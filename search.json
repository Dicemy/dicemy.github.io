[{"title":"河南大学暑假集训的日常（4）","url":"https://dicemy.github.io/43344.html","content":"DAY7（DP进阶）POJ - 2342 Anniversary party（树形DP）\n入门树形DP。\n用vector将边存下来，然后将一个点作为树的根节点进行dp，d[x][0]表示编号为x的员工不参加的愉悦值，d[x][1]表示编号为x的员工参加的愉悦值。v节点表示x节点所连的边，转移方程为：d[x][1] += d[v][0]; d[x][0] += max(d[v][1], d[v][0]); \n代码：\n12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#define endl &#x27;\\n&#x27;using namespace std;typedef long long ll;const ll maxn = 6010;ll n, u, v;ll d[maxn][2];bool vis[maxn];vector&lt;int&gt; son[maxn];void dfs(int x) &#123;\tvis[x] = 1;\tfor (int i=0;i&lt;son[x].size();++i) &#123;\t\tint v = son[x][i];\t\tif (!vis[v]) &#123;\t\t\tdfs(v);\t\t\td[x][1] += d[v][0];\t\t\td[x][0] += max(d[v][1], d[v][0]);\t\t&#125;\t&#125;&#125;int main() &#123;\twhile(cin &gt;&gt; n) &#123;\t\tmemset(d, 0, sizeof(d));\t\tmemset(vis, 0, sizeof(vis));\t\tfor (int i=1;i&lt;=n;++i) &#123;\t\t\tcin &gt;&gt; d[i][1];\t\t\td[i][0] = 0;\t\t\tson[i].clear();\t\t&#125;\t\twhile(cin &gt;&gt; u &gt;&gt; v &amp;&amp; !(u == 0 &amp;&amp; v == 0)) &#123;\t\t\tson[u].push_back(v);\t\t\tson[v].push_back(u);\t\t&#125;\t\tdfs(1);\t\tcout &lt;&lt; max(d[1][0], d[1][1]) &lt;&lt; endl;\t&#125;\treturn #include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#define endl &#x27;\\n&#x27;using namespace std;typedef long long ll;const ll maxn = 6010;ll n, u, v;ll d[maxn][2];bool vis[maxn];vector&lt;int&gt; son[maxn];void dfs(int x) &#123;\tvis[x] = 1;\tfor (int i=0;i&lt;son[x].size();++i) &#123;\t\tint v = son[x][i];\t\tif (!vis[v]) &#123;\t\t\tdfs(v);\t\t\td[x][1] += d[v][0];\t\t\td[x][0] += max(d[v][1], d[v][0]);\t\t&#125;\t&#125;&#125;int main() &#123;\twhile(cin &gt;&gt; n) &#123;\t\tmemset(d, 0, sizeof(d));\t\tmemset(vis, 0, sizeof(vis));\t\tfor (int i=1;i&lt;=n;++i) &#123;\t\t\tcin &gt;&gt; d[i][1];\t\t\td[i][0] = 0;\t\t\tson[i].clear();\t\t&#125;\t\twhile(cin &gt;&gt; u &gt;&gt; v &amp;&amp; !(u == 0 &amp;&amp; v == 0)) &#123;\t\t\tson[u].push_back(v);\t\t\tson[v].push_back(u);\t\t&#125;\t\tdfs(1);\t\tcout &lt;&lt; max(d[1][0], d[1][1]) &lt;&lt; endl;\t&#125;\treturn 0;&#125;\n\nLibreOJ - 10156 战略游戏（树形DP）\n和上一道题很像，d[x][0]表示x站点处没有哨兵所需要的消耗，d[x][1]表示x站点处有哨兵所需要的消耗。转移方程做了一点小小的改动： d[x][0] += d[v][1]; d[x][1] += min(d[v][1], d[v][0]); \n代码：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#define endl &#x27;\\n&#x27;using namespace std;typedef long long ll;const ll maxn = 6010;ll n, u, v, k;ll d[maxn][2];bool vis[maxn];vector&lt;int&gt; son[maxn];void dfs(int x) &#123;\tvis[x] = 1;\tfor (int i=0;i&lt;son[x].size();++i) &#123;\t\tint v = son[x][i];\t\tif (!vis[v]) &#123;\t\t\tdfs(v);\t\t\td[x][0] += d[v][1];\t\t\td[x][1] += min(d[v][1], d[v][0]);\t\t&#125;\t&#125;&#125;int main() &#123;\twhile(cin &gt;&gt; n) &#123;\t\tmemset(d, 0, sizeof(d));\t\tmemset(vis, 0, sizeof(vis));\t\tfor (int i=1;i&lt;=n;++i) &#123;\t\t\tcin &gt;&gt; u &gt;&gt; k;\t\t\td[u][1] = 1;\t\t\td[u][0] = 0;\t\t\tfor (int i=1;i&lt;=k;++i) &#123;\t\t\t\tcin &gt;&gt; v;\t\t\t\tson[u].push_back(v);\t\t\t\tson[v].push_back(u);\t\t\t&#125;\t\t&#125;\t\tdfs(0);\t\tcout &lt;&lt; min(d[0][0], d[0][1]) &lt;&lt; endl;\t&#125;\treturn #include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#define endl &#x27;\\n&#x27;using namespace std;typedef long long ll;const ll maxn = 6010;ll n, u, v, k;ll d[maxn][2];bool vis[maxn];vector&lt;int&gt; son[maxn];void dfs(int x) &#123;\tvis[x] = 1;\tfor (int i=0;i&lt;son[x].size();++i) &#123;\t\tint v = son[x][i];\t\tif (!vis[v]) &#123;\t\t\tdfs(v);\t\t\td[x][0] += d[v][1];\t\t\td[x][1] += min(d[v][1], d[v][0]);\t\t&#125;\t&#125;&#125;int main() &#123;\twhile(cin &gt;&gt; n) &#123;\t\tmemset(d, 0, sizeof(d));\t\tmemset(vis, 0, sizeof(vis));\t\tfor (int i=1;i&lt;=n;++i) &#123;\t\t\tcin &gt;&gt; u &gt;&gt; k;\t\t\td[u][1] = 1;\t\t\td[u][0] = 0;\t\t\tfor (int i=1;i&lt;=k;++i) &#123;\t\t\t\tcin &gt;&gt; v;\t\t\t\tson[u].push_back(v);\t\t\t\tson[v].push_back(u);\t\t\t&#125;\t\t&#125;\t\tdfs(0);\t\tcout &lt;&lt; min(d[0][0], d[0][1]) &lt;&lt; endl;\t&#125;\treturn 0;&#125;\n\n","categories":[],"tags":[]},{"title":"河南大学暑假集训的日常（3）","url":"https://dicemy.github.io/56657.html","content":"DAY5（线段树）HDU - 1394 Minimum Inversion Number（树状数组/线段树）\n和昨天的题撞了，用树状数组求数列的逆序对。\n代码：\n12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#define TobinMEng caicai#define int llusing namespace std;typedef long long ll;const int maxn = 5010;int n, a[maxn &lt;&lt; 2], f[maxn &lt;&lt; 2];int tmp, ans;inline int lowbit(int x) &#123;return -x&amp;x;&#125;void update(int x, int v) &#123;for (; x&lt;=n; x+=lowbit(x))f[x] += v;&#125;int ask(int x, int res = 0) &#123;for (; x&gt;=1;x-=lowbit(x)) res += f[x];return res;&#125;signed main() &#123;\twhile(scanf(&quot;%d&quot;, &amp;n) != EOF) &#123;\t\tmemset(a, 0, sizeof(a));\t\tmemset(f, 0, sizeof(f));\t\ttmp = ans = 0;\t\tfor (int i=1;i&lt;=n;++i) &#123;\t\t\tscanf(&quot;%d&quot;, &amp;a[i]);\t\t\ta[i]++; \t\t\tupdate(a[i], 1);\t\t\ttmp += (i - ask(a[i]));\t\t&#125;\t\tans = tmp;\t\tfor (int i=1;i&lt;n;++i) &#123;\t\t\ttmp += (n - 2 * a[i] + 1);\t\t\tans = min(ans, tmp);\t\t&#125;\t\tprintf(&quot;%d\\n&quot;, ans);\t&#125;\treturn #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#define TobinMEng caicai#define int llusing namespace std;typedef long long ll;const int maxn = 5010;int n, a[maxn &lt;&lt; 2], f[maxn &lt;&lt; 2];int tmp, ans;inline int lowbit(int x) &#123;return -x&amp;x;&#125;void update(int x, int v) &#123;for (; x&lt;=n; x+=lowbit(x))f[x] += v;&#125;int ask(int x, int res = 0) &#123;for (; x&gt;=1;x-=lowbit(x)) res += f[x];return res;&#125;signed main() &#123;\twhile(scanf(&quot;%d&quot;, &amp;n) != EOF) &#123;\t\tmemset(a, 0, sizeof(a));\t\tmemset(f, 0, sizeof(f));\t\ttmp = ans = 0;\t\tfor (int i=1;i&lt;=n;++i) &#123;\t\t\tscanf(&quot;%d&quot;, &amp;a[i]);\t\t\ta[i]++; \t\t\tupdate(a[i], 1);\t\t\ttmp += (i - ask(a[i]));\t\t&#125;\t\tans = tmp;\t\tfor (int i=1;i&lt;n;++i) &#123;\t\t\ttmp += (n - 2 * a[i] + 1);\t\t\tans = min(ans, tmp);\t\t&#125;\t\tprintf(&quot;%d\\n&quot;, ans);\t&#125;\treturn 0;&#125;\n\nHDU - 1698 Just a Hook（线段树）\n是一个将区间覆盖修改为一个相同的数并维护区间的和的一个线段树板子题。\n代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#define int long longusing namespace std;const int maxn = 200010;int n, m, T, l, r, v;struct SegmentTree &#123;\tint l, r;\tint dat, add;\t#define l(p) tree[p].l\t#define r(p) tree[p].r\t#define dat(p) tree[p].dat\t#define add(p) tree[p].add&#125;tree[maxn &lt;&lt; 2];inline int Read() &#123;\tint x=0,f=1;char ch=getchar();\twhile(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125;\twhile(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125;\treturn x*f;&#125;inline void update(int p) &#123;dat(p) = dat(p &lt;&lt; 1) + dat((p &lt;&lt; 1) | 1);&#125;inline void spread(int p) &#123;\tif (add(p)) &#123;\t\tadd(p &lt;&lt; 1) =  add(p);\t\tadd((p &lt;&lt; 1) | 1) = add(p);\t\tdat(p &lt;&lt; 1) = add(p) * (r(p &lt;&lt; 1) - l(p &lt;&lt; 1) + 1);\t\tdat((p &lt;&lt; 1) | 1) = add(p) * (r((p &lt;&lt; 1) | 1) - l((p &lt;&lt; 1) | 1) + 1);\t\tadd(p) = 0;\t&#125;&#125;void build(int p, int l, int r) &#123;\tl(p) = l; r(p) = r; add(p) = 0;\tif (l == r) &#123;dat(p) = 1;return;&#125;\tint mid = (l + r) &gt;&gt; 1;\tbuild(p &lt;&lt; 1, l, mid);\tbuild((p &lt;&lt; 1) | 1, mid + 1, r);\tupdate(p);&#125;void change(int p, int l, int r, int v) &#123;\tif (l &lt;= l(p) &amp;&amp; r(p) &lt;= r) &#123;\t\tdat(p) = v * (r(p) - l(p) + 1);//对于区间覆盖修改的值和区间加减修改的值是有区别的。\t\tadd(p) = v;\t\treturn;\t&#125;\tspread(p);\tint mid = (l(p) + r(p)) &gt;&gt; 1;\tif (l &lt;= mid) change(p &lt;&lt; 1, l, r, v);\tif (r &gt; mid) change((p &lt;&lt; 1) | 1, l, r, v);\tupdate(p);&#125;signed main() &#123;\tT = Read();\tfor (int t=1;t&lt;=T;++t) &#123;\t\tn = Read(); m = Read();\t\tbuild(1, 1, n);\t\tfor (int i=1;i&lt;=m;++i) &#123;\t\t\tl = Read(); r = Read(); v = Read();\t\t\tchange(1, l, r, v);\t\t&#125;\t\tprintf(&quot;Case %lld: The total value of the hook is %lld.\\n&quot;, t, dat(#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#define int long longusing namespace std;const int maxn = 200010;int n, m, T, l, r, v;struct SegmentTree &#123;\tint l, r;\tint dat, add;\t#define l(p) tree[p].l\t#define r(p) tree[p].r\t#define dat(p) tree[p].dat\t#define add(p) tree[p].add&#125;tree[maxn &lt;&lt; 2];inline int Read() &#123;\tint x=0,f=1;char ch=getchar();\twhile(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125;\twhile(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125;\treturn x*f;&#125;inline void update(int p) &#123;dat(p) = dat(p &lt;&lt; 1) + dat((p &lt;&lt; 1) | 1);&#125;inline void spread(int p) &#123;\tif (add(p)) &#123;\t\tadd(p &lt;&lt; 1) =  add(p);\t\tadd((p &lt;&lt; 1) | 1) = add(p);\t\tdat(p &lt;&lt; 1) = add(p) * (r(p &lt;&lt; 1) - l(p &lt;&lt; 1) + 1);\t\tdat((p &lt;&lt; 1) | 1) = add(p) * (r((p &lt;&lt; 1) | 1) - l((p &lt;&lt; 1) | 1) + 1);\t\tadd(p) = 0;\t&#125;&#125;void build(int p, int l, int r) &#123;\tl(p) = l; r(p) = r; add(p) = 0;\tif (l == r) &#123;dat(p) = 1;return;&#125;\tint mid = (l + r) &gt;&gt; 1;\tbuild(p &lt;&lt; 1, l, mid);\tbuild((p &lt;&lt; 1) | 1, mid + 1, r);\tupdate(p);&#125;void change(int p, int l, int r, int v) &#123;\tif (l &lt;= l(p) &amp;&amp; r(p) &lt;= r) &#123;\t\tdat(p) = v * (r(p) - l(p) + 1);//对于区间覆盖修改的值和区间加减修改的值是有区别的。\t\tadd(p) = v;\t\treturn;\t&#125;\tspread(p);\tint mid = (l(p) + r(p)) &gt;&gt; 1;\tif (l &lt;= mid) change(p &lt;&lt; 1, l, r, v);\tif (r &gt; mid) change((p &lt;&lt; 1) | 1, l, r, v);\tupdate(p);&#125;signed main() &#123;\tT = Read();\tfor (int t=1;t&lt;=T;++t) &#123;\t\tn = Read(); m = Read();\t\tbuild(1, 1, n);\t\tfor (int i=1;i&lt;=m;++i) &#123;\t\t\tl = Read(); r = Read(); v = Read();\t\t\tchange(1, l, r, v);\t\t&#125;\t\tprintf(&quot;Case %lld: The total value of the hook is %lld.\\n&quot;, t, dat(1));\t&#125;&#125;\n\nHDU - 1754 I Hate It （线段树）\n单点修改+区间最值线段树模板\n代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 2000010;int n, m, l, r;int a[maxn];char od[5];struct node &#123;\tint l, r;\tint dat, add; \t#define l(x) tree[x].l\t#define r(x) tree[x].r\t#define dat(x) tree[x].dat&#125;tree[maxn &lt;&lt; 2];inline int Read() &#123;\tint x=0,f=1;char ch=getchar();\twhile(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125;\twhile(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125;\treturn x*f;&#125;inline void update(int p) &#123;dat(p) = max(dat(p&lt;&lt;1), dat(p&lt;&lt;1|1));&#125;void build(int p, int l, int r) &#123;\tl(p) = l; r(p) = r;\tif (l == r)\t&#123;dat(p) = a[l];return;&#125;\t\tint mid = (l + r) &gt;&gt; 1;\tbuild(p &lt;&lt; 1, l, mid);\tbuild(p &lt;&lt; 1 | 1, mid + 1, r);\tupdate(p);&#125;void init() &#123;\tfor (int i=1;i&lt;=n;++i)\ta[i] = Read();\tbuild(1, 1, n);&#125;void change(int p, int x, int v) &#123;\tif (l(p) == r(p)) &#123;\t\tdat(p) = v;\t\treturn;\t&#125;\tint mid = (l(p) + r(p)) &gt;&gt; 1;\tif (x &lt;= mid) change(p &lt;&lt; 1, x, v);\tif (x &gt; mid) change(p &lt;&lt; 1 | 1, x, v);\tupdate(p);&#125;int ask(int p, int l, int r) &#123;\tif (l &lt;= l(p) &amp;&amp; r(p) &lt;= r)\treturn dat(p);\tint mid = (l(p) + r(p)) &gt;&gt; 1;\tint res = 0;\tif (l &lt;= mid) res = max(res, ask(p &lt;&lt; 1, l, r));\tif (r &gt; mid) res = max(res, ask(p &lt;&lt; 1 | 1, l, r));\treturn res;&#125;int main() &#123;\twhile(scanf(&quot;%d%d&quot;, &amp;n,&amp;m) != EOF) &#123;\t\tinit(); \t\tfor (int i=1;i&lt;=m;++i) &#123;\t\t\tscanf(&quot;%s&quot;, od);\t\t\tl = Read(); r = Read();\t\t\tif (od[0] == &#x27;Q&#x27;) printf(&quot;%d\\n&quot;, ask(1, l, r));\t\t\telse change(1, l, r);\t\t&#125;\t&#125;\treturn #include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 2000010;int n, m, l, r;int a[maxn];char od[5];struct node &#123;\tint l, r;\tint dat, add; \t#define l(x) tree[x].l\t#define r(x) tree[x].r\t#define dat(x) tree[x].dat&#125;tree[maxn &lt;&lt; 2];inline int Read() &#123;\tint x=0,f=1;char ch=getchar();\twhile(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125;\twhile(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125;\treturn x*f;&#125;inline void update(int p) &#123;dat(p) = max(dat(p&lt;&lt;1), dat(p&lt;&lt;1|1));&#125;void build(int p, int l, int r) &#123;\tl(p) = l; r(p) = r;\tif (l == r)\t&#123;dat(p) = a[l];return;&#125;\t\tint mid = (l + r) &gt;&gt; 1;\tbuild(p &lt;&lt; 1, l, mid);\tbuild(p &lt;&lt; 1 | 1, mid + 1, r);\tupdate(p);&#125;void init() &#123;\tfor (int i=1;i&lt;=n;++i)\ta[i] = Read();\tbuild(1, 1, n);&#125;void change(int p, int x, int v) &#123;\tif (l(p) == r(p)) &#123;\t\tdat(p) = v;\t\treturn;\t&#125;\tint mid = (l(p) + r(p)) &gt;&gt; 1;\tif (x &lt;= mid) change(p &lt;&lt; 1, x, v);\tif (x &gt; mid) change(p &lt;&lt; 1 | 1, x, v);\tupdate(p);&#125;int ask(int p, int l, int r) &#123;\tif (l &lt;= l(p) &amp;&amp; r(p) &lt;= r)\treturn dat(p);\tint mid = (l(p) + r(p)) &gt;&gt; 1;\tint res = 0;\tif (l &lt;= mid) res = max(res, ask(p &lt;&lt; 1, l, r));\tif (r &gt; mid) res = max(res, ask(p &lt;&lt; 1 | 1, l, r));\treturn res;&#125;int main() &#123;\twhile(scanf(&quot;%d%d&quot;, &amp;n,&amp;m) != EOF) &#123;\t\tinit(); \t\tfor (int i=1;i&lt;=m;++i) &#123;\t\t\tscanf(&quot;%s&quot;, od);\t\t\tl = Read(); r = Read();\t\t\tif (od[0] == &#x27;Q&#x27;) printf(&quot;%d\\n&quot;, ask(1, l, r));\t\t\telse change(1, l, r);\t\t&#125;\t&#125;\treturn 0;&#125;\n\nHDU - 1166 敌兵布阵（树状数组）\n一个简单的树状数组，区间加减，区间求和\n代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;typedef long long ll;using namespace std;const int maxn = 50010;int T, n, l, r;int a[maxn], c[maxn];string od;inline int Read() &#123;\tint x=0,f=1;char ch=getchar();\twhile(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125;\twhile(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125;\treturn x*f;&#125;inline int ask(int x, int res = 0) &#123;for (; x&gt;=1; x-=(x&amp;-x))\tres += c[x];return res;&#125;inline void update(int x, int v) &#123;for (; x&lt;=n; x+=(x&amp;-x)) c[x] += v;&#125;inline int query(int l, int r) &#123;return ask(r) - ask(l - 1);&#125;inline void init() &#123;\tn = Read();\tmemset(c, 0, sizeof(c));\tmemset(a, 0, sizeof(a));\tfor (int i=1;i&lt;=n;++i) &#123;\t\ta[i] = Read();\t\t\tupdate(i, a[i]);\t&#125;&#125;int main() &#123;\tT = Read();\tfor (int i=1;i&lt;=T;++i) &#123;\t\tinit();\t\tprintf(&quot;Case %d:\\n&quot;, i);\t\twhile(cin &gt;&gt; od &amp;&amp; od != &quot;End&quot;) &#123;\t\t\tl = Read(); r = Read();\t\t\tif (od == &quot;Add&quot;) update(l, r);\t\t\tif (od == &quot;Sub&quot;) update(l, -r);\t\t\tif (od == &quot;Query&quot;) printf(&quot;%d\\n&quot;, query(l, r));\t\t&#125;\t&#125;\treturn #include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;typedef long long ll;using namespace std;const int maxn = 50010;int T, n, l, r;int a[maxn], c[maxn];string od;inline int Read() &#123;\tint x=0,f=1;char ch=getchar();\twhile(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125;\twhile(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125;\treturn x*f;&#125;inline int ask(int x, int res = 0) &#123;for (; x&gt;=1; x-=(x&amp;-x))\tres += c[x];return res;&#125;inline void update(int x, int v) &#123;for (; x&lt;=n; x+=(x&amp;-x)) c[x] += v;&#125;inline int query(int l, int r) &#123;return ask(r) - ask(l - 1);&#125;inline void init() &#123;\tn = Read();\tmemset(c, 0, sizeof(c));\tmemset(a, 0, sizeof(a));\tfor (int i=1;i&lt;=n;++i) &#123;\t\ta[i] = Read();\t\t\tupdate(i, a[i]);\t&#125;&#125;int main() &#123;\tT = Read();\tfor (int i=1;i&lt;=T;++i) &#123;\t\tinit();\t\tprintf(&quot;Case %d:\\n&quot;, i);\t\twhile(cin &gt;&gt; od &amp;&amp; od != &quot;End&quot;) &#123;\t\t\tl = Read(); r = Read();\t\t\tif (od == &quot;Add&quot;) update(l, r);\t\t\tif (od == &quot;Sub&quot;) update(l, -r);\t\t\tif (od == &quot;Query&quot;) printf(&quot;%d\\n&quot;, query(l, r));\t\t&#125;\t&#125;\treturn 0;&#125; \n\nDAY6（DP入门）LibreOJ - 10147 石子合并（区间DP）\n经典区间DP。\n数组复制到2n保证成环，枚举区间长度，然后遍历每一个区间，每一个区间由该区间中间分开成的两个区间转移过来，f[i][j]表示i到j区间上进行合并的最大或者最小消耗是多少。转移方程为f1[l][r] = min(f1[l][r], f1[l][k] + f1[k+1][r]); f1[l][r] += sum[r] - sum[l-1];\n代码：\n1234567891011121314151617181920212223242526272829303132333435363738# include &lt;iostream&gt;# include &lt;cstring&gt;# include &lt;cstdio&gt;# include &lt;algorithm&gt;using namespace std;const int INF = 99999999;int f1[205][205], f2[205][205], a[205], sum[205];int n, ans1 = INF, ans2 = 0;int main() &#123;\tscanf(&quot;%d&quot;, &amp;n);\tfor (int i=1;i&lt;=n;++i) &#123;\t\tscanf(&quot;%d&quot;, &amp;a[i]);\t\ta[i+n] = a[i];\t&#125;\tmemset(f1, 0x3f, sizeof(f1));\tfor (int i=1;i&lt;=n*2;++i) &#123;\t\tf1[i][i] = 0;\t\tsum[i] = sum[i-1] + a[i];\t&#125;\tfor (int len=2;len&lt;=n;++len) &#123;\t\tfor (int l=1;l&lt;=n*2-len+1;++l) &#123;\t\t\tint r = l + len - 1;\t\t\tfor (int k=l;k&lt;r;++k) &#123;\t\t\t\tf1[l][r] = min(f1[l][r], f1[l][k] + f1[k+1][r]);\t\t\t\tf2[l][r] = max(f2[l][r], f2[l][k] + f2[k+1][r]);\t\t\t&#125;\t\t\tf1[l][r] += sum[r] - sum[l-1];\t\t\tf2[l][r] += sum[r] - sum[l-1];\t\t&#125;\t&#125;\tfor (int i=1;i&lt;=n;++i) &#123;\t\tans1 = min(ans1, f1[i][i+n-1]);\t\tans2 = max(ans2, f2[i][i+n-1]);\t&#125;\tprintf(&quot;%d\\n%d\\n&quot;, ans1, ans2);\treturn # include &lt;iostream&gt;# include &lt;cstring&gt;# include &lt;cstdio&gt;# include &lt;algorithm&gt;using namespace std;const int INF = 99999999;int f1[205][205], f2[205][205], a[205], sum[205];int n, ans1 = INF, ans2 = 0;int main() &#123;\tscanf(&quot;%d&quot;, &amp;n);\tfor (int i=1;i&lt;=n;++i) &#123;\t\tscanf(&quot;%d&quot;, &amp;a[i]);\t\ta[i+n] = a[i];\t&#125;\tmemset(f1, 0x3f, sizeof(f1));\tfor (int i=1;i&lt;=n*2;++i) &#123;\t\tf1[i][i] = 0;\t\tsum[i] = sum[i-1] + a[i];\t&#125;\tfor (int len=2;len&lt;=n;++len) &#123;\t\tfor (int l=1;l&lt;=n*2-len+1;++l) &#123;\t\t\tint r = l + len - 1;\t\t\tfor (int k=l;k&lt;r;++k) &#123;\t\t\t\tf1[l][r] = min(f1[l][r], f1[l][k] + f1[k+1][r]);\t\t\t\tf2[l][r] = max(f2[l][r], f2[l][k] + f2[k+1][r]);\t\t\t&#125;\t\t\tf1[l][r] += sum[r] - sum[l-1];\t\t\tf2[l][r] += sum[r] - sum[l-1];\t\t&#125;\t&#125;\tfor (int i=1;i&lt;=n;++i) &#123;\t\tans1 = min(ans1, f1[i][i+n-1]);\t\tans2 = max(ans2, f2[i][i+n-1]);\t&#125;\tprintf(&quot;%d\\n%d\\n&quot;, ans1, ans2);\treturn 0;&#125;\n\nHDU - 1257 最少拦截系统（LIS）\n最长上升子序列的板子题。\n该题要求一个序列的最长不下降子序列的个数，可以转化为求一个序列的最长上升子序列的长度。该写法时间复杂度O(n^2)。有nlogn的写法，暂时不想去复习:)\n代码：\n12345678910111213141516171819202122232425#include&lt;iostream&gt; #include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;const ll maxn = 30010; ll a[maxn], d[maxn];ll n, ans;int main() &#123;\twhile(~scanf(&quot;%d&quot;, &amp;n)) &#123;\t\tans = 0;\t\tfor (int i=1;i&lt;=n;++i)\tscanf(&quot;%d&quot;, &amp;a[i]);\t\tfor (int i=1;i&lt;=n;++i) &#123;\t\t\td[i] = 1;\t\t\tfor (int j=1;j&lt;i;++j) &#123;\t\t\t\tif (a[j] &lt; a[i])\t\t\t\t\td[i] = max(d[j] + 1, d[i]);\t\t\t\tans = max(ans, d[i]);\t\t\t&#125;\t\t&#125;\t\tprintf(&quot;%d\\n&quot;, ans);\t&#125;\treturn #include&lt;iostream&gt; #include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;const ll maxn = 30010; ll a[maxn], d[maxn];ll n, ans;int main() &#123;\twhile(~scanf(&quot;%d&quot;, &amp;n)) &#123;\t\tans = 0;\t\tfor (int i=1;i&lt;=n;++i)\tscanf(&quot;%d&quot;, &amp;a[i]);\t\tfor (int i=1;i&lt;=n;++i) &#123;\t\t\td[i] = 1;\t\t\tfor (int j=1;j&lt;i;++j) &#123;\t\t\t\tif (a[j] &lt; a[i])\t\t\t\t\td[i] = max(d[j] + 1, d[i]);\t\t\t\tans = max(ans, d[i]);\t\t\t&#125;\t\t&#125;\t\tprintf(&quot;%d\\n&quot;, ans);\t&#125;\treturn 0;&#125;\n\nHDU - 1176 Bone Collector（01背包）\n经典01背包板子题。\n代码：\n123456789101112131415161718192021222324252627#include&lt;iostream&gt; #include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;const ll maxn = 1010;ll T, n, v;ll w[maxn], c[maxn], d[maxn];int main() &#123;\tscanf(&quot;%lld&quot;, &amp;T);\twhile(T--) &#123;\t\tscanf(&quot;%lld%lld&quot;, &amp;n, &amp;v);\t\tmemset(w, 0, sizeof(w));\t\tmemset(c, 0, sizeof(c));\t\tmemset(d, 0, sizeof(d));\t\tfor (int i=1;i&lt;=n;++i)\tscanf(&quot;%lld&quot;, &amp;c[i]);\t\tfor (int i=1;i&lt;=n;++i)\tscanf(&quot;%lld&quot;, &amp;w[i]);\t\tfor (int i=1;i&lt;=n;++i) &#123;\t\t\tfor (int j=v;j&gt;=w[i];--j) &#123;\t\t\t\t\td[j] = max(d[j], d[j-w[i]]+c[i]);\t\t\t&#125;\t\t&#125;\t\tprintf(&quot;%lld\\n&quot;, d[v]);\t&#125;\treturn #include&lt;iostream&gt; #include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;const ll maxn = 1010;ll T, n, v;ll w[maxn], c[maxn], d[maxn];int main() &#123;\tscanf(&quot;%lld&quot;, &amp;T);\twhile(T--) &#123;\t\tscanf(&quot;%lld%lld&quot;, &amp;n, &amp;v);\t\tmemset(w, 0, sizeof(w));\t\tmemset(c, 0, sizeof(c));\t\tmemset(d, 0, sizeof(d));\t\tfor (int i=1;i&lt;=n;++i)\tscanf(&quot;%lld&quot;, &amp;c[i]);\t\tfor (int i=1;i&lt;=n;++i)\tscanf(&quot;%lld&quot;, &amp;w[i]);\t\tfor (int i=1;i&lt;=n;++i) &#123;\t\t\tfor (int j=v;j&gt;=w[i];--j) &#123;\t\t\t\t\td[j] = max(d[j], d[j-w[i]]+c[i]);\t\t\t&#125;\t\t&#125;\t\tprintf(&quot;%lld\\n&quot;, d[v]);\t&#125;\treturn 0;&#125;\n\nHDU - 2084 数塔（DP）\n经典入门DP\n代码：\n123456789101112131415161718192021222324252627#include&lt;iostream&gt; #include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;int n, T;int a[110][110];int d[110][110];void work() &#123;\tmemset(a, 0, sizeof(a));\tmemset(d, 0, sizeof(d));\tscanf(&quot;%d&quot;, &amp;n);\tfor (int i=1;i&lt;=n;++i) &#123;\t\tfor (int j=1;j&lt;=i;++j) &#123;\t\t\tscanf(&quot;%d&quot;, &amp;a[i][j]);\t\t\td[i][j] = max(d[i-1][j-1] + a[i][j], d[i-1][j] + a[i][j]);\t\t&#125;\t&#125;\tint ans = 0;\tfor (int i=1;i&lt;=n;++i)\tans = max(ans, d[n][i]);\tprintf(&quot;%d\\n&quot;, ans);&#125;int main() &#123;\tscanf(&quot;%d&quot;, &amp;T);\twhile(T--) work();\treturn #include&lt;iostream&gt; #include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;int n, T;int a[110][110];int d[110][110];void work() &#123;\tmemset(a, 0, sizeof(a));\tmemset(d, 0, sizeof(d));\tscanf(&quot;%d&quot;, &amp;n);\tfor (int i=1;i&lt;=n;++i) &#123;\t\tfor (int j=1;j&lt;=i;++j) &#123;\t\t\tscanf(&quot;%d&quot;, &amp;a[i][j]);\t\t\td[i][j] = max(d[i-1][j-1] + a[i][j], d[i-1][j] + a[i][j]);\t\t&#125;\t&#125;\tint ans = 0;\tfor (int i=1;i&lt;=n;++i)\tans = max(ans, d[n][i]);\tprintf(&quot;%d\\n&quot;, ans);&#125;int main() &#123;\tscanf(&quot;%d&quot;, &amp;T);\twhile(T--) work();\treturn 0;&#125;\n\n","categories":[],"tags":[]},{"title":"Spring Boot入门","url":"https://dicemy.github.io/12868.html","content":"一、String Boot入门1、Spring Boot简介\n简化spring应用开发的一个框架；整个Spring技术栈的一个大整合；J2EE开发的一站式解决方案；\n\n2、微服务2014，martin fowler微服务：架构风格（服务微化）一个应用应该是一组小型服务；可以通过HTTP的方式进行互通；\n每一个功能元素最终都是一个可独立替换和独立升级的软件单元；\n环境约束-jdk1.8-maven3.3.9-IDEA-Spring Boot 1.5.9\n","categories":[],"tags":[]},{"title":"TobinMEng的代码模板大合集","url":"https://dicemy.github.io/58095.html","content":"代码模板。\n巨长的代码模板。\n拿来了高中的代码模板然后持续更新。\n图论图图的储存和插入12345int head[maxn], ver[maxm], Next[maxm], edge[maxm], tot;inline void adde(int x, int y, int head[maxn], ver[maxm], Next[maxm], edge[maxm], tot;inline void adde(int x, int y, int v) &#123;\tNext[++tot] = head[x]; head[x] = tot;\tver[tot] = y; edge[tot] = v;&#125; \n\n连通块的划分（图的染色）1234567891011121314void dfs(int x) &#123;    color[x] = cnt;    for (int i=head[x]; i; i=Next[i]) &#123;        int y = ver[i];        if (color[y]) continue;        dfs(y);    &#125;&#125;for (int i=1;i&lt;=n;++i) &#123;    if (!color[i]) &#123;        cnt++;        void dfs(int x) &#123;    color[x] = cnt;    for (int i=head[x]; i; i=Next[i]) &#123;        int y = ver[i];        if (color[y]) continue;        dfs(y);    &#125;&#125;for (int i=1;i&lt;=n;++i) &#123;    if (!color[i]) &#123;        cnt++;        dfs(i);    &#125;&#125;\n\nBFS遍历一个树/图123456789101112131415void bfs() &#123;    queue&lt;int&gt; q;    memset(d, 0, sizeof(d));//如果搜索的是一棵树的话， 那么d数组指的是节点x在树中的深度。如果是一张图的话， d数组指的是x的层次， （从起点1走到x所要经历的最少点数）。    q.push(1); d[1] = 1;    while(q.size()) &#123;        int x = q.front(); q.pop();        for (int i=head[x]; i; i=Next[i]) &#123;            int y = ver[i];            if (d[y]) continue;            d[y] = d[x] + 1;            q.push(y);        &#125;    &#125;&#125;//bfs有两个重要的性质， 1.在访问过所有的第i层节点之后，才会开始访问i+1层节点2.任意时刻，队列里只会出现i层的节点和i+1层的节点，并且所有的第i层节点都在第i+1层节点之前。（简单来说就是满足“两端性”和“单调性”）void bfs() &#123;    queue&lt;int&gt; q;    memset(d, 0, sizeof(d));//如果搜索的是一棵树的话， 那么d数组指的是节点x在树中的深度。如果是一张图的话， d数组指的是x的层次， （从起点1走到x所要经历的最少点数）。    q.push(1); d[1] = 1;    while(q.size()) &#123;        int x = q.front(); q.pop();        for (int i=head[x]; i; i=Next[i]) &#123;            int y = ver[i];            if (d[y]) continue;            d[y] = d[x] + 1;            q.push(y);        &#125;    &#125;&#125;//bfs有两个重要的性质， 1.在访问过所有的第i层节点之后，才会开始访问i+1层节点2.任意时刻，队列里只会出现i层的节点和i+1层的节点，并且所有的第i层节点都在第i+1层节点之前。（简单来说就是满足“两端性”和“单调性”）//并且dfs的时间复杂度和bfs的时间复杂度是相同的， 都为O(n+e)的时间复杂度，只不过限制两个算法的一个是堆栈大小， 一个是队列的大小\n\nDijkstra简单的正确性证明\n123456789101112131415161718void Dijkstra(int x) &#123;    priority_queue&lt;pair&lt;ll ll&gt; &gt; q;    for (int i=1;i&lt;=n;++i)\tdis[i] = INF, vis[i] = false;    dis[x] = 0;    q.push(make_pair(0, x));    while(q.size()) &#123;        int x = q.top().second;\tq.pop();        if (vis[x]) continue;        vis[x] = true;        for (int i=head[x]; i; i=Next[i]) &#123;            int y = ver[i], w = edge[i];            if (dis[y] &gt; dis[x] + w) &#123;//由于是拿出现在堆中最小的点x来更新其相邻的点， 所以写的顺序需要注意                dis[y] = dis[x] + w;                q.push(make_pair(-dis[y], y));            &#125;        &#125;    &#125;&#125;void Dijkstra(int x) &#123;    priority_queue&lt;pair&lt;ll ll&gt; &gt; q;    for (int i=1;i&lt;=n;++i)\tdis[i] = INF, vis[i] = false;    dis[x] = 0;    q.push(make_pair(0, x));    while(q.size()) &#123;        int x = q.top().second;\tq.pop();        if (vis[x]) continue;        vis[x] = true;        for (int i=head[x]; i; i=Next[i]) &#123;            int y = ver[i], w = edge[i];            if (dis[y] &gt; dis[x] + w) &#123;//由于是拿出现在堆中最小的点x来更新其相邻的点， 所以写的顺序需要注意                dis[y] = dis[x] + w;                q.push(make_pair(-dis[y], y));            &#125;        &#125;    &#125;&#125;//适用于有向图和无向图中，只适用于边长不为负的图。时间复杂度为O((n+m)log(n));\n\nSPFA\n12345678910111213141516171819void SPFA(int x) &#123;\tqueue&lt;int&gt; q;\tfor (int i=1;i&lt;=n;++i)\tdis[i] = INT, vis[i] = false;\tdis[x] = 0; q.push(x); vis[x] = true;\twhile (q.size()) &#123;\t\tint x = q.front();\t\tq.pop(); vis[x] = false;//vis表示该点是否在队列中\t\tfor (int i=head[x];i;i=Next[i]) &#123;\t\t\tint y = ver[i], w = edge[i];\t\t\tif (dis[y] &gt; dis[x] + w) &#123;\t\t\t\tdis[y] = dis[x] + w;\t\t\t\tif (vis[y] == false) &#123;\t\t\t\t\tvis[y] = true;\t\t\t\t\tq.push(y);\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;&#125;void SPFA(int x) &#123;\tqueue&lt;int&gt; q;\tfor (int i=1;i&lt;=n;++i)\tdis[i] = INT, vis[i] = false;\tdis[x] = 0; q.push(x); vis[x] = true;\twhile (q.size()) &#123;\t\tint x = q.front();\t\tq.pop(); vis[x] = false;//vis表示该点是否在队列中\t\tfor (int i=head[x];i;i=Next[i]) &#123;\t\t\tint y = ver[i], w = edge[i];\t\t\tif (dis[y] &gt; dis[x] + w) &#123;\t\t\t\tdis[y] = dis[x] + w;\t\t\t\tif (vis[y] == false) &#123;\t\t\t\t\tvis[y] = true;\t\t\t\t\tq.push(y);\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;&#125;//适用于有向图和无向图中，可以计算负权图，可以用来判断负环。时间复杂度为O(nm);\n\nFloyed123456void Floyed() &#123;    for (int k=1;k&lt;=n;++k)         for (int i=1;i&lt;=n;++i)             for (int j=1;j&lt;=n;++j)                 dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);&#125;void Floyed() &#123;    for (int k=1;k&lt;=n;++k)         for (int i=1;i&lt;=n;++i)             for (int j=1;j&lt;=n;++j)                 dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);&#125;//多源最短路，可以有负权边。适用于大部分的情况。但是时间复杂度高达O(n³)。\n\nKruskal123456789101112131415161718192021struct node &#123;\tll x, y, v;\tfriend bool operator &lt; (const node&amp;a, const node&amp;b) &#123;\t\treturn a.v &lt; b.v;\t&#125;&#125;e[maxm];void Kruskal() &#123;\tfor (int i=1;i&lt;=n;++i)\tf[i] = i;    int cnt = 0;    sort(e+1, e+1+m);    for (int i=1;i&lt;=m;++i) &#123;        int a = find(e[i].x), b = find(e[i].y);        if (a == b)\tcontinue;        else &#123;            ans += e[i].v;            f[b] = a;            ++cnt;        &#125;        if (cnt == n - 1)\tbreak;    &#125;&#125;struct node &#123;\tll x, y, v;\tfriend bool operator &lt; (const node&amp;a, const node&amp;b) &#123;\t\treturn a.v &lt; b.v;\t&#125;&#125;e[maxm];void Kruskal() &#123;\tfor (int i=1;i&lt;=n;++i)\tf[i] = i;    int cnt = 0;    sort(e+1, e+1+m);    for (int i=1;i&lt;=m;++i) &#123;        int a = find(e[i].x), b = find(e[i].y);        if (a == b)\tcontinue;        else &#123;            ans += e[i].v;            f[b] = a;            ++cnt;        &#125;        if (cnt == n - 1)\tbreak;    &#125;&#125;//这个是求出最小生成树的所有边的权值和， 其实可以可以在计算所有边的权值和的同时从新建一棵最小生成树\n\n并查集1234567891011void init() &#123;    for (int i=1;i&lt;=n;++i) f[i] = i;&#125;//使用并查集的初始化int find(int x) &#123;    return (f[x] == x) ? x : f[x] = find(f[x]);&#125;//进行路径压缩的并查集void un(int x, int y) &#123;    int a = getf(x), b = getf(y);    if (a == b) return;    void init() &#123;    for (int i=1;i&lt;=n;++i) f[i] = i;&#125;//使用并查集的初始化int find(int x) &#123;    return (f[x] == x) ? x : f[x] = find(f[x]);&#125;//进行路径压缩的并查集void un(int x, int y) &#123;    int a = getf(x), b = getf(y);    if (a == b) return;    else f[b] = a;&#125;\n\n拓扑排序12345678910111213141516171819void Topsort() &#123;    queue&lt;int&gt; q;    for (int i=1;i&lt;=n;++i) &#123;        if (du[i] == 0) &#123;            q.push(i);        &#125;    &#125;//找到入度为0的点， 入队    while(q.size()) &#123;        int x = q.front(); q.pop();        a[++tot] = x;        for (int i=head[x]; i; i=Next[i]) &#123;            if (--du[ver[i]] == 0) &#123;                a[++tot] = ver[i];                q.push(ver[i]);            &#125;        &#125;    &#125;&#125;//有向图中使用，记清楚！必须是有向图。显然的是，在进行完成拓扑排序之后，图中还留下来的东西就是一些环。即tot != n;void Topsort() &#123;    queue&lt;int&gt; q;    for (int i=1;i&lt;=n;++i) &#123;        if (du[i] == 0) &#123;            q.push(i);        &#125;    &#125;//找到入度为0的点， 入队    while(q.size()) &#123;        int x = q.front(); q.pop();        a[++tot] = x;        for (int i=head[x]; i; i=Next[i]) &#123;            if (--du[ver[i]] == 0) &#123;                a[++tot] = ver[i];                q.push(ver[i]);            &#125;        &#125;    &#125;&#125;//有向图中使用，记清楚！必须是有向图。显然的是，在进行完成拓扑排序之后，图中还留下来的东西就是一些环。即tot != n;//算法的应用：1.有向图找环（无向图是不能使用拓扑排序的）\n\n二分图最大匹配1234567891011121314151617181920bool find(int x) &#123;    for (int i=1;i&lt;=m;++i) &#123;          if (Link[x][i] &amp;&amp; !used[i]) &#123;            used[i] = true;            if (girl[i] == 0 || find(girl[i])) &#123;                girl[i] = x;             \treturn true;               &#125;        &#125;    &#125;    return false;&#125;//其实就是在寻找增广路的过程int Maxmatch() &#123;    int ans = 0;    for (int i=1;i&lt;=n;++i) &#123;        memset(used, 0, sizeof(used));        if (find(i)) ++ans;    &#125;    return ans;&#125;bool find(int x) &#123;    for (int i=1;i&lt;=m;++i) &#123;          if (Link[x][i] &amp;&amp; !used[i]) &#123;            used[i] = true;            if (girl[i] == 0 || find(girl[i])) &#123;                girl[i] = x;             \treturn true;               &#125;        &#125;    &#125;    return false;&#125;//其实就是在寻找增广路的过程int Maxmatch() &#123;    int ans = 0;    for (int i=1;i&lt;=n;++i) &#123;        memset(used, 0, sizeof(used));        if (find(i)) ++ans;    &#125;    return ans;&#125;//匈牙利算法如果使用邻接矩阵的话可以在O(n³)的时间内找到一个二分图的最大匹配数。空间复杂度是一个邻接矩阵(n²)。\n\nTarjan求强联通分量12345678910111213141516171819202122232425262728void Tarjan(int x) &#123;    dfn[x] = low[x] = ++tim;    Stack[++top] = x;    vis[x] = true;    for (int i=head[x]; i; i=Next[i]) &#123;        if (!dfn[ver[i]]) &#123;            Tarjan(ver[i]);            low[x] = min(low[x], low[ver[i]]);        &#125;else if (vis[ver[i]]) &#123;            low[x] = min(low[x], dfn[ver[i]]);        &#125;    &#125;    if (dfn[x] == low[x]) &#123;\t\tint temp = 0;\t\t++cnt;//一个新的强联通块\t\tdo&#123;\t\t\ttemp = Stack[--top];\t\t\tcolor[temp] = cnt;//color里存的是第i个点属于第几个联通块\t\t\tvis[temp] = false;\t\t&#125;while(x != temp);\t&#125;&#125;int main() &#123;    for (int i=1;i&lt;=n;++i) &#123;        if (!vis[i])            tarjan(i);void Tarjan(int x) &#123;    dfn[x] = low[x] = ++tim;    Stack[++top] = x;    vis[x] = true;    for (int i=head[x]; i; i=Next[i]) &#123;        if (!dfn[ver[i]]) &#123;            Tarjan(ver[i]);            low[x] = min(low[x], low[ver[i]]);        &#125;else if (vis[ver[i]]) &#123;            low[x] = min(low[x], dfn[ver[i]]);        &#125;    &#125;    if (dfn[x] == low[x]) &#123;\t\tint temp = 0;\t\t++cnt;//一个新的强联通块\t\tdo&#123;\t\t\ttemp = Stack[--top];\t\t\tcolor[temp] = cnt;//color里存的是第i个点属于第几个联通块\t\t\tvis[temp] = false;\t\t&#125;while(x != temp);\t&#125;&#125;int main() &#123;    for (int i=1;i&lt;=n;++i) &#123;        if (!vis[i])            tarjan(i);//因为这张图可能不连通    &#125;&#125;\n\n缩点1234567891011121314151617181920212223242526272829void Tarjan() &#123;    dfn[x] = low[x] = ++tim;    Stack[++top] = x;    vis[x] = true;    for (int i=head[x]; i; i=Next[i]) &#123;        if (!dfn[ver[i]]) &#123;            Tarjan(ver[i]);            low[x] = min(low[x], low[ver[i]]);        &#125;else if (vis[ver[i]]) &#123;            low[x] = min(low[x], dfn[ver[i]]);        &#125;    &#125;    if (low[x] == dfn[x]) &#123;        int temp;        ++cnt;        do &#123;            temp = Stack[top--];            color[temp] = cnt;            vis[y] = false;        &#125;while(x != temp)    &#125;&#125;/*现在说一说缩点，其实就是拿着邻接表，和强连通分量们来建一张新的图，在新的图中，点就是原来的强连通分量，边的具体操作有点复杂，现在具体说一说，大致意思就是：既然点都变成了强连通分量，那么边就应该在他们当中去连接不是吗?那什么和什么连？似乎可以看到，连接同一个强连通分量里的点是没有任何意义的，所以就好办了，跑一遍原邻接表，如果一条边（u，v,w）的u和v不在同一个强连通分量中，那么就在新图中连这条边，就这样点就缩好了。听起来也许有些玄幻，但是它就真真切切的完成了？！*/for (int i=1;i&lt;=m;++i) &#123;//一共m条边    if (color[a[i]] != color[b[i]]) &#123;//如果两条边的两个端点不在一个强连通分量里面， 那么我们在这两个点之间连一条边        adde(color[a[i]], color[b[i]], z[i]);    &#125;&#125;void Tarjan() &#123;    dfn[x] = low[x] = ++tim;    Stack[++top] = x;    vis[x] = true;    for (int i=head[x]; i; i=Next[i]) &#123;        if (!dfn[ver[i]]) &#123;            Tarjan(ver[i]);            low[x] = min(low[x], low[ver[i]]);        &#125;else if (vis[ver[i]]) &#123;            low[x] = min(low[x], dfn[ver[i]]);        &#125;    &#125;    if (low[x] == dfn[x]) &#123;        int temp;        ++cnt;        do &#123;            temp = Stack[top--];            color[temp] = cnt;            vis[y] = false;        &#125;while(x != temp)    &#125;&#125;/*现在说一说缩点，其实就是拿着邻接表，和强连通分量们来建一张新的图，在新的图中，点就是原来的强连通分量，边的具体操作有点复杂，现在具体说一说，大致意思就是：既然点都变成了强连通分量，那么边就应该在他们当中去连接不是吗?那什么和什么连？似乎可以看到，连接同一个强连通分量里的点是没有任何意义的，所以就好办了，跑一遍原邻接表，如果一条边（u，v,w）的u和v不在同一个强连通分量中，那么就在新图中连这条边，就这样点就缩好了。听起来也许有些玄幻，但是它就真真切切的完成了？！*/for (int i=1;i&lt;=m;++i) &#123;//一共m条边    if (color[a[i]] != color[b[i]]) &#123;//如果两条边的两个端点不在一个强连通分量里面， 那么我们在这两个点之间连一条边        adde(color[a[i]], color[b[i]], z[i]);    &#125;&#125;//等于用剩下的信息建了一张新图\n\n树LCA树上倍增123456789101112131415161718192021222324252627282930void bfs() &#123;    t = log(n)/log(2);    queue&lt;int&gt; q;    d[s] = 1;    q.push(s);    while(q.size()) &#123;        int x = q.front(); q.pop();        for (int i=head[x]; i; i=Next[i]) &#123;            int y = ver[i];            if (d[y]) continue;            d[y] = d[x]　＋ 1;            f[y][0] = x;            for (int j=1;j&lt;=t;++j) &#123;                f[y][j] = f[f[y][j-1]][j-1];            &#125;            q.push(y);        &#125;    &#125;&#125;int lca(int x, int y) &#123;    if (d[x] &gt; d[y]) swap(x, y);    for (int i=t;i&gt;=0;--i) &#123;        if (d[f[y][i]] &gt;= d[x])\ty = f[y][i];    &#125;    if (x == y) return x;    for (int i=t;i&gt;=0;--i) &#123;        if (f[y][i] != f[x][i]) x = f[x][i], y = f[y][i];    &#125;    return f[x][void bfs() &#123;    t = log(n)/log(2);    queue&lt;int&gt; q;    d[s] = 1;    q.push(s);    while(q.size()) &#123;        int x = q.front(); q.pop();        for (int i=head[x]; i; i=Next[i]) &#123;            int y = ver[i];            if (d[y]) continue;            d[y] = d[x]　＋ 1;            f[y][0] = x;            for (int j=1;j&lt;=t;++j) &#123;                f[y][j] = f[f[y][j-1]][j-1];            &#125;            q.push(y);        &#125;    &#125;&#125;int lca(int x, int y) &#123;    if (d[x] &gt; d[y]) swap(x, y);    for (int i=t;i&gt;=0;--i) &#123;        if (d[f[y][i]] &gt;= d[x])\ty = f[y][i];    &#125;    if (x == y) return x;    for (int i=t;i&gt;=0;--i) &#123;        if (f[y][i] != f[x][i]) x = f[x][i], y = f[y][i];    &#125;    return f[x][0];&#125;\n\nTarjan算法离线求LCA1234567891011121314151617181920212223242526void init() &#123;    int a, b;    for (int i=1;i&lt;n;++i) &#123;        a = Read(); b = Read();        adde(a, b);         adde(b, a);    &#125;//一棵树n-1条边    for (int i=1;i&lt;=k;++i) &#123;        a = Read(); b = Read();        qadde(a, b);        qadde(b, a);    &#125;//k个询问    for (int i=1;i&lt;=n;++i) f[i] = i;&#125;void Tarjan(int x) &#123;    vis[x] = true;    for (int i=head[x]; i; i=Next[i]) &#123;        if (vis[ver[i]])  continue;        tarjan(ver[i]);        f[ver[i]] = x;    &#125;    for (int i=qhead[x]; i; i=Next[i]) &#123;        if (vis[qver[i]])             ans[edge[i]] = void init() &#123;    int a, b;    for (int i=1;i&lt;n;++i) &#123;        a = Read(); b = Read();        adde(a, b);         adde(b, a);    &#125;//一棵树n-1条边    for (int i=1;i&lt;=k;++i) &#123;        a = Read(); b = Read();        qadde(a, b);        qadde(b, a);    &#125;//k个询问    for (int i=1;i&lt;=n;++i) f[i] = i;&#125;void Tarjan(int x) &#123;    vis[x] = true;    for (int i=head[x]; i; i=Next[i]) &#123;        if (vis[ver[i]])  continue;        tarjan(ver[i]);        f[ver[i]] = x;    &#125;    for (int i=qhead[x]; i; i=Next[i]) &#123;        if (vis[qver[i]])             ans[edge[i]] = getf(qver[i]);    &#125;&#125;\n\n树的直径123456789101112void dp(int x) &#123;    vis[x] = true;    for(int i=head[x]; i; i=Next[i]) &#123;        int y = ver[i];        if (vis[y]) continue;        dp(y);        ans = max(ans, d[x] + d[y] + edge[i]);        d[x] = max(d[x], d[y] + edge[i]);//d数组的含义是从x节点出发走向x的子树， 所能到达的最远距离。        //那么树上最长链的距离即为从x到x的子节点yi的距离加上x到x的子节点yj的距离加上d[yi]再加上d[yj]即可        void dp(int x) &#123;    vis[x] = true;    for(int i=head[x]; i; i=Next[i]) &#123;        int y = ver[i];        if (vis[y]) continue;        dp(y);        ans = max(ans, d[x] + d[y] + edge[i]);        d[x] = max(d[x], d[y] + edge[i]);//d数组的含义是从x节点出发走向x的子树， 所能到达的最远距离。        //那么树上最长链的距离即为从x到x的子节点yi的距离加上x到x的子节点yj的距离加上d[yi]再加上d[yj]即可        //d[x]中存的是从x走向他的前i个子节点最长的路径， 再加上当前的点到它子节点最长的路径即可得到x所在链的长度， 取一下max即为最长链的长度， 即为树的直径    &#125;&#125;\n\n树的重心123456789101112131415161718void dfs(int x) &#123;//树的重心的定义就是将该点删去之后所形成的最大的子树最小的那个点    vis[x] = true;    size[x] = 1;//子树x的大小    int max_part = 0;//删掉子树x后分成的最大子树的大小    for (int i=head[x]; i; i=Next[i]) &#123;        int y = ver[i];        if (vis[y])\tcontinue;        dfs(y);        size[x] += size[y];//从子节点向上更新        max_part = max(maxn_part, size[y]);//x的子节点中最大的那个节点的size    &#125;    \tmax_part = max(maxn_part, n - size[x]);//现在max_part中储存的是该节点删去之后形成的若干个子树最大的那个的大小     //n - max_part里存的是x向上连接他的父亲节点的那一棵子树的大小。    void dfs(int x) &#123;//树的重心的定义就是将该点删去之后所形成的最大的子树最小的那个点    vis[x] = true;    size[x] = 1;//子树x的大小    int max_part = 0;//删掉子树x后分成的最大子树的大小    for (int i=head[x]; i; i=Next[i]) &#123;        int y = ver[i];        if (vis[y])\tcontinue;        dfs(y);        size[x] += size[y];//从子节点向上更新        max_part = max(maxn_part, size[y]);//x的子节点中最大的那个节点的size    &#125;    \tmax_part = max(maxn_part, n - size[x]);//现在max_part中储存的是该节点删去之后形成的若干个子树最大的那个的大小     //n - max_part里存的是x向上连接他的父亲节点的那一棵子树的大小。    if (max_part < ans) &#123;        ans = max_part;        pos = x;    &#125;&#125;\n\n树的各点子树的大小12345678910void dfs(int x) &#123;    vis[x] = true;    size[x] = 1;    for (int i=head[x]; i; i=Next[i]) &#123;        int y = ver[i];        if (vis[y]) continue;        void dfs(int x) &#123;    vis[x] = true;    size[x] = 1;    for (int i=head[x]; i; i=Next[i]) &#123;        int y = ver[i];        if (vis[y]) continue;        dfs(y);        size[x] += size[y];    &#125;&#125;\n\n树的各点的深度1234567891011121314151617181920212223void dfs(int x) &#123;    vis[x] = true;    for (int i=head[x]; i; i=Next[i) &#123;        int y = ver[i];        if (vis[y])\tcontinue;        d[y] = d[x] + 1;        dfs(y);    &#125;&#125;void bfs(int x) &#123;    memset(d, 0, sizeof(d));\tqueue&lt;int&gt; q;    d[x] = 1; q.push(x);    while(q.size()) &#123;        int x = q.front(); q.pop();        for (int i=head[x];i;i=Next[i]) &#123;            int y = ver[i];            if (vis[y]) continue;            d[y] = d[x] + 1;            q.void dfs(int x) &#123;    vis[x] = true;    for (int i=head[x]; i; i=Next[i) &#123;        int y = ver[i];        if (vis[y])\tcontinue;        d[y] = d[x] + 1;        dfs(y);    &#125;&#125;void bfs(int x) &#123;    memset(d, 0, sizeof(d));\tqueue&lt;int&gt; q;    d[x] = 1; q.push(x);    while(q.size()) &#123;        int x = q.front(); q.pop();        for (int i=head[x];i;i=Next[i]) &#123;            int y = ver[i];            if (vis[y]) continue;            d[y] = d[x] + 1;            q.push(y);        &#125;    &#125;&#125;\n\n数论基础数论Gcd 和 Lcm123456int gcd(int a, int b) &#123;    return b? gcd(b, a%b) : a;&#125;int lcm(int a, int b) &#123;    return a / int gcd(int a, int b) &#123;    return b? gcd(b, a%b) : a;&#125;int lcm(int a, int b) &#123;    return a / gcd(a, b) * b;&#125;\n\n线性筛求素数1234567891011121314ll prime[maxn]， size = 0;bool vis[maxn]; inline void init() &#123;    memset(vis, true, sizeof(vis));    memset(prime, 0, sizeof(vis));    vis[1] = false;    for (int i=2;i&lt;=n;++i) &#123;        if (vis[i]) prime[++size] = i;        for (int j=1;j&lt;=size&amp;&amp;i*prime[j]&lt;=n;++j) &#123;            vis[i*prime[j]] = false;            if (i % prime[j] == 0)\tbreak;        &#125;    &#125;&#125;ll prime[maxn]， size = 0;bool vis[maxn]; inline void init() &#123;    memset(vis, true, sizeof(vis));    memset(prime, 0, sizeof(vis));    vis[1] = false;    for (int i=2;i&lt;=n;++i) &#123;        if (vis[i]) prime[++size] = i;        for (int j=1;j&lt;=size&amp;&amp;i*prime[j]&lt;=n;++j) &#123;            vis[i*prime[j]] = false;            if (i % prime[j] == 0)\tbreak;        &#125;    &#125;&#125;//时间复杂度O(n)\n\nEXGCD123456789101112void Exgcd(int a, int b, int&amp; d, int&amp; x, int&amp; y) &#123;    if (!b) &#123;        x = 1;        y = 0;        d = a;        return;    &#125;    int x1, y1;    void Exgcd(int a, int b, int&amp; d, int&amp; x, int&amp; y) &#123;    if (!b) &#123;        x = 1;        y = 0;        d = a;        return;    &#125;    int x1, y1;    Exgcd(b, a%b, d, x1, y1);    x = y1;    y = x1 - (a / b) * y1;  &#125;\n\n求逆元1234567891011121314151617//如果p是素数那么可以使用小费马定理int inv(int a, int p) &#123;\treturn = power(a, p - 2, p);    &#125;//如果p不是素数那么可以使用EXgcdint inv(int a, int p) &#123;\tint x, y, d;    exgcd(a, p, d, x, y);    return d == 1 ? (a + p)% p : -1;&#125;//如果返回-1则这个数没有逆元//如果要求出n以内所有在膜p情况下的的逆元,可以线性递推void inv(int n, int p) &#123;    inv[1] = 1;    for (int i=//如果p是素数那么可以使用小费马定理int inv(int a, int p) &#123;\treturn = power(a, p - 2, p);    &#125;//如果p不是素数那么可以使用EXgcdint inv(int a, int p) &#123;\tint x, y, d;    exgcd(a, p, d, x, y);    return d == 1 ? (a + p)% p : -1;&#125;//如果返回-1则这个数没有逆元//如果要求出n以内所有在膜p情况下的的逆元,可以线性递推void inv(int n, int p) &#123;    inv[1] = 1;    for (int i=2;i<=n;++i) &#123;        inv[i] = (p - p / i) * inv[p % i] % p;    &#125;&#125;\n\n快速幂12345678int power(int a, int b, int p) &#123;    int res = 1 % p;    for(; b; b &gt;&gt;= 1) &#123;        if (b &amp; 1) res = (long long)res * a % p;        a =(long long)a * a % p;    &#125;    int power(int a, int b, int p) &#123;    int res = 1 % p;    for(; b; b &gt;&gt;= 1) &#123;        if (b &amp; 1) res = (long long)res * a % p;        a =(long long)a * a % p;    &#125;    return res;&#125;\n\n龟速乘12345678ll Mul(ll a, ll b, ll p) &#123;    ll res = 0;    for(; b; b &gt;&gt;= 1) &#123;        if (b &amp; 1) res = (res % p + a % p) % p;        a = (a &lt;&lt; 1) % p;    &#125;    return res;&#125;ll Mul(ll a, ll b, ll p) &#123;    ll res = 0;    for(; b; b &gt;&gt;= 1) &#123;        if (b &amp; 1) res = (res % p + a % p) % p;        a = (a &lt;&lt; 1) % p;    &#125;    return res;&#125;//可以防止两数相乘过大炸掉long long\n\n组合数学12345678910void init() &#123;    memset(c, 0, sizeof(c));    c[1][0] = c[1][1] = 1;    for (int i=2;i&lt;=maxn;++i) &#123;        c[i][0] = c[i][i] = 1;        for (int j=1;j&lt;i;++j) &#123;            c[i][j] =(c[i-1][j] % mod + c[i-1][jvoid init() &#123;    memset(c, 0, sizeof(c));    c[1][0] = c[1][1] = 1;    for (int i=2;i&lt;=maxn;++i) &#123;        c[i][0] = c[i][i] = 1;        for (int j=1;j&lt;i;++j) &#123;            c[i][j] =(c[i-1][j] % mod + c[i-1][j-1] % mod)% mod;        &#125;    &#125;&#125;\n\n矩阵乘法12345678910111213141516171819202122struct Mat &#123;    a[maxn][maxn];&#125;A, e;Mat Mul(Mat x, Mat y) &#123;    Mat c;    for (int i=1;i&lt;=n;++i)    for (int j=1;j&lt;=n;++j)        c.a[i][j] = 0;   \tfor (int k=1;k&lt;=n;++k)\tfor (int i=1;i&lt;=n;++i)\t\tfor (int j=1;j&lt;=n;++j)        c.a[i][j] = c.a[i][j] % mod + (x.a[i][k] * y.a[k][j] % mod) % mod;    return c;&#125;Mat power(Mat x, int p) &#123;    Mat ans = e;    for (; b; b&gt;&gt;=1) &#123;        if (b &amp; 1) ans = Mul(ans, a);        a = Mul(a, a);    &#125;    struct Mat &#123;    a[maxn][maxn];&#125;A, e;Mat Mul(Mat x, Mat y) &#123;    Mat c;    for (int i=1;i&lt;=n;++i)    for (int j=1;j&lt;=n;++j)        c.a[i][j] = 0;   \tfor (int k=1;k&lt;=n;++k)\tfor (int i=1;i&lt;=n;++i)\t\tfor (int j=1;j&lt;=n;++j)        c.a[i][j] = c.a[i][j] % mod + (x.a[i][k] * y.a[k][j] % mod) % mod;    return c;&#125;Mat power(Mat x, int p) &#123;    Mat ans = e;    for (; b; b&gt;&gt;=1) &#123;        if (b &amp; 1) ans = Mul(ans, a);        a = Mul(a, a);    &#125;    return ans;&#125;\n\n数据结构基本数据结构链表12345678910111213141516171819202122232425262728293031323334inline void init() &#123;    a[1].pre = 0;    a[1].next = -1;    a[0].next = 1;    a[0].pre = -1;&#125;inline void insert(int x, int k, int p) &#123;    if (p == 1) &#123;        a[x].pre = k;        a[x].next = a[k].next;        a[a[k].next].pre = x;        a[k].pre = x;    &#125;else &#123;        k = a[k].pre;        a[x].pre = k;        a[x].next = a[k].next;        a[a[k].next].pre = x;        a[k].next = x;    &#125;    return;&#125;//在k的前或者后面插入一个值为x的点//p == 1 时表示在k的后面插入了x//p == 0 时表示在k的前面插入了xinline void del(int x) &#123;    if (a[x].pre != -1) &#123;        a[a[x].pre].next = a[x].next;        a[a[x].next].pre = a[x].pre;        a[x].pre = -1;    &#125;&#125;//一个数的pre为-1表示这个点已经被删除for (int i=a[0].next;i!=-1;i=a[i].next) &#123;    inline void init() &#123;    a[1].pre = 0;    a[1].next = -1;    a[0].next = 1;    a[0].pre = -1;&#125;inline void insert(int x, int k, int p) &#123;    if (p == 1) &#123;        a[x].pre = k;        a[x].next = a[k].next;        a[a[k].next].pre = x;        a[k].pre = x;    &#125;else &#123;        k = a[k].pre;        a[x].pre = k;        a[x].next = a[k].next;        a[a[k].next].pre = x;        a[k].next = x;    &#125;    return;&#125;//在k的前或者后面插入一个值为x的点//p == 1 时表示在k的后面插入了x//p == 0 时表示在k的前面插入了xinline void del(int x) &#123;    if (a[x].pre != -1) &#123;        a[a[x].pre].next = a[x].next;        a[a[x].next].pre = a[x].pre;        a[x].pre = -1;    &#125;&#125;//一个数的pre为-1表示这个点已经被删除for (int i=a[0].next;i!=-1;i=a[i].next) &#123;    //一个链表的遍历&#125;\n\n队列12345678910111213141516171819//STLqueue&lt;int&gt; q;q.push(x);q.pop();int x = q.front();int size = q.size();bool is_empty = q.empty();//手写一个队列inline void init()&#123;    head = 0; tail = 0;\tmemset(q, 0, sizeof(q));&#125;inline void push(int x) &#123;q[++tail] = x;&#125;inline void pop()\t\t&#123;head++;&#125;inline int  front()\t\t&#123;return q[tail];&#125;inline bool empty()\t\t&#123;return head &gt;= tail;&#125;inline int \tsize()\t\t&#123;//STLqueue&lt;int&gt; q;q.push(x);q.pop();int x = q.front();int size = q.size();bool is_empty = q.empty();//手写一个队列inline void init()&#123;    head = 0; tail = 0;\tmemset(q, 0, sizeof(q));&#125;inline void push(int x) &#123;q[++tail] = x;&#125;inline void pop()\t\t&#123;head++;&#125;inline int  front()\t\t&#123;return q[tail];&#125;inline bool empty()\t\t&#123;return head &gt;= tail;&#125;inline int \tsize()\t\t&#123;return tail - head;&#125;\n\n优先队列12345678910//STLpriority_queue&lt;int&gt; q;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;q.push(x);q.pop();int x = q.top();int size = q.size();bool is_empty = q.empty();//STLpriority_queue&lt;int&gt; q;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;q.push(x);q.pop();int x = q.top();int size = q.size();bool is_empty = q.empty();//不会手写\n\n栈12345stack&lt;int&gt; s;s.push(x);s.pop();int x = s.top();bool is_empty = s.stack&lt;int&gt; s;s.push(x);s.pop();int x = s.top();bool is_empty = s.empty();\n\n单调队列1\n\n单调栈1\n\nST表1\n\n树状数组1234567891011121314151617181920inline void add(int x, int v) &#123;    for (; x &lt;= n; x += x &amp; (-x))\tc[x] += v;&#125;inline int ask(int x) &#123;    int res = 0;    for (; x; x -= x &amp; (-x))\tres += c[x];    return x;&#125;inline void init() &#123;    for (int i=1;i&lt;=n;++i)\tadd(i, a[i]);&#125;inline int sum(int x, int y) &#123;    return ask(y) - ask(x - 1);&#125;add(x, v);//单点修改x加上vint sum = sum(a, b)//区间求和， 从a到b的区间//区间修改，区间求和inline void change(int l, inline void add(int x, int v) &#123;    for (; x &lt;= n; x += x &amp; (-x))\tc[x] += v;&#125;inline int ask(int x) &#123;    int res = 0;    for (; x; x -= x &amp; (-x))\tres += c[x];    return x;&#125;inline void init() &#123;    for (int i=1;i&lt;=n;++i)\tadd(i, a[i]);&#125;inline int sum(int x, int y) &#123;    return ask(y) - ask(x - 1);&#125;add(x, v);//单点修改x加上vint sum = sum(a, b)//区间求和， 从a到b的区间//区间修改，区间求和inline void change(int l, int r, ll d) &#123;\t    &#125;\n\n线段树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051struct Segment &#123;    int l, r;    ll dat, add;    #define l(x)\ttree[x].l    #define r(x)\ttree[x].r    #define dat(x)\ttree[x].dat    #define add(x)\ttree[x].add&#125;tree[maxn &lt;&lt; 2];int a[maxn];inline void update(int p) &#123;    dat(p) = dat(p&lt;&lt;1) + dat(p&lt;&lt;1|1);&#125;void build(int p, int l, int r) &#123;    l(p) = l; r(p) = r;    if (l == r) &#123;dat(p) = a[i];return;&#125;    int mid = (l + r) &gt;&gt; 1;    build(p&lt;&lt;1,\tl, mid);    build(p&lt;&lt;1|1,mid+1, r);    update(p);&#125;void spread(int p) &#123;    if (add(p)) &#123;        dat(p&lt;&lt;1) += add(p) * (r(p&lt;&lt;1) - l(p&lt;&lt;1) + 1);        dat(p&lt;&lt;1|1) += add(p) * (r(p&lt;&lt;1|1) - l(p&lt;&lt;1|1) + 1);        add(p&lt;&lt;1) += add(p);        add(p&lt;&lt;1|1) += add(p);        add(p) = 0;    &#125;&#125;void change(int p, int l, int r, int d) &#123;    if (l &lt;= l(p) &amp;&amp; r &gt;= r(p)) &#123;        dat(p) += (long long)d * (r(p) - l(p) + 1);        add(p) += d;        return;    &#125;    spread(p);    int mid = (l(p) + r(p)) &gt;&gt; 1;    if (l &lt;= mid)\tchange(p&lt;&lt;1, l, r, d);    if (r &gt; mid)\tchange(p&lt;&lt;1|1, l, r, d);    update(p);&#125;long long ask(int p, int l, int r) &#123;    if (l &lt;= l(p) &amp;&amp; r &gt;= r(p))\treturn dat(p);    spread(p);    int mid = (l(p) + r(p)) &gt;&gt; 1;    long long res = 0;    if (l &lt;= mid)\tres += ask(p&lt;&lt;1, l, r);    if (r &gt; mid)\tres += ask(p&lt;&lt;1|1, l, r);    struct Segment &#123;    int l, r;    ll dat, add;    #define l(x)\ttree[x].l    #define r(x)\ttree[x].r    #define dat(x)\ttree[x].dat    #define add(x)\ttree[x].add&#125;tree[maxn &lt;&lt; 2];int a[maxn];inline void update(int p) &#123;    dat(p) = dat(p&lt;&lt;1) + dat(p&lt;&lt;1|1);&#125;void build(int p, int l, int r) &#123;    l(p) = l; r(p) = r;    if (l == r) &#123;dat(p) = a[i];return;&#125;    int mid = (l + r) &gt;&gt; 1;    build(p&lt;&lt;1,\tl, mid);    build(p&lt;&lt;1|1,mid+1, r);    update(p);&#125;void spread(int p) &#123;    if (add(p)) &#123;        dat(p&lt;&lt;1) += add(p) * (r(p&lt;&lt;1) - l(p&lt;&lt;1) + 1);        dat(p&lt;&lt;1|1) += add(p) * (r(p&lt;&lt;1|1) - l(p&lt;&lt;1|1) + 1);        add(p&lt;&lt;1) += add(p);        add(p&lt;&lt;1|1) += add(p);        add(p) = 0;    &#125;&#125;void change(int p, int l, int r, int d) &#123;    if (l &lt;= l(p) &amp;&amp; r &gt;= r(p)) &#123;        dat(p) += (long long)d * (r(p) - l(p) + 1);        add(p) += d;        return;    &#125;    spread(p);    int mid = (l(p) + r(p)) &gt;&gt; 1;    if (l &lt;= mid)\tchange(p&lt;&lt;1, l, r, d);    if (r &gt; mid)\tchange(p&lt;&lt;1|1, l, r, d);    update(p);&#125;long long ask(int p, int l, int r) &#123;    if (l &lt;= l(p) &amp;&amp; r &gt;= r(p))\treturn dat(p);    spread(p);    int mid = (l(p) + r(p)) &gt;&gt; 1;    long long res = 0;    if (l &lt;= mid)\tres += ask(p&lt;&lt;1, l, r);    if (r &gt; mid)\tres += ask(p&lt;&lt;1|1, l, r);    return res;&#125;\n\n分块12345678910111213141516171819202122232425262728293031323334void build() &#123;    block = sqrt(n);    num = n / block;  if (n % block) num++;    for (int i=1;i&lt;=num;++i)        l[i] = (i - 1) * block + 1, r[i] = i * block;    r[num] = n;    for (int i=1;i&lt;=n;++i) &#123;        a[i] = Read();        belong[i] = (i - 1) / block + 1;        sum[belong[i]] += a[i];    &#125;&#125;void add(int x, int y, int d) &#123;    for (int i=x;i&lt;=min(x, r[belong[x]]);++i)         a[i] += d, sum[belong[i]] += d;    if (belong[x] != belong[y]) &#123;        for (int i=l[belong[y]];i&lt;=y;++i)            a[i] += d, sum[belong[i]] += d;    &#125;    for (int i=belong[x]+1;i&lt;=belong[y]-1;++i)        sum[i] += block * d, tag[i] +=d;&#125;int ask(int x, int y) &#123;    ll ans = 0;    for (int i=x;i&lt;=min(x, r[belong[x]]);++i)         ans += tag[belong[i]] + a[i];    if (belong[x] != belong[y]) &#123;        for (int i=l[belong[y]];i&lt;=y;++i)            ans += tag[belong[i]] + a[i];    &#125;    for (int i=belong[x]+1;i&lt;=belong[y]-1;++i)        ans += sum[i];    void build() &#123;    block = sqrt(n);    num = n / block;  if (n % block) num++;    for (int i=1;i&lt;=num;++i)        l[i] = (i - 1) * block + 1, r[i] = i * block;    r[num] = n;    for (int i=1;i&lt;=n;++i) &#123;        a[i] = Read();        belong[i] = (i - 1) / block + 1;        sum[belong[i]] += a[i];    &#125;&#125;void add(int x, int y, int d) &#123;    for (int i=x;i&lt;=min(x, r[belong[x]]);++i)         a[i] += d, sum[belong[i]] += d;    if (belong[x] != belong[y]) &#123;        for (int i=l[belong[y]];i&lt;=y;++i)            a[i] += d, sum[belong[i]] += d;    &#125;    for (int i=belong[x]+1;i&lt;=belong[y]-1;++i)        sum[i] += block * d, tag[i] +=d;&#125;int ask(int x, int y) &#123;    ll ans = 0;    for (int i=x;i&lt;=min(x, r[belong[x]]);++i)         ans += tag[belong[i]] + a[i];    if (belong[x] != belong[y]) &#123;        for (int i=l[belong[y]];i&lt;=y;++i)            ans += tag[belong[i]] + a[i];    &#125;    for (int i=belong[x]+1;i&lt;=belong[y]-1;++i)        ans += sum[i];    return ans;&#125;\n\n字符串基本字符串算法Hash表1234567unsigned long long h(char s[]) &#123;    int len = strlen(s);    unsigned long long ans = 0;    for (int i=0;i&lt;len;++i) \t\tans += ans * 131 + (unsigned long long)(s[i] - &#x27;a&#x27; + 1);\tunsigned long long h(char s[]) &#123;    int len = strlen(s);    unsigned long long ans = 0;    for (int i=0;i&lt;len;++i) \t\tans += ans * 131 + (unsigned long long)(s[i] - &#x27;a&#x27; + 1);\treturn ans;&#125;\n\nKMP123456789101112131415161718192021void prekmp() &#123;    m = strlen(b + 1);    Next[1] = 0;    for (int i=2,j=0;i&lt;=m;++i) &#123;        while(j &amp;&amp; b[i] != b[j + 1])j = Next[j];        if (b[i] == b[j + 1]) ++j;        Next[i] = j;    &#125;&#125;void kmp() &#123;    n = strlen(a + 1);    for (int i=1,j=0;i&lt;=n;++i) &#123;        while(j &amp;&amp; a[i] != b[j + 1])j = Next[j];        if (a[i] == b[j + 1]) ++j;        if (j == m) &#123;            ++ans;            printf(&quot;%d\\n&quot;, i - m + void prekmp() &#123;    m = strlen(b + 1);    Next[1] = 0;    for (int i=2,j=0;i&lt;=m;++i) &#123;        while(j &amp;&amp; b[i] != b[j + 1])j = Next[j];        if (b[i] == b[j + 1]) ++j;        Next[i] = j;    &#125;&#125;void kmp() &#123;    n = strlen(a + 1);    for (int i=1,j=0;i&lt;=n;++i) &#123;        while(j &amp;&amp; a[i] != b[j + 1])j = Next[j];        if (a[i] == b[j + 1]) ++j;        if (j == m) &#123;            ++ans;            printf(&quot;%d\\n&quot;, i - m + 1);            j = Next[j];        &#125;    &#125;&#125;\n\nManacher1234567891011121314151617181920void init() &#123;\tint len = strlen(str), j = 1;\ts[0] = &#x27;$&#x27;, s[1] = &#x27;#&#x27;;\trep(i, 0, len-1) &#123;\t\ts[++j] = str[i];\t\ts[++j] = &#x27;#&#x27;;\t&#125;\ts[++j] = &#x27;\\0&#x27;;&#125;int Manacher() &#123;\tint len = strlen(s);\tint mx = 0, id = 0, ans = -1;\trep(i, 0, len - 1) &#123;\t\tif (mx&gt;i) p[i]=min(mx-i, p[2*id-i]);else p[i] = 1;\t\twhile(i-p[i]&gt;=0&amp;&amp;s[i+p[i]]==s[i-p[i]])p[i]++;\t\tif(p[i]+i&gt;mx) mx = p[i]+i, id = i;\t\tans = max(ans, p[i] - 1);\t&#125;\tvoid init() &#123;\tint len = strlen(str), j = 1;\ts[0] = &#x27;$&#x27;, s[1] = &#x27;#&#x27;;\trep(i, 0, len-1) &#123;\t\ts[++j] = str[i];\t\ts[++j] = &#x27;#&#x27;;\t&#125;\ts[++j] = &#x27;\\0&#x27;;&#125;int Manacher() &#123;\tint len = strlen(s);\tint mx = 0, id = 0, ans = -1;\trep(i, 0, len - 1) &#123;\t\tif (mx&gt;i) p[i]=min(mx-i, p[2*id-i]);else p[i] = 1;\t\twhile(i-p[i]&gt;=0&amp;&amp;s[i+p[i]]==s[i-p[i]])p[i]++;\t\tif(p[i]+i&gt;mx) mx = p[i]+i, id = i;\t\tans = max(ans, p[i] - 1);\t&#125;\treturn ans;&#125;\n\n搜索基本搜索算法Dfs12345678void dfs(int x) &#123;    if (x &gt; n) &#123;        ...        return;    &#125;    ...\tdfs(x + void dfs(int x) &#123;    if (x &gt; n) &#123;        ...        return;    &#125;    ...\tdfs(x + 1);&#125;\n\nBfs123456789void bfs(int x) &#123;    queue&lt;int&gt; q;    q.push(x);    while(q.size()) &#123;        int x = q.front();        ...        q.void bfs(int x) &#123;    queue&lt;int&gt; q;    q.push(x);    while(q.size()) &#123;        int x = q.front();        ...        q.push(...);    &#125;&#125;\n\n迭代加深1\n\n其他常见思路二分123456789101112131415161718192021222324//求小于等于x最大的那一个inline bool check(int x) &#123;    if (...) return true;    else return false;&#125;int work() &#123;    int l = 0; r = max_n;    while(l &lt; r) &#123;        int mid = (l + r + 1) &gt;&gt; 1;        if (check(mid))\tl = mid;        else r = mid - 1;    &#125;    return l;&#125;//求大于等于x的最小的那一个int work() &#123;    int l = 0; r = max_n;    while(l &lt; r) &#123;        int mid = (l + r) &gt;&gt; 1;        if (check(mid)) r = mid;        else l = mid + 1;    &#125;    //求小于等于x最大的那一个inline bool check(int x) &#123;    if (...) return true;    else return false;&#125;int work() &#123;    int l = 0; r = max_n;    while(l &lt; r) &#123;        int mid = (l + r + 1) &gt;&gt; 1;        if (check(mid))\tl = mid;        else r = mid - 1;    &#125;    return l;&#125;//求大于等于x的最小的那一个int work() &#123;    int l = 0; r = max_n;    while(l &lt; r) &#123;        int mid = (l + r) &gt;&gt; 1;        if (check(mid)) r = mid;        else l = mid + 1;    &#125;    return l;&#125;\n\n代码模板开新题的程序头12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;#define IO ios::sync_with_stdio(false);cin.tie(0); cout.tie(0);#define rep(i, a, n) for (int i=a;i&lt;=n;++i)#define per(i, n, a) for (int i=n;i&gt;=a;--i)#define endl &#x27;\\n&#x27;using namespace std;typedef unsigned long long ull;typedef long long ll;const int maxn = const int maxm = const int inf = 0x3f3f3f3f;const int mod = 1e9 +7;inline int lowbit(int x) &#123;return -x&amp;x;&#125;inline int Read() &#123;\tint x=0,f=1;char ch=getchar();\twhile(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125;\twhile(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125;\treturn x*f;&#125;int main() &#123;\treturn #include&lt;bits/stdc++.h&gt;#define IO ios::sync_with_stdio(false);cin.tie(0); cout.tie(0);#define rep(i, a, n) for (int i=a;i&lt;=n;++i)#define per(i, n, a) for (int i=n;i&gt;=a;--i)#define endl &#x27;\\n&#x27;using namespace std;typedef unsigned long long ull;typedef long long ll;const int maxn = const int maxm = const int inf = 0x3f3f3f3f;const int mod = 1e9 +7;inline int lowbit(int x) &#123;return -x&amp;x;&#125;inline int Read() &#123;\tint x=0,f=1;char ch=getchar();\twhile(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125;\twhile(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125;\treturn x*f;&#125;int main() &#123;\treturn 0;&#125;\n\n1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;bitset&gt;#include &lt;stack&gt; #define IO ios::sync_with_stdio(false);cin.tie(0); cout.tie(0);#define rep(i, a, n) for (int i=a;i&lt;=n;++i)#define per(i, n, a) for (int i=n;i&gt;=a;--i)#define endl &#x27;\\n&#x27;using namespace std;typedef unsigned long long ull;typedef long long ll;const int maxn = const int maxm = const int inf = 0x3f3f3f3f;const int mod = 1e9 +7;inline int lowbit(int x) &#123;return -x&amp;x;&#125;inline int Read() &#123;\tint x=0,f=1;char ch=getchar();\twhile(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125;\twhile(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125;\treturn x*f;&#125;int main() &#123;\treturn #include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;bitset&gt;#include &lt;stack&gt; #define IO ios::sync_with_stdio(false);cin.tie(0); cout.tie(0);#define rep(i, a, n) for (int i=a;i&lt;=n;++i)#define per(i, n, a) for (int i=n;i&gt;=a;--i)#define endl &#x27;\\n&#x27;using namespace std;typedef unsigned long long ull;typedef long long ll;const int maxn = const int maxm = const int inf = 0x3f3f3f3f;const int mod = 1e9 +7;inline int lowbit(int x) &#123;return -x&amp;x;&#125;inline int Read() &#123;\tint x=0,f=1;char ch=getchar();\twhile(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125;\twhile(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125;\treturn x*f;&#125;int main() &#123;\treturn 0;&#125;\n\n","categories":[],"tags":[]},{"title":"河南大学暑假集训的日常（2）","url":"https://dicemy.github.io/8528.html","content":"DAY3（并查集）HDU - 1213 How Many Tables（并查集）\n\n简单题。\n代码：\n12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;const int maxn = 11000;int T, n, m, a, b;int f[maxn];int ans() &#123;\tint res = 0;\tfor (int i=1;i&lt;=n;++i) if (f[i] == i) res++;\treturn res;&#125;int find(int x) &#123;return (f[x] == x) ? x : f[x] = find(f[x]);&#125; int main() &#123;\tcin &gt;&gt; T;\tfor (int i=1;i&lt;=T;++i) &#123;\t\tcin &gt;&gt; n &gt;&gt; m;\t\tfor (int i=1;i&lt;=n;++i)\tf[i] = i;\t\tfor (int i=1;i&lt;=m;++i) &#123;\t\t\tcin &gt;&gt; a &gt;&gt; b;\t\t\tint x = find(a), y = find(b);\t\t\tf[y] = x;\t\t&#125;\t\tprintf(&quot;%d\\n&quot;, ans());\t&#125;\treturn #include&lt;iostream&gt;using namespace std;const int maxn = 11000;int T, n, m, a, b;int f[maxn];int ans() &#123;\tint res = 0;\tfor (int i=1;i&lt;=n;++i) if (f[i] == i) res++;\treturn res;&#125;int find(int x) &#123;return (f[x] == x) ? x : f[x] = find(f[x]);&#125; int main() &#123;\tcin &gt;&gt; T;\tfor (int i=1;i&lt;=T;++i) &#123;\t\tcin &gt;&gt; n &gt;&gt; m;\t\tfor (int i=1;i&lt;=n;++i)\tf[i] = i;\t\tfor (int i=1;i&lt;=m;++i) &#123;\t\t\tcin &gt;&gt; a &gt;&gt; b;\t\t\tint x = find(a), y = find(b);\t\t\tf[y] = x;\t\t&#125;\t\tprintf(&quot;%d\\n&quot;, ans());\t&#125;\treturn 0;&#125;\n\nHDU - 3038 How Many Answers Are Wrong（带边权并查集）\n\n该题是一道时带边权的并查集。\n对于每一个节点，不仅要维护它的祖先节点（若该节点上向右的区间有值的话右端点所对应的节点）的编号，还要维护该节点到它祖先节点的距离。\n距离可以为负数，在计算区间的时候减去距离就行了。在对一组区间的数据检测是否合法的时候，检测两个端点是否可以通过某一种方式通过某一种路径联通，即两节点的祖先节点是否为同一节点。如果联通，那么就可以通过这两个节点到其祖先节点的距离来计算出这两个节点之间的距离了。\n对于节点到其祖先节点的距离的维护，可以通过递归寻找祖先节点的过程中更新。在每一次寻找的过程中，如果该节点不是最终的祖先节点的话，那么将该节点到祖先节点的距离加上其父节点到祖先节点的距离。\n对于新插入的节点，需要维护两节点的根节点的距离关系，可以通过画出向量的方式较为清楚的表达出来：\n\n带边权并查集参考博客\n代码：\n123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int maxn = 200010;int f[maxn], d[maxn];int n, m;int find(int x) &#123;\tif (x != f[x]) &#123;\t\tint t = f[x];\t\tf[x] = find(f[x]);\t\td[x] += d[t];//这句话会在find函数进行递归的过程中进行更新路径上的距离值。\t&#125;\treturn f[x];&#125;int main() &#123;\twhile(cin &gt;&gt; n &gt;&gt; m) &#123;\t\tmemset(d, 0, sizeof(d));\t\tfor (int i=0;i&lt;=maxn-2;++i)\tf[i] = i; \t\tint l, r, v, ans = 0;\t\tfor (int i=1;i&lt;=m;++i) &#123;\t\t\tscanf(&quot;%d%d%d&quot;, &amp;l,&amp;r,&amp;v);\t\t\tl--;\t\t\tint fl = find(l);\t\t\tint fr = find(r);\t\t\tif (fl == fr)  &#123;\t\t\t\tif (d[r] - d[l] != v) ans++;\t\t\t&#125;//这个位置没有加大括号WA了好几发，但是我现在还是不知道这里为啥需要加大括号。。。            //这个括号到这我在HDU上WA了10+发\t\t\telse &#123;\t\t\t\tf[fr] = fl;\t\t\t\td[fr] = d[l] + v - d[r];\t\t\t&#125;\t\t&#125;\t\tprintf(&quot;%d\\n&quot;,ans);\t&#125;\treturn #include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int maxn = 200010;int f[maxn], d[maxn];int n, m;int find(int x) &#123;\tif (x != f[x]) &#123;\t\tint t = f[x];\t\tf[x] = find(f[x]);\t\td[x] += d[t];//这句话会在find函数进行递归的过程中进行更新路径上的距离值。\t&#125;\treturn f[x];&#125;int main() &#123;\twhile(cin &gt;&gt; n &gt;&gt; m) &#123;\t\tmemset(d, 0, sizeof(d));\t\tfor (int i=0;i&lt;=maxn-2;++i)\tf[i] = i; \t\tint l, r, v, ans = 0;\t\tfor (int i=1;i&lt;=m;++i) &#123;\t\t\tscanf(&quot;%d%d%d&quot;, &amp;l,&amp;r,&amp;v);\t\t\tl--;\t\t\tint fl = find(l);\t\t\tint fr = find(r);\t\t\tif (fl == fr)  &#123;\t\t\t\tif (d[r] - d[l] != v) ans++;\t\t\t&#125;//这个位置没有加大括号WA了好几发，但是我现在还是不知道这里为啥需要加大括号。。。            //这个括号到这我在HDU上WA了10+发\t\t\telse &#123;\t\t\t\tf[fr] = fl;\t\t\t\td[fr] = d[l] + v - d[r];\t\t\t&#125;\t\t&#125;\t\tprintf(&quot;%d\\n&quot;,ans);\t&#125;\treturn 0;&#125;\n\nPOJ - 2492A Bug’s Life（种类并查集/拓展域并查集）\n开两倍的f数组，x+n表示与x不相同的种类，（这种方法也叫作拆点）每一对虫子只需要保证性别不同即可，即x和y+n是联通的x+n和y也是联通的，但是x和y并不联通。如果在同一种类一侧出现了连接，即为产生了矛盾。\n代码：\n123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 2010;int T, n, m, x, y;bool flag = true;int f[maxn &lt;&lt; 1];int find(int x) &#123;return f[x] == x ? x : f[x] = find(f[x]);&#125;inline bool check(int x, int y) &#123;\tint px = find(x), py = find(y);\treturn px == py;&#125;inline void unino(int x, int y) &#123;\tint px = find(x), py = find(y);\tf[py] = px;&#125;int main() &#123;\tcin &gt;&gt; T;\tfor (int i=1;i&lt;=T;++i) &#123;\t\tscanf(&quot;%d%d&quot;, &amp;n,&amp;m);\t\tflag = true;\t\tfor (int i=1;i&lt;=n*2;++i)\tf[i] = i;\t\tfor (int i=1;i&lt;=m;++i) &#123;\t\t\tscanf(&quot;%d%d&quot;, &amp;x,&amp;y);\t\t\tif (!flag)\tcontinue;\t\t\tif (check(x, y) || check(x+n, y+n)) flag = false;\t\t\telse &#123;\t\t\t\tunino(x, y+n);\t\t\t\tunino(x+n, y);\t\t\t&#125;\t\t&#125;\t\tif (!flag) printf(&quot;Scenario #%d:\\nSuspicious bugs found!\\n\\n&quot;, i);\t\telse printf(&quot;Scenario #%d:\\nNo suspicious bugs found!\\n\\n&quot;, i);\t&#125;\treturn #include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 2010;int T, n, m, x, y;bool flag = true;int f[maxn &lt;&lt; 1];int find(int x) &#123;return f[x] == x ? x : f[x] = find(f[x]);&#125;inline bool check(int x, int y) &#123;\tint px = find(x), py = find(y);\treturn px == py;&#125;inline void unino(int x, int y) &#123;\tint px = find(x), py = find(y);\tf[py] = px;&#125;int main() &#123;\tcin &gt;&gt; T;\tfor (int i=1;i&lt;=T;++i) &#123;\t\tscanf(&quot;%d%d&quot;, &amp;n,&amp;m);\t\tflag = true;\t\tfor (int i=1;i&lt;=n*2;++i)\tf[i] = i;\t\tfor (int i=1;i&lt;=m;++i) &#123;\t\t\tscanf(&quot;%d%d&quot;, &amp;x,&amp;y);\t\t\tif (!flag)\tcontinue;\t\t\tif (check(x, y) || check(x+n, y+n)) flag = false;\t\t\telse &#123;\t\t\t\tunino(x, y+n);\t\t\t\tunino(x+n, y);\t\t\t&#125;\t\t&#125;\t\tif (!flag) printf(&quot;Scenario #%d:\\nSuspicious bugs found!\\n\\n&quot;, i);\t\telse printf(&quot;Scenario #%d:\\nNo suspicious bugs found!\\n\\n&quot;, i);\t&#125;\treturn 0;&#125;\n\nPOJ - 1988 Cube Stacking（带边权并查集）\n这道题同样也是带边权的并查集，有点像银河英雄传说这道题。每一个节点需要维护的值有到底部的距离和该栈的元素个数。核心部分还是在合并时权值的处理。\n代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int n = 50010;int m, x, y;int f[n], d[n], h[n];inline void init() &#123;\tcin &gt;&gt; m;\tfor (int i=1;i&lt;n;++i)\t&#123;\t\tf[i] = i;\t\th[i] = 1;\t\td[i] = 0;\t&#125;&#125;int find(int x) &#123;\tif (x != f[x]) &#123;\t\tint t = f[x];\t\tf[x] = find(f[x]);\t\td[x] += d[t];\t&#125;\treturn f[x];&#125;int main() &#123;\tinit();\tstring od;\tfor (int i=1;i&lt;=m;++i) &#123;\t\tcin &gt;&gt; od;\t\tif (od[0] == &#x27;C&#x27;) &#123;\t\t\tcin &gt;&gt; x;\t\t\tfind(x);\t\t\tprintf(&quot;%d\\n&quot;, d[x]);\t\t&#125;else &#123;\t\t\tcin &gt;&gt; x &gt;&gt; y;\t\t\tint px = find(x);\t\t\tint py = find(y);\t\t\tif (px != py) &#123;\t\t\t\tf[px] = py;\t\t\t\td[px] = h[py];\t\t\t\th[py] += h[px];\t\t\t&#125;\t\t&#125;\t&#125;\treturn #include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int n = 50010;int m, x, y;int f[n], d[n], h[n];inline void init() &#123;\tcin &gt;&gt; m;\tfor (int i=1;i&lt;n;++i)\t&#123;\t\tf[i] = i;\t\th[i] = 1;\t\td[i] = 0;\t&#125;&#125;int find(int x) &#123;\tif (x != f[x]) &#123;\t\tint t = f[x];\t\tf[x] = find(f[x]);\t\td[x] += d[t];\t&#125;\treturn f[x];&#125;int main() &#123;\tinit();\tstring od;\tfor (int i=1;i&lt;=m;++i) &#123;\t\tcin &gt;&gt; od;\t\tif (od[0] == &#x27;C&#x27;) &#123;\t\t\tcin &gt;&gt; x;\t\t\tfind(x);\t\t\tprintf(&quot;%d\\n&quot;, d[x]);\t\t&#125;else &#123;\t\t\tcin &gt;&gt; x &gt;&gt; y;\t\t\tint px = find(x);\t\t\tint py = find(y);\t\t\tif (px != py) &#123;\t\t\t\tf[px] = py;\t\t\t\td[px] = h[py];\t\t\t\th[py] += h[px];\t\t\t&#125;\t\t&#125;\t&#125;\treturn 0;&#125;\n\nPOJ - 1182食物链（拓展域并查集）\n经典的拓展域并查集。\n\n拓展域并查集：首先对与最简单的并查集来说，如果两个是同一类，那么就p[pa]=pb对吧，但是对于两个相互排斥类的怎么办呢，这就涉及到拓展与并查集了，首先想法就是建立两个并查集，但是怎么把两个并查集联系起来呢？拓展个体。\n这里的拓展个体是什么意思呢，一个个体我们要拆成多个，比方说两个集合存在队立关系，那么对于一个个体a，我们假设存在一个个体a+n ，a和a+n这两个是处于对立关系的，所以当我们说a和b对立的时候，意思就是在说，a+n和b在同一并查集，b+n和a在同一并查集，当我们说，a和b是同类的时候，那么也就是说a和b属于一个并查集，且a+n和b+n属于一个并查集。\n\n开三倍的数组，除了本身的域之外拓展的两个域表示域和本身的关系。分别表示天敌和捕食。\n代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#define rep(i, a, n) for (ll i=a;i&lt;=n;++i)#define per(i, n, a) for (ll i=n;i&gt;=a;--i)#define IOS std::ios::sync_with_stdio(false)#define enter putchar(&#x27;\\n&#x27;)typedef long long ll;using namespace std;const int maxn = 50010;int n, k, f[maxn * 3];int d, x, y, ans;int getfa(int x) &#123;return (f[x] == x) ? x : f[x] = getfa(f[x]);&#125;inline void un(int x, int y) &#123;\tint a = getfa(x);\tint b = getfa(y);\tif (a != b) f[b] = a;&#125;void work(int d, int x, int y) &#123;\tif (x &gt; n || y &gt; n) &#123;ans++;return;&#125;\tif (d == 1) &#123;\t\tif (getfa(x + n) == getfa(y) || getfa(x + 2 * n) == getfa(y)) &#123;ans++;return;&#125;\t\tun(x, y);\t\tun(x + n, y + n);\t\tun(x + 2 * n, y + 2 * n);\t&#125;\tif (d == 2) &#123;\t\tif (getfa(x) == getfa(y) || getfa(x + 2 * n) == getfa(y)) &#123;ans++;return;&#125;\t\tun(x + n, y);\t\tun(y + 2 * n, x);\t\tun(y + n, x + 2 * n);\t&#125;&#125;int main() &#123;\tscanf(&quot;%d%d&quot;, &amp;n, &amp;k);\trep(i, 1, n*3) f[i] = i;\trep(i, 1, k) &#123;\t\tscanf(&quot;%d%d%d&quot;, &amp;d, &amp;x, &amp;y);\t\twork(d, x, y);\t&#125;\tprintf(&quot;%d\\n&quot;, ans);\treturn #include&lt;iostream&gt;#define rep(i, a, n) for (ll i=a;i&lt;=n;++i)#define per(i, n, a) for (ll i=n;i&gt;=a;--i)#define IOS std::ios::sync_with_stdio(false)#define enter putchar(&#x27;\\n&#x27;)typedef long long ll;using namespace std;const int maxn = 50010;int n, k, f[maxn * 3];int d, x, y, ans;int getfa(int x) &#123;return (f[x] == x) ? x : f[x] = getfa(f[x]);&#125;inline void un(int x, int y) &#123;\tint a = getfa(x);\tint b = getfa(y);\tif (a != b) f[b] = a;&#125;void work(int d, int x, int y) &#123;\tif (x &gt; n || y &gt; n) &#123;ans++;return;&#125;\tif (d == 1) &#123;\t\tif (getfa(x + n) == getfa(y) || getfa(x + 2 * n) == getfa(y)) &#123;ans++;return;&#125;\t\tun(x, y);\t\tun(x + n, y + n);\t\tun(x + 2 * n, y + 2 * n);\t&#125;\tif (d == 2) &#123;\t\tif (getfa(x) == getfa(y) || getfa(x + 2 * n) == getfa(y)) &#123;ans++;return;&#125;\t\tun(x + n, y);\t\tun(y + 2 * n, x);\t\tun(y + n, x + 2 * n);\t&#125;&#125;int main() &#123;\tscanf(&quot;%d%d&quot;, &amp;n, &amp;k);\trep(i, 1, n*3) f[i] = i;\trep(i, 1, k) &#123;\t\tscanf(&quot;%d%d%d&quot;, &amp;d, &amp;x, &amp;y);\t\twork(d, x, y);\t&#125;\tprintf(&quot;%d\\n&quot;, ans);\treturn 0;&#125; \n\nDAY4（树状数组）POJ - 3468A Simple Problem with Integers（线段树/树状数组）\n一个简单的区间修改和区间求和的板子题。\n代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;typedef long long ll;const int maxn = 1e5 + 7;struct SegmentTree &#123;\tll l, r;\tll dat, add;\t#define l(x) tree[x].l\t#define r(x) tree[x].r\t#define dat(x) tree[x].dat\t#define add(x) tree[x].add&#125;tree[maxn &lt;&lt; 2];ll a[maxn &lt;&lt; 1];ll n, m;inline ll Read() &#123;\tll x=0,f=1;char ch=getchar();\twhile(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125;\twhile(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125;\treturn x*f;&#125;inline void update(ll p) &#123;dat(p) = dat(p&lt;&lt;1) + dat(p&lt;&lt;1|1);&#125;void build(ll p, ll l, ll r) &#123;\tl(p) = l; r(p) = r;\tif (l == r) &#123;dat(p) = a[l]; return;&#125;\tll mid = (l + r) &gt;&gt; 1;\tbuild(p&lt;&lt;1, l, mid);\tbuild(p&lt;&lt;1|1, mid+1, r);\tupdate(p);&#125;void spread(ll p) &#123;\tif (add(p)) &#123;\t\tadd(p&lt;&lt;1) += add(p);\t\tadd(p&lt;&lt;1|1) += add(p);\t\tdat(p&lt;&lt;1) += add(p) * (r(p&lt;&lt;1) - l(p&lt;&lt;1) + 1);\t\tdat(p&lt;&lt;1|1) += add(p) * (r(p&lt;&lt;1|1) - l(p&lt;&lt;1|1) + 1);\t\tadd(p) = 0;\t&#125;&#125;void change(ll p, ll l, ll r, ll d) &#123;\tif (l &lt;= l(p) &amp;&amp; r &gt;= r(p)) &#123;\t\tdat(p) += d * (r(p) - l(p) + 1);\t\tadd(p) += d;\t\treturn;\t&#125;\tspread(p);\tll mid = (l(p) + r(p)) &gt;&gt; 1;\tif (l &lt;= mid) change(p&lt;&lt;1, l, r, d);\tif (r &gt; mid) change(p&lt;&lt;1|1, l, r, d);\tupdate(p);&#125;ll  ask(int p, int l, int r) &#123;\tif (l &lt;= l(p) &amp;&amp; r &gt;= r(p))\treturn dat(p);\tspread(p);\tll mid = (l(p) + r(p)) &gt;&gt; 1;\tll res = 0;\tif (l &lt;= mid) res += ask(p&lt;&lt;1, l, r);\tif (r &gt; mid) res += ask(p&lt;&lt;1|1, l, r);\treturn res;&#125;inline void init() &#123;\tn = Read(); m = Read();\tfor (register int i=1;i&lt;=n;++i)\ta[i] = Read();\tbuild(1, 1, n);&#125;inline void work() &#123;\tll l, r, d;\tchar op; \twhile(m--)  &#123;\t\tcin &gt;&gt; op;\t\tif (op == &#x27;C&#x27;) &#123;\t\t\tl = Read(); r = Read(); d = Read();\t\t\tchange(1, l, r, d);\t\t&#125;\t\tif (op == &#x27;Q&#x27;) &#123;\t\t\tl = Read(); r = Read();\t\t\tprintf(&quot;%lld\\n&quot;, ask(1, l, r));\t\t&#125;\t&#125;&#125;int main() &#123;\tinit();\twork();\treturn #include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;typedef long long ll;const int maxn = 1e5 + 7;struct SegmentTree &#123;\tll l, r;\tll dat, add;\t#define l(x) tree[x].l\t#define r(x) tree[x].r\t#define dat(x) tree[x].dat\t#define add(x) tree[x].add&#125;tree[maxn &lt;&lt; 2];ll a[maxn &lt;&lt; 1];ll n, m;inline ll Read() &#123;\tll x=0,f=1;char ch=getchar();\twhile(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125;\twhile(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125;\treturn x*f;&#125;inline void update(ll p) &#123;dat(p) = dat(p&lt;&lt;1) + dat(p&lt;&lt;1|1);&#125;void build(ll p, ll l, ll r) &#123;\tl(p) = l; r(p) = r;\tif (l == r) &#123;dat(p) = a[l]; return;&#125;\tll mid = (l + r) &gt;&gt; 1;\tbuild(p&lt;&lt;1, l, mid);\tbuild(p&lt;&lt;1|1, mid+1, r);\tupdate(p);&#125;void spread(ll p) &#123;\tif (add(p)) &#123;\t\tadd(p&lt;&lt;1) += add(p);\t\tadd(p&lt;&lt;1|1) += add(p);\t\tdat(p&lt;&lt;1) += add(p) * (r(p&lt;&lt;1) - l(p&lt;&lt;1) + 1);\t\tdat(p&lt;&lt;1|1) += add(p) * (r(p&lt;&lt;1|1) - l(p&lt;&lt;1|1) + 1);\t\tadd(p) = 0;\t&#125;&#125;void change(ll p, ll l, ll r, ll d) &#123;\tif (l &lt;= l(p) &amp;&amp; r &gt;= r(p)) &#123;\t\tdat(p) += d * (r(p) - l(p) + 1);\t\tadd(p) += d;\t\treturn;\t&#125;\tspread(p);\tll mid = (l(p) + r(p)) &gt;&gt; 1;\tif (l &lt;= mid) change(p&lt;&lt;1, l, r, d);\tif (r &gt; mid) change(p&lt;&lt;1|1, l, r, d);\tupdate(p);&#125;ll  ask(int p, int l, int r) &#123;\tif (l &lt;= l(p) &amp;&amp; r &gt;= r(p))\treturn dat(p);\tspread(p);\tll mid = (l(p) + r(p)) &gt;&gt; 1;\tll res = 0;\tif (l &lt;= mid) res += ask(p&lt;&lt;1, l, r);\tif (r &gt; mid) res += ask(p&lt;&lt;1|1, l, r);\treturn res;&#125;inline void init() &#123;\tn = Read(); m = Read();\tfor (register int i=1;i&lt;=n;++i)\ta[i] = Read();\tbuild(1, 1, n);&#125;inline void work() &#123;\tll l, r, d;\tchar op; \twhile(m--)  &#123;\t\tcin &gt;&gt; op;\t\tif (op == &#x27;C&#x27;) &#123;\t\t\tl = Read(); r = Read(); d = Read();\t\t\tchange(1, l, r, d);\t\t&#125;\t\tif (op == &#x27;Q&#x27;) &#123;\t\t\tl = Read(); r = Read();\t\t\tprintf(&quot;%lld\\n&quot;, ask(1, l, r));\t\t&#125;\t&#125;&#125;int main() &#123;\tinit();\twork();\treturn 0;&#125;\n\nHDU - 1166敌兵布阵（树状数组）\n单点修改区间求和的树状数组板子题。\n代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;typedef long long ll;using namespace std;const int maxn = 50010;int T, n, l, r;int a[maxn], c[maxn];string od;inline int Read() &#123;\tint x=0,f=1;char ch=getchar();\twhile(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125;\twhile(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125;\treturn x*f;&#125;inline int ask(int x, int res = 0) &#123;for (; x&gt;=1; x-=(x&amp;-x))\tres += c[x];return res;&#125;inline void update(int x, int v) &#123;for (; x&lt;=n; x+=(x&amp;-x)) c[x] += v;&#125;inline int query(int l, int r) &#123;return ask(r) - ask(l - 1);&#125;inline void init() &#123;\tn = Read();\tmemset(c, 0, sizeof(c));\tmemset(a, 0, sizeof(a));\tfor (int i=1;i&lt;=n;++i) &#123;\t\ta[i] = Read();\t\t\tupdate(i, a[i]);\t&#125;&#125;int main() &#123;\tT = Read();\tfor (int i=1;i&lt;=T;++i) &#123;\t\tinit();\t\tprintf(&quot;Case %d:\\n&quot;, i);\t\twhile(cin &gt;&gt; od &amp;&amp; od != &quot;End&quot;) &#123;\t\t\tl = Read(); r = Read();\t\t\tif (od == &quot;Add&quot;) update(l, r);\t\t\tif (od == &quot;Sub&quot;) update(l, -r);\t\t\tif (od == &quot;Query&quot;) printf(&quot;%d\\n&quot;, query(l, r));\t\t&#125;\t&#125;\treturn #include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;typedef long long ll;using namespace std;const int maxn = 50010;int T, n, l, r;int a[maxn], c[maxn];string od;inline int Read() &#123;\tint x=0,f=1;char ch=getchar();\twhile(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125;\twhile(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125;\treturn x*f;&#125;inline int ask(int x, int res = 0) &#123;for (; x&gt;=1; x-=(x&amp;-x))\tres += c[x];return res;&#125;inline void update(int x, int v) &#123;for (; x&lt;=n; x+=(x&amp;-x)) c[x] += v;&#125;inline int query(int l, int r) &#123;return ask(r) - ask(l - 1);&#125;inline void init() &#123;\tn = Read();\tmemset(c, 0, sizeof(c));\tmemset(a, 0, sizeof(a));\tfor (int i=1;i&lt;=n;++i) &#123;\t\ta[i] = Read();\t\t\tupdate(i, a[i]);\t&#125;&#125;int main() &#123;\tT = Read();\tfor (int i=1;i&lt;=T;++i) &#123;\t\tinit();\t\tprintf(&quot;Case %d:\\n&quot;, i);\t\twhile(cin &gt;&gt; od &amp;&amp; od != &quot;End&quot;) &#123;\t\t\tl = Read(); r = Read();\t\t\tif (od == &quot;Add&quot;) update(l, r);\t\t\tif (od == &quot;Sub&quot;) update(l, -r);\t\t\tif (od == &quot;Query&quot;) printf(&quot;%d\\n&quot;, query(l, r));\t\t&#125;\t&#125;\treturn 0;&#125; \n\nHDU - 1394Minimum Inversion Number（逆序对/树状数组）\n树状数组求逆序对数的改进版，需要在题中所给的序列生成的一系列序列中找到逆序对数最小的那一组。\n关于求一个数列的逆序对数，可以用树状数组来维护一个数字前面比自己大的数的个数。树状数组可以方便的在线求前缀和，所以说可以用树状数组来完成这道题。\n树状数组求逆序对参考博客\n代码：\n1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#define int llusing namespace std;typedef long long ll;const int maxn = 5010;int n, a[maxn &lt;&lt; 2], f[maxn &lt;&lt; 2];int tmp, ans;inline int lowbit(int x) &#123;return -x&amp;x;&#125;void update(int x, int v) &#123;for (; x&lt;=n; x+=lowbit(x))f[x] += v;&#125;int ask(int x, int res = 0) &#123;for (; x&gt;=1;x-=lowbit(x)) res += f[x];return res;&#125;signed main() &#123;\twhile(scanf(&quot;%d&quot;, &amp;n) != EOF) &#123;\t\tmemset(a, 0, sizeof(a));\t\tmemset(f, 0, sizeof(f));\t\ttmp = ans = 0;\t\tfor (int i=1;i&lt;=n;++i) &#123;\t\t\tscanf(&quot;%d&quot;, &amp;a[i]);\t\t\ta[i]++; \t\t\tupdate(a[i], 1);\t\t\ttmp += (i - ask(a[i]));\t\t&#125;//该过程是求一个序列的逆序对的方法\t\tans = tmp;\t\tfor (int i=1;i&lt;n;++i) &#123;\t\t\ttmp += (n - 2 * a[i] + 1);\t\t\tans = min(ans, tmp);\t\t&#125;//这一段是解决如何求出每一个元素后移之后的序列逆序对数\t\tprintf(&quot;%d\\n&quot;, ans);\t&#125;\treturn #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#define int llusing namespace std;typedef long long ll;const int maxn = 5010;int n, a[maxn &lt;&lt; 2], f[maxn &lt;&lt; 2];int tmp, ans;inline int lowbit(int x) &#123;return -x&amp;x;&#125;void update(int x, int v) &#123;for (; x&lt;=n; x+=lowbit(x))f[x] += v;&#125;int ask(int x, int res = 0) &#123;for (; x&gt;=1;x-=lowbit(x)) res += f[x];return res;&#125;signed main() &#123;\twhile(scanf(&quot;%d&quot;, &amp;n) != EOF) &#123;\t\tmemset(a, 0, sizeof(a));\t\tmemset(f, 0, sizeof(f));\t\ttmp = ans = 0;\t\tfor (int i=1;i&lt;=n;++i) &#123;\t\t\tscanf(&quot;%d&quot;, &amp;a[i]);\t\t\ta[i]++; \t\t\tupdate(a[i], 1);\t\t\ttmp += (i - ask(a[i]));\t\t&#125;//该过程是求一个序列的逆序对的方法\t\tans = tmp;\t\tfor (int i=1;i&lt;n;++i) &#123;\t\t\ttmp += (n - 2 * a[i] + 1);\t\t\tans = min(ans, tmp);\t\t&#125;//这一段是解决如何求出每一个元素后移之后的序列逆序对数\t\tprintf(&quot;%d\\n&quot;, ans);\t&#125;\treturn 0;&#125;\n\nHDU - 2795Billboard（线段树）\n这道题的实现其实不太难，难点是如何建树。\n由题可知，我们可以在广告牌的高度上建树，然后对于每一个新的广告，查找最靠下的可以满足当前广告牌的位置插入，实际上就是维护了一个区间的最大值，来进行判断当前广告是否可以放到该区间中。\n代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;typedef long long ll;const ll maxn = 500010;ll n, h, w;ll a[maxn * 4];inline void update(ll p) &#123;a[p] = max(a[p &lt;&lt; 1], a[p &lt;&lt; 1 | 1]);&#125;void build(ll p, ll l, ll r) &#123;\tif (l == r)\t&#123;\t\ta[p] = w;\t\treturn;\t&#125;\tll mid = (l + r) &gt;&gt; 1;\tbuild(p &lt;&lt; 1, l, mid);\tbuild(p &lt;&lt; 1 | 1, mid + 1, r);\tupdate(p);&#125;ll ask(ll x, ll l, ll r, ll p) &#123;\tif (l == r) &#123;\t\ta[p] -= x;\t\treturn l;\t&#125;\tll mid = (l + r) &gt;&gt; 1;\tll res = 0;\tif (a[p&lt;&lt;1] &gt;= x)\tres = ask(x, l, mid, p&lt;&lt;1);\telse \tres = ask(x, mid + 1, r, p&lt;&lt;1|1);\tupdate(p);\treturn res;&#125;int main() &#123;\twhile(scanf(&quot;%d%d%d&quot;, &amp;h, &amp;w, &amp;n) != EOF) &#123;\t\tmemset(a, 0, sizeof(a));\t\th = min(h,n);\t\tbuild(1,1,h);\t\tll x = 0;\t\tfor (int i=1;i&lt;=n;++i) &#123;\t\t\tscanf(&quot;%d&quot;, &amp;x);\t\t\tif (a[1] &lt; x)\tprintf(&quot;-1\\n&quot;);\t\t\telse\tprintf(&quot;%d\\n&quot;, ask(x, 1, h, 1));\t\t&#125;\t&#125;\treturn #include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;typedef long long ll;const ll maxn = 500010;ll n, h, w;ll a[maxn * 4];inline void update(ll p) &#123;a[p] = max(a[p &lt;&lt; 1], a[p &lt;&lt; 1 | 1]);&#125;void build(ll p, ll l, ll r) &#123;\tif (l == r)\t&#123;\t\ta[p] = w;\t\treturn;\t&#125;\tll mid = (l + r) &gt;&gt; 1;\tbuild(p &lt;&lt; 1, l, mid);\tbuild(p &lt;&lt; 1 | 1, mid + 1, r);\tupdate(p);&#125;ll ask(ll x, ll l, ll r, ll p) &#123;\tif (l == r) &#123;\t\ta[p] -= x;\t\treturn l;\t&#125;\tll mid = (l + r) &gt;&gt; 1;\tll res = 0;\tif (a[p&lt;&lt;1] &gt;= x)\tres = ask(x, l, mid, p&lt;&lt;1);\telse \tres = ask(x, mid + 1, r, p&lt;&lt;1|1);\tupdate(p);\treturn res;&#125;int main() &#123;\twhile(scanf(&quot;%d%d%d&quot;, &amp;h, &amp;w, &amp;n) != EOF) &#123;\t\tmemset(a, 0, sizeof(a));\t\th = min(h,n);\t\tbuild(1,1,h);\t\tll x = 0;\t\tfor (int i=1;i&lt;=n;++i) &#123;\t\t\tscanf(&quot;%d&quot;, &amp;x);\t\t\tif (a[1] &lt; x)\tprintf(&quot;-1\\n&quot;);\t\t\telse\tprintf(&quot;%d\\n&quot;, ask(x, 1, h, 1));\t\t&#125;\t&#125;\treturn 0;&#125;\n\nPOJ - 2777Count Color（线段树+状态压缩）\n用位运算来保存颜色的状态，加上懒惰标记，然后update维护父子节点的信息会不太一样。\n代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#define int llusing namespace std;typedef long long ll;const int maxn = 500010;int n, t, m, l, r, c;int a[maxn &lt;&lt; 2], f[maxn &lt;&lt; 2];char od[5];void update(int p) &#123;a[p] = a[p*2] | a[p*2+1];&#125;void spread(int p) &#123;a[p*2+1] = a[p*2] = f[p*2+1] = f[p*2] = f[p];f[p] = 0;&#125; void change(int p, int l, int r, int x, int y, int c) &#123;\tif (x &lt;= l &amp;&amp; r &lt;= y) &#123;\t\tf[p] = a[p] = 1 &lt;&lt; c;\t\treturn;\t&#125;\tint mid = (l + r) &gt;&gt; 1;\tif (f[p])\tspread(p);\tif (x &lt;= mid) change(p*2, l, mid, x, y, c);\tif (y &gt; mid) change(p*2+1, mid + 1, r, x, y, c);\tupdate(p);\t&#125;int ask(int p, int l, int r, int x, int y) &#123;\tif (x &lt;= l &amp;&amp; r &lt;= y)\treturn a[p];\tll mid = (l + r) &gt;&gt; 1;\tif (f[p])\tspread(p);\tll res = 0;\tif (x &lt;= mid) res |= ask(p&lt;&lt;1, l, mid, x, y);\tif (y &gt; mid) res |= ask(p&lt;&lt;1|1, mid + 1, r, x, y);\treturn res;&#125;int cnt(int x) &#123;\tint ans = 0;\twhile(x) ans++, x -= -x&amp;x;\treturn ans;&#125;signed main() &#123;\tscanf(&quot;%lld%lld%lld&quot;, &amp;n,&amp;t,&amp;m);\tchange(1, 1, n, 1, n, 1);\tfor (int i=1;i&lt;=m;++i) &#123;\t\tscanf(&quot;%s%lld%lld&quot;, od, &amp;l, &amp;r);\t\tif (l &gt; r)\tl ^= r ^= l ^= l;\t\tif (od[0] == &#x27;C&#x27;) &#123;\t\t\tscanf(&quot;%lld&quot;, &amp;c);\t\t\tchange(1, 1, n, l, r, c);\t\t&#125;else printf(&quot;%lld\\n&quot;, cnt(ask(1, 1, n, l, r)));\t&#125;\treturn #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#define int llusing namespace std;typedef long long ll;const int maxn = 500010;int n, t, m, l, r, c;int a[maxn &lt;&lt; 2], f[maxn &lt;&lt; 2];char od[5];void update(int p) &#123;a[p] = a[p*2] | a[p*2+1];&#125;void spread(int p) &#123;a[p*2+1] = a[p*2] = f[p*2+1] = f[p*2] = f[p];f[p] = 0;&#125; void change(int p, int l, int r, int x, int y, int c) &#123;\tif (x &lt;= l &amp;&amp; r &lt;= y) &#123;\t\tf[p] = a[p] = 1 &lt;&lt; c;\t\treturn;\t&#125;\tint mid = (l + r) &gt;&gt; 1;\tif (f[p])\tspread(p);\tif (x &lt;= mid) change(p*2, l, mid, x, y, c);\tif (y &gt; mid) change(p*2+1, mid + 1, r, x, y, c);\tupdate(p);\t&#125;int ask(int p, int l, int r, int x, int y) &#123;\tif (x &lt;= l &amp;&amp; r &lt;= y)\treturn a[p];\tll mid = (l + r) &gt;&gt; 1;\tif (f[p])\tspread(p);\tll res = 0;\tif (x &lt;= mid) res |= ask(p&lt;&lt;1, l, mid, x, y);\tif (y &gt; mid) res |= ask(p&lt;&lt;1|1, mid + 1, r, x, y);\treturn res;&#125;int cnt(int x) &#123;\tint ans = 0;\twhile(x) ans++, x -= -x&amp;x;\treturn ans;&#125;signed main() &#123;\tscanf(&quot;%lld%lld%lld&quot;, &amp;n,&amp;t,&amp;m);\tchange(1, 1, n, 1, n, 1);\tfor (int i=1;i&lt;=m;++i) &#123;\t\tscanf(&quot;%s%lld%lld&quot;, od, &amp;l, &amp;r);\t\tif (l &gt; r)\tl ^= r ^= l ^= l;\t\tif (od[0] == &#x27;C&#x27;) &#123;\t\t\tscanf(&quot;%lld&quot;, &amp;c);\t\t\tchange(1, 1, n, l, r, c);\t\t&#125;else printf(&quot;%lld\\n&quot;, cnt(ask(1, 1, n, l, r)));\t&#125;\treturn 0;&#125;\n\n","categories":[],"tags":[]},{"title":"河南大学暑假集训的日常（1）","url":"https://dicemy.github.io/16332.html","content":"DAY1(STL)HDU1880魔咒词典（字符串Hash/map/）\n\n水题，两个map即可，细节在于string用cin读还是getline读，然后可以用string的erase来去掉中括号【】\n\n以上的话，是提交卡在队列里时自信打出来的。最后发现是水的是我。。。\n用两个map的话交一遍就会发现一定会MLE。。。而且HDU的MLE规则很奇怪，不要尝试参考评测机的内存大小来调数组的大小，没有用的。。以图为证：\n\n是的，我MLE了20多次，都是在尝试调数组的大小。。。。。\n正解应该是Hash+挂链法或者寻址法，但是我写的挂链法也还是MLE。。。最后选择了zy选择的vector。但是注意：这个代码也还是可以被卡掉，这个hash并没有处理字符串冲突的情况。\n代码：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 100010;vector&lt;int&gt; a, b; string s1[maxn];string s2[maxn];string t1, t2;int cnt, n;int gethash(string s) &#123;\tint res = 0, leng = s.length();\tfor (int i=0;i&lt;leng;++i)\t\tres += res * 237 + s[i];\treturn res;&#125;int main() &#123;\twhile(cin &gt;&gt; t1 &amp;&amp; t1 != &quot;@END@&quot;) &#123;\t\tgetchar();\t\tgetline(cin, t2);\t\tint c1 = gethash(t1);\t\tint c2 = gethash(t2);\t\ta.push_back(c1);\t\tb.push_back(c2);\t\ts1[cnt] = t1;\t\ts2[cnt++] = t2;\t&#125;\tcin &gt;&gt; n;getchar();\tfor (int i=1;i&lt;=n;++i) &#123;\t\tgetline(cin, t1);\t\tint tmp = gethash(t1);\t\tif (t1[0] == &#x27;[&#x27;) &#123;\t\t\tif (find(a.begin(), a.end(), tmp) == a.end())\tcout &lt;&lt; &quot;what?&quot; &lt;&lt; endl;\t\t\telse\tcout &lt;&lt; s2[find(a.begin(), a.end(), tmp) - a.begin()] &lt;&lt; endl;\t\t&#125;else &#123;\t\t\tif (find(b.begin(), b.end(), tmp) == b.end())\tcout &lt;&lt; &quot;what?&quot; &lt;&lt; endl;\t\t\telse &#123;\t\t\t\tstring s3 = s1[find(b.begin(), b.end(), tmp) - b.begin()];\t\t\t\tfor (int i=1;i&lt;s3.length()-1;++i)\tcout &lt;&lt; s3[i];\t\t\t\tcout &lt;&lt; endl;\t\t\t&#125;\t\t&#125;\t&#125;\treturn #include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 100010;vector&lt;int&gt; a, b; string s1[maxn];string s2[maxn];string t1, t2;int cnt, n;int gethash(string s) &#123;\tint res = 0, leng = s.length();\tfor (int i=0;i&lt;leng;++i)\t\tres += res * 237 + s[i];\treturn res;&#125;int main() &#123;\twhile(cin &gt;&gt; t1 &amp;&amp; t1 != &quot;@END@&quot;) &#123;\t\tgetchar();\t\tgetline(cin, t2);\t\tint c1 = gethash(t1);\t\tint c2 = gethash(t2);\t\ta.push_back(c1);\t\tb.push_back(c2);\t\ts1[cnt] = t1;\t\ts2[cnt++] = t2;\t&#125;\tcin &gt;&gt; n;getchar();\tfor (int i=1;i&lt;=n;++i) &#123;\t\tgetline(cin, t1);\t\tint tmp = gethash(t1);\t\tif (t1[0] == &#x27;[&#x27;) &#123;\t\t\tif (find(a.begin(), a.end(), tmp) == a.end())\tcout &lt;&lt; &quot;what?&quot; &lt;&lt; endl;\t\t\telse\tcout &lt;&lt; s2[find(a.begin(), a.end(), tmp) - a.begin()] &lt;&lt; endl;\t\t&#125;else &#123;\t\t\tif (find(b.begin(), b.end(), tmp) == b.end())\tcout &lt;&lt; &quot;what?&quot; &lt;&lt; endl;\t\t\telse &#123;\t\t\t\tstring s3 = s1[find(b.begin(), b.end(), tmp) - b.begin()];\t\t\t\tfor (int i=1;i&lt;s3.length()-1;++i)\tcout &lt;&lt; s3[i];\t\t\t\tcout &lt;&lt; endl;\t\t\t&#125;\t\t&#125;\t&#125;\treturn 0;&#125;\n\nHDU1276士兵队列训练问题（模拟/约瑟夫环）\n用vector完成，简单模拟，水题。\n第一遍没有注意输出空格PE了一次，第二遍A了\n\n代码（比较丑陋）：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; a, b;int n, m;int vsize() &#123;    int leng = a.size(), res = 0;    for (int i=1;i&lt;leng;i++) &#123;        if (a[i] != -1) res++;    &#125;    return res;&#125;void work() &#123;    int flag = 0, leng;    while(vsize() &gt; 3) &#123;        leng = a.size();        if (!flag) &#123;            for (int i=1;i&lt;leng;++i)                 if (i % 2 == 0) &#123;                    a[i] = -1;                &#125;        &#125;else &#123;            for (int i=1;i&lt;leng;++i)                 if (i % 3 == 0) &#123;                    a[i] = -1;                &#125;        &#125;        for (vector&lt;int&gt;::iterator it=a.begin();it!=a.end();it++) &#123;            if (*it == -1) &#123;                a.erase(it);                it--;            &#125;        &#125;        flag = flag == 1 ? 0 : 1;    &#125;&#125;int main() &#123;    cin &gt;&gt; n;    for (int i=1;i&lt;=n;++i) &#123;        cin &gt;&gt; m;        a.clear();        b.clear();        a.push_back(0);        for (int j=1;j&lt;=m;++j)    a.push_back(j);        work();        for (vector&lt;int&gt;::iterator it=a.begin() + 1;it!=a.end();it++) &#123;            if (*it != -1)                b.push_back(*it);        &#125;        for (vector&lt;int&gt;::iterator it=b.begin();it!=b.end();it++) &#123;            if (it != b.end() - 1)                 cout &lt;&lt; *it &lt;&lt; &#x27; &#x27;;            else cout &lt;&lt; *it;        &#125;        cout &lt;&lt; endl;    &#125;    return #include&lt;map&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; a, b;int n, m;int vsize() &#123;    int leng = a.size(), res = 0;    for (int i=1;i&lt;leng;i++) &#123;        if (a[i] != -1) res++;    &#125;    return res;&#125;void work() &#123;    int flag = 0, leng;    while(vsize() &gt; 3) &#123;        leng = a.size();        if (!flag) &#123;            for (int i=1;i&lt;leng;++i)                 if (i % 2 == 0) &#123;                    a[i] = -1;                &#125;        &#125;else &#123;            for (int i=1;i&lt;leng;++i)                 if (i % 3 == 0) &#123;                    a[i] = -1;                &#125;        &#125;        for (vector&lt;int&gt;::iterator it=a.begin();it!=a.end();it++) &#123;            if (*it == -1) &#123;                a.erase(it);                it--;            &#125;        &#125;        flag = flag == 1 ? 0 : 1;    &#125;&#125;int main() &#123;    cin &gt;&gt; n;    for (int i=1;i&lt;=n;++i) &#123;        cin &gt;&gt; m;        a.clear();        b.clear();        a.push_back(0);        for (int j=1;j&lt;=m;++j)    a.push_back(j);        work();        for (vector&lt;int&gt;::iterator it=a.begin() + 1;it!=a.end();it++) &#123;            if (*it != -1)                b.push_back(*it);        &#125;        for (vector&lt;int&gt;::iterator it=b.begin();it!=b.end();it++) &#123;            if (it != b.end() - 1)                 cout &lt;&lt; *it &lt;&lt; &#x27; &#x27;;            else cout &lt;&lt; *it;        &#125;        cout &lt;&lt; endl;    &#125;    return 0;&#125;\n\n牛客 吐泡泡（栈）\n点开之后发现5月的时候写过了。。。看了一下发现记不得自己是怎么做了，估计是要老年痴呆了（确信）简单的栈应用。\n\n代码：\n12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;#define rep(i, a, n) for (int i=a;i&lt;=n;++i)#define per(i, n, a) for (int i=n;i&gt;=a;--i)#define enter putchar(&#x27;\\n&#x27;)typedef long long ll;using namespace std;string s, ans;stack&lt;char&gt; sk;int len;int main() &#123;\twhile(cin &gt;&gt; s) &#123;\t\tans = &quot;&quot;;\t\tlen = s.length();\t\trep(i, 0, len - 1) &#123;\t\t\tif (sk.empty()) &#123;\t\t\t\tsk.push(s[i]);\t\t\t\tcontinue;\t\t\t&#125;\t\t\telse &#123;\t\t\t\tchar temp = sk.top();\t\t\t\tif (temp == s[i]) &#123;\t\t\t\t\tif (temp == &#x27;o&#x27;) &#123;\t\t\t\t\t\tsk.pop();\t\t\t\t\t\tif (sk.size() &amp;&amp; sk.top() == &#x27;O&#x27;)\tsk.pop();\t\t\t\t\t\telse\tsk.push(&#x27;O&#x27;);\t\t\t\t\t&#125;\t\t\t\t\telse\tsk.pop();\t\t\t\t&#125;else\tsk.push(s[i]);\t\t\t&#125;\t\t&#125;\t\twhile(sk.size()) &#123;\t\t\tans += sk.top();\t\t\tsk.pop();\t\t&#125;\t\tper(i, ans.size() - 1, 0) cout &lt;&lt; ans[i];\t\tenter;\t&#125;\treturn #include&lt;bits/stdc++.h&gt;#define rep(i, a, n) for (int i=a;i&lt;=n;++i)#define per(i, n, a) for (int i=n;i&gt;=a;--i)#define enter putchar(&#x27;\\n&#x27;)typedef long long ll;using namespace std;string s, ans;stack&lt;char&gt; sk;int len;int main() &#123;\twhile(cin &gt;&gt; s) &#123;\t\tans = &quot;&quot;;\t\tlen = s.length();\t\trep(i, 0, len - 1) &#123;\t\t\tif (sk.empty()) &#123;\t\t\t\tsk.push(s[i]);\t\t\t\tcontinue;\t\t\t&#125;\t\t\telse &#123;\t\t\t\tchar temp = sk.top();\t\t\t\tif (temp == s[i]) &#123;\t\t\t\t\tif (temp == &#x27;o&#x27;) &#123;\t\t\t\t\t\tsk.pop();\t\t\t\t\t\tif (sk.size() &amp;&amp; sk.top() == &#x27;O&#x27;)\tsk.pop();\t\t\t\t\t\telse\tsk.push(&#x27;O&#x27;);\t\t\t\t\t&#125;\t\t\t\t\telse\tsk.pop();\t\t\t\t&#125;else\tsk.push(s[i]);\t\t\t&#125;\t\t&#125;\t\twhile(sk.size()) &#123;\t\t\tans += sk.top();\t\t\tsk.pop();\t\t&#125;\t\tper(i, ans.size() - 1, 0) cout &lt;&lt; ans[i];\t\tenter;\t&#125;\treturn 0;&#125; \n\nDAY2(单调栈、单调队列、ST表)POJ - 3250Bad Hair Day（单调栈）\n由题可知将答案求每个羊可以看到多少只右边的羊转化为求每一个羊可以被多少左边的羊看到，然后在纸上模拟一下就可以发现单调栈满足这个过程。单调栈和单调队列难都是在思路的转换，一眼会想不到。\n\n代码（摘了眼镜看形状好奇怪啊。。）：\n12345678910111213141516171819#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;stack&lt;ll&gt; st;ll n, ans, tmp;int main() &#123;\tcin &gt;&gt; n;\tcin &gt;&gt; tmp;\tst.push(tmp);\tfor (int i=1;i&lt;n;++i) &#123;\t\tcin &gt;&gt; tmp;\t\twhile(st.size() &amp;&amp; st.top() &lt;= tmp) st.pop();\t\tans += st.size();\t\tst.push(tmp);\t&#125;\tcout &lt;&lt; ans;\treturn #include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;stack&lt;ll&gt; st;ll n, ans, tmp;int main() &#123;\tcin &gt;&gt; n;\tcin &gt;&gt; tmp;\tst.push(tmp);\tfor (int i=1;i&lt;n;++i) &#123;\t\tcin &gt;&gt; tmp;\t\twhile(st.size() &amp;&amp; st.top() &lt;= tmp) st.pop();\t\tans += st.size();\t\tst.push(tmp);\t&#125;\tcout &lt;&lt; ans;\treturn 0;&#125;\n\nPOJ - 2823 Sliding Window（单调队列）\n如果我们要得到区间的最大值，那我们可以维护一个队列，在里面存一些我们遇到过的比较大的值，并且保证这个队列是递减的。那么如果我们这时拿到一个新的数据，我们只需要把这个数据放到当前队列的正确的位置然后取队首元素就能找到最大值了。\n由于该队列是单调递增的，所以只需要将新的数据和队尾的值进行比较，如果队尾的值比较小，那么直接扔掉，因为我们要得到的是区间的最大值，所以舍去一些比较小并且比较旧的值并没有什么影响。\n对于这道题最后需要注意的是处理完数据之后的队首是否在当前数据的窗口中，若不在，那么将旧数据直接舍弃即可。\n处理区间的最小值同理。\n对于队列维护的模拟可以看这个博客。\n这道题还有一些小坑。因为在POJ上，会比较慢，用deque会T掉，可以用数组模拟一个双端队列。然后常数大也会被卡掉，所以要用快读。\n\n代码：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;deque&gt;using namespace std;const int maxn = 1e6 +7;int n, k;int a[maxn], b1[maxn], b2[maxn], tot1, tot2, h1, h2, t1, t2;pair&lt;int, int&gt; q1[maxn], q2[maxn];inline int read() &#123;    int a=0,f=1; char c=getchar();    while (c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;) &#123;if (c==&#x27;-&#x27;) f=-1; c=getchar();&#125;    while (c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;) &#123;a=a*10+c-&#x27;0&#x27;; c=getchar();&#125;    return a*f;&#125;void init() &#123;\tios::sync_with_stdio(false);\tn = read();k=read();\tfor (int i=1;i&lt;=n;++i)\ta[i] = read();\th1 = 1, h2 = 1, t1 = 1, t2 = 1;&#125;inline void write(int x)&#123;\tif(x&gt;9)write(x/10);\tputchar(x%10+&#x27;0&#x27;);&#125;void solve() &#123;\tfor (int i=1;i&lt;k;++i) &#123;\t\twhile(h1 &lt; t1 &amp;&amp; q1[t1-1].first &lt;= a[i])\tt1--;\t\twhile(h2 &lt; t2 &amp;&amp; q2[t2-1].first &gt;= a[i])\tt2--;\t\tq1[t1].second = i;q1[t1++].first = a[i];\t\tq2[t2].second = i;q2[t2++].first = a[i];\t&#125;\tfor (int i=k;i&lt;=n;++i) &#123;\t\twhile(h1 &lt; t1 &amp;&amp; q1[h1].second &lt;= i - k)\th1++;\t\twhile(h2 &lt; t2 &amp;&amp; q2[h2].second &lt;= i - k)\th2++;\t\twhile(h1 &lt; t1 &amp;&amp; q1[t1-1].first &lt;= a[i])\tt1--;\t\twhile(h2 &lt; t2 &amp;&amp; q2[t2-1].first &gt;= a[i])\tt2--;\t\tq1[t1].second = i;q1[t1++].first = a[i];\t\tq2[t2].second = i;q2[t2++].first = a[i];\t\tb1[++tot1] = q1[h1].first;\t\tb2[++tot2] = q2[h2].first;\t&#125;&#125;void print() &#123;\tfor (int i=1;i&lt;=tot1;++i)\tif(i!=tot1)\tprintf(&quot;%d &quot;,b2[i]); else printf(&quot;%d\\n&quot;,b2[i]);\tfor (int i=1;i&lt;=tot2;++i)\tif(i!=tot2)\tprintf(&quot;%d &quot;,b1[i]); else printf(&quot;%d&quot;,b1[i]);&#125;int main() &#123;\tinit();\tsolve();\tprint();\treturn #include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;deque&gt;using namespace std;const int maxn = 1e6 +7;int n, k;int a[maxn], b1[maxn], b2[maxn], tot1, tot2, h1, h2, t1, t2;pair&lt;int, int&gt; q1[maxn], q2[maxn];inline int read() &#123;    int a=0,f=1; char c=getchar();    while (c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;) &#123;if (c==&#x27;-&#x27;) f=-1; c=getchar();&#125;    while (c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;) &#123;a=a*10+c-&#x27;0&#x27;; c=getchar();&#125;    return a*f;&#125;void init() &#123;\tios::sync_with_stdio(false);\tn = read();k=read();\tfor (int i=1;i&lt;=n;++i)\ta[i] = read();\th1 = 1, h2 = 1, t1 = 1, t2 = 1;&#125;inline void write(int x)&#123;\tif(x&gt;9)write(x/10);\tputchar(x%10+&#x27;0&#x27;);&#125;void solve() &#123;\tfor (int i=1;i&lt;k;++i) &#123;\t\twhile(h1 &lt; t1 &amp;&amp; q1[t1-1].first &lt;= a[i])\tt1--;\t\twhile(h2 &lt; t2 &amp;&amp; q2[t2-1].first &gt;= a[i])\tt2--;\t\tq1[t1].second = i;q1[t1++].first = a[i];\t\tq2[t2].second = i;q2[t2++].first = a[i];\t&#125;\tfor (int i=k;i&lt;=n;++i) &#123;\t\twhile(h1 &lt; t1 &amp;&amp; q1[h1].second &lt;= i - k)\th1++;\t\twhile(h2 &lt; t2 &amp;&amp; q2[h2].second &lt;= i - k)\th2++;\t\twhile(h1 &lt; t1 &amp;&amp; q1[t1-1].first &lt;= a[i])\tt1--;\t\twhile(h2 &lt; t2 &amp;&amp; q2[t2-1].first &gt;= a[i])\tt2--;\t\tq1[t1].second = i;q1[t1++].first = a[i];\t\tq2[t2].second = i;q2[t2++].first = a[i];\t\tb1[++tot1] = q1[h1].first;\t\tb2[++tot2] = q2[h2].first;\t&#125;&#125;void print() &#123;\tfor (int i=1;i&lt;=tot1;++i)\tif(i!=tot1)\tprintf(&quot;%d &quot;,b2[i]); else printf(&quot;%d\\n&quot;,b2[i]);\tfor (int i=1;i&lt;=tot2;++i)\tif(i!=tot2)\tprintf(&quot;%d &quot;,b1[i]); else printf(&quot;%d&quot;,b1[i]);&#125;int main() &#123;\tinit();\tsolve();\tprint();\treturn 0;&#125;\n\nPOJ - 3264 Balanced Lineup（ST表/线段树/树状数组）\n这道题是学长讲的ST表的例题，本质是一个RMQ。\nST表，是利用倍增和动态规划的思想处理出的一个查询表，需要用nlogn的时间预处理，得到ST表之后，就可用O(1)的时间查询任意区间内的极值。\nST表的预处理的状态转移方程：d1[i][j]=min(d1[i-1][j],d1[i-1][j+bin[i-1]]); i表示2的i次方，j表示某个点。对于每一个点的所有有意义的2的i次方长度的区间内的极值都需要求出。\nST算法进行查询的核心是在预处理出每个端点本身开始往后的2的i次方的范围内的每一个2区间内的极值后。对于每一次查询，找到满足区间长度r - l + 1所能满足的最大的2的x次方，然后将长度分为两半，以2的x-1次方为区间长度对两个端点的左右进行查询，O（1）的复杂度，然后取这两个值中的极值即为区间的极值。\n参考博客：https://blog.csdn.net/Keep_Trying_Go/article/details/116268533https://blog.csdn.net/Hanks_o/article/details/77547380\n\n\n代码：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;cstring&gt;#define rep(i,a,b) for (int i=a;i&lt;=b;++i)using namespace std;const int maxn = 50010;int n, q; int a[maxn], bin[30], Log[maxn];int d1[30][maxn], d2[30][maxn];void init() &#123;\tmemset(a,0,sizeof(a));\tmemset(d1,0,sizeof(d1));\tmemset(d2,0,sizeof(d2));\tbin[0] = 1;Log[0] = -1;\tcin &gt;&gt; n &gt;&gt; q;\trep(i,1,n)\tcin &gt;&gt; a[i];\trep(i,1,20)\tbin[i] = bin[i - 1] * 2;\trep(i,1,50001)\tLog[i] = Log[i/2] + 1;\trep(i,1,n)\td1[0][i] = d2[0][i] = a[i];\trep(i,1,Log[n]) &#123;\t\trep(j,1,n) &#123;\t\t\tif(j+bin[i]-1&lt;=n) &#123; \t\t\t\td1[i][j]=min(d1[i-1][j],d1[i-1][j+bin[i-1]]);\t\t\t\td2[i][j]=max(d2[i-1][j],d2[i-1][j+bin[i-1]]);\t\t\t&#125; \t\t&#125;\t&#125;&#125;void query(int x ,int y) &#123;\tint t = Log[y-x+1];\tint a = max(d2[t][x],d2[t][y-bin[t]+1]);\tint b = min(d1[t][x],d1[t][y-bin[t]+1]);\tcout &lt;&lt; a - b &lt;&lt; endl;&#125;int main() &#123;\tinit();\trep(i,1,q) &#123;\t\tint a, b;\t\tcin &gt;&gt; a &gt;&gt; b;\t\tquery(a, b);\t&#125;\treturn #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;cstring&gt;#define rep(i,a,b) for (int i=a;i&lt;=b;++i)using namespace std;const int maxn = 50010;int n, q; int a[maxn], bin[30], Log[maxn];int d1[30][maxn], d2[30][maxn];void init() &#123;\tmemset(a,0,sizeof(a));\tmemset(d1,0,sizeof(d1));\tmemset(d2,0,sizeof(d2));\tbin[0] = 1;Log[0] = -1;\tcin &gt;&gt; n &gt;&gt; q;\trep(i,1,n)\tcin &gt;&gt; a[i];\trep(i,1,20)\tbin[i] = bin[i - 1] * 2;\trep(i,1,50001)\tLog[i] = Log[i/2] + 1;\trep(i,1,n)\td1[0][i] = d2[0][i] = a[i];\trep(i,1,Log[n]) &#123;\t\trep(j,1,n) &#123;\t\t\tif(j+bin[i]-1&lt;=n) &#123; \t\t\t\td1[i][j]=min(d1[i-1][j],d1[i-1][j+bin[i-1]]);\t\t\t\td2[i][j]=max(d2[i-1][j],d2[i-1][j+bin[i-1]]);\t\t\t&#125; \t\t&#125;\t&#125;&#125;void query(int x ,int y) &#123;\tint t = Log[y-x+1];\tint a = max(d2[t][x],d2[t][y-bin[t]+1]);\tint b = min(d1[t][x],d1[t][y-bin[t]+1]);\tcout &lt;&lt; a - b &lt;&lt; endl;&#125;int main() &#123;\tinit();\trep(i,1,q) &#123;\t\tint a, b;\t\tcin &gt;&gt; a &gt;&gt; b;\t\tquery(a, b);\t&#125;\treturn 0;&#125;\n\nPOJ - 2559 Largest Rectangle in a Histogram （单调栈）\n单调栈的应用。\n对于每一个长方形来说，如果不重复计算的话，这道题的答案就是每个长方形向右画的长方形中面积最大的那一个。\n接着想，对于某个长方形，它所能画出的最大高度就是他本身，最大宽度就是他往右的连续的不低于他的长方形的宽度。对于一个高度上升的长方形序列，其中一个长方形所能达到的最大面积就是向右不低于该长方形的所有长方形的宽度和，所以，对于一个还在上升的序列，并不能知道它最右边能够到达的宽度有多少，所以将其加入栈中，如果发现了一个长方形的高度下降，那么这个长方形一定可以作为上升序列中的一些长方形的右边界。此时开始计算，直到序列恢复递增为止。\n\n代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#define rep(i,a,b) for (int i=a;i&lt;=b;++i)using namespace std;typedef long long ll;const int maxn = 100010;ll n, a[maxn], w[maxn], s[maxn], tail, ans;inline void init() &#123;\tmemset(w, 0, sizeof(w));\tmemset(a, 0, sizeof(a));\tmemset(s, 0, sizeof(s));\tans = 0, tail = 0;\ts[n + 1] = 0;\trep(i,1,n)\tcin &gt;&gt; a[i];&#125;void solve() &#123;\trep(i,1,n+1) &#123;\t\tif (a[i] &gt; s[tail]) &#123;\t\t\ts[++tail] = a[i];\t\t\tw[tail] = 1;\t\t&#125; else &#123;\t\t\tint width = 0;\t\t\twhile(a[i] &lt; s[tail]) &#123;\t\t\t\twidth += w[tail];\t\t\t\tans = max(ans, (ll)width * s[tail]);\t\t\t\ttail--;\t\t\t&#125;\t\t\ts[++tail] = a[i], w[tail] = width + 1;\t\t&#125;\t&#125;&#125;int main() &#123;\twhile(cin &gt;&gt; n &amp;&amp; n != 0) &#123;\t\tinit();\t\tsolve();\t\t\tcout &lt;&lt; ans &lt;&lt; endl;\t&#125;\treturn #include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#define rep(i,a,b) for (int i=a;i&lt;=b;++i)using namespace std;typedef long long ll;const int maxn = 100010;ll n, a[maxn], w[maxn], s[maxn], tail, ans;inline void init() &#123;\tmemset(w, 0, sizeof(w));\tmemset(a, 0, sizeof(a));\tmemset(s, 0, sizeof(s));\tans = 0, tail = 0;\ts[n + 1] = 0;\trep(i,1,n)\tcin &gt;&gt; a[i];&#125;void solve() &#123;\trep(i,1,n+1) &#123;\t\tif (a[i] &gt; s[tail]) &#123;\t\t\ts[++tail] = a[i];\t\t\tw[tail] = 1;\t\t&#125; else &#123;\t\t\tint width = 0;\t\t\twhile(a[i] &lt; s[tail]) &#123;\t\t\t\twidth += w[tail];\t\t\t\tans = max(ans, (ll)width * s[tail]);\t\t\t\ttail--;\t\t\t&#125;\t\t\ts[++tail] = a[i], w[tail] = width + 1;\t\t&#125;\t&#125;&#125;int main() &#123;\twhile(cin &gt;&gt; n &amp;&amp; n != 0) &#123;\t\tinit();\t\tsolve();\t\t\tcout &lt;&lt; ans &lt;&lt; endl;\t&#125;\treturn 0;&#125;\n","categories":[],"tags":[]},{"title":"数学建模常用算法学习","url":"https://dicemy.github.io/35840.html","content":"层次分析法（AHP）一、对于一个问题，先分析系统中各因素之间的关系，建立系统的递阶层次结构（三层图）。\n二、然后对于同一层次的各元素关于上一层中某一准则的重要性进行两两比较，构造判断矩阵。\n\n在准则层需要生成每个准则的权重，在方案层需要生成对于每个准则的得分，使用两两对比的方法生成判断矩阵然后就可以计算出每个准则的权重或者方案对不同准则的得分了。\n在层次分析法中我们构造的判断矩阵均是正互反矩阵(𝑎ij * 𝑎ji = 1)，若正互反矩阵满足𝑎ij  * 𝑎jk = 𝑎ik，则我们称为一致矩阵。在判断矩阵计算准则的权重或者方案对不同准则的得分之前，需要对其进行一致性检验。\n\n三、通过计算一致性指标和一致性比例来评判判断矩阵是否可以接受，计算对于该准则的相对权重。\n\n进行一致性检验的一致矩阵准则的权重的计算或者方案对不同准则的得分的计算，计算权重或者得分有多种方式：\n\n算数平均法求权重\n\n集合平均法求权重\n\n特征值法求权重\n\n\n计算出所有的方案对不同准则的得分和准则的权重之后就可以计算每个方案的加权得分了。\n\n四、计算各层元素对系统目标的合成权重，并进行排序。\nTOPSIS法（优劣解距离法）一、将原始矩阵正向化，将所有的指标转化成极大型指标。\n\n\n极大型指标\n极小型指标\n中间型指标\n区间型指标\n\n\n二、正向化矩阵标准化。\n\n消除不同指标量纲的影响，例如名次和分数两个指标导致的量纲不统一的影响。\n\n三、计算得分并归一化\n\n通过公式计算每一个评价对象对不同的评价指标离最小值的距离和到最大最小距离的和的比值来得到评价对象在该评价指标上的得分。\n\n四、带权重的TOPSIS\n\n通过层次分析法可以得到不同的指标的权值，在进行计算得分的时候乘以相应的权值。\n\n插值算法\n理解：感觉该算法就是通过已知的一些点来推测拟合出一个函数，并借此函数计算出需要插值的点所对应的值是多少\n常见插值方法：\n\n多项式插值\n分段插值\n三角插值\n\n\n一、拉格朗日插值法\n\n\n\n通过该方法，可以通过n+1个点来找到一个n+1项n次的一个多项式作为插值函数，来估计对应插值点的函数值。\n\n龙格现象：高次插值会产生龙格现象，即在两端处波动极大，产生明显的震荡。在不熟悉曲线的运动趋势的前提下，不要轻易使用高次插值\n分段线性插值\n\n分段线性插值法的一种为分段二次插值法，在几何上利用分段抛物线来代替原函数，故分段二次插值法又称为分段抛物线插值法。\n但是在分段时使用的插值方法本质还是拉格朗日插值法。\n\n二、牛顿插值法\n\n\n\n与拉格朗日插值法相比，牛顿插值法具有继承性。（牛顿插值法每次插值只和前n项的值有关，这样每次只要在原来的函数上添加新的项，就能够产生新的函数）但是牛顿插值也存在龙格现象的问题。\n\n\n拉格朗日插值法和牛顿插值法两种方法得到的多项式都不能全面的反映被插值函数的形态，比如说在一个或者全部节点上的导数值，或者高阶导数值，这两种插值法都不能满足。\n\n三、埃尔米特（Hermite）插值法\n\n埃尔米特插值法可以保证插值函数在节点处有切线（光滑）使插值函数和被插值函数的密合程度比较好。\n\n分段三次埃尔米特插值法\n\n直接使用Hermite插值得到的多项式的次数也比较高，也会存在龙格现象，因此在实际应用中，往往使用分段三次Hermite插值多项式（PCHIP）\n\n四、三次样条插值法\n\n该插值法同样是区间插值法，是可以保证二阶连续可微的插值法。\n\n这些插值法都在Matlab内部提供了封装好的实现方法，体现为内置的函数。\n","categories":["技术"],"tags":[]},{"title":"Matlab学习笔记","url":"https://dicemy.github.io/29380.html","content":"语法小知识：\n\n同一行中间用逗号分隔，也可以不用逗号，直接用空格 分号可以用来分隔每一行的元素就是说逗号是一行中的数据，分号分割行与行之间。\n矩阵E(:)表示矩阵的所有元素，E(:,1)表示第一列，E(1,:)表示第一行。\n2:5表示从第2到第5，1:3:10表示从1到10，每次递增3。2:end表示从第二行到最后一行，\n~=是不等号\nMatlab函数的声明要单独放在一个.m文件中，不能直接放在主函数里面。函数声明格式：function [输出变量] = 函数名称(输入变量）  最后用end结束声明\n\n123456789101112131415161718192021222324252627282930313233343536373839404142% 常用指令操作clc % 清屏clear all % 清除工作区的所有变量hold on hold off % 控制图像是否被刷新% 常用字符串函数char(65) % ascii码对应的字符，Alength(s) % 字符串长度strcmp() % 字符串比较函数strcat() % 将多个字符串合并成一个num2str() % 将数字转换为字符串% 常用数学函数size() % 数组大小，第二个参数也是dim表示矩阵的维度。magic() % 生成一个幻方abs(s) % 求s的ascii码floor()\t% 取整函数sum() % 求和函数，辅助参数dim表示求和的维度，1表示按列，2表示按行，默认dim=1repmat() % 复制扩展矩阵sort() % 将数组或矩阵排序prod() % 计算矩阵每一列的乘积eig() % 计算矩阵的特征值inv() % 求矩阵的逆矩阵rand() % 产生（0,1）之间均匀分布的伪随机数组成的数组randn() % 生成标准正态分布的伪随机数（均值为0，方差为1）randperm() % 将一序号随机打乱，序号必须是整数normrnd(MU,SIGMA) % 生成服从正态分布的随机数% 常用数据输入输出函数disp() % 向命令行输出字符或数字input() % 从命令行读取数据xlsread(&#x27;xls_name_string&#x27;) % Excel表格读取save % 用来将数据保存为.mat文件load % 用来加载之间生成的.mat文件% 常用绘图函数plot(x, y) % 创建2维直线图stem(Y) % 绘制数据序列Y的茎状图meshgrid(a, b) % 生成二维网格contour3(x, y, z) % 三维等值线绘图legend(&#x27;string1&#x27;,&#x27;string2&#x27;) % 标注绘制的图形的名称xlabel() ylabel() zlabel() % 标注x,y,z轴title()\t% matlab绘图标题设置set() % 设置图像属性axis() % 常用指令操作clc % 清屏clear all % 清除工作区的所有变量hold on hold off % 控制图像是否被刷新% 常用字符串函数char(65) % ascii码对应的字符，Alength(s) % 字符串长度strcmp() % 字符串比较函数strcat() % 将多个字符串合并成一个num2str() % 将数字转换为字符串% 常用数学函数size() % 数组大小，第二个参数也是dim表示矩阵的维度。magic() % 生成一个幻方abs(s) % 求s的ascii码floor()\t% 取整函数sum() % 求和函数，辅助参数dim表示求和的维度，1表示按列，2表示按行，默认dim=1repmat() % 复制扩展矩阵sort() % 将数组或矩阵排序prod() % 计算矩阵每一列的乘积eig() % 计算矩阵的特征值inv() % 求矩阵的逆矩阵rand() % 产生（0,1）之间均匀分布的伪随机数组成的数组randn() % 生成标准正态分布的伪随机数（均值为0，方差为1）randperm() % 将一序号随机打乱，序号必须是整数normrnd(MU,SIGMA) % 生成服从正态分布的随机数% 常用数据输入输出函数disp() % 向命令行输出字符或数字input() % 从命令行读取数据xlsread(&#x27;xls_name_string&#x27;) % Excel表格读取save % 用来将数据保存为.mat文件load % 用来加载之间生成的.mat文件% 常用绘图函数plot(x, y) % 创建2维直线图stem(Y) % 绘制数据序列Y的茎状图meshgrid(a, b) % 生成二维网格contour3(x, y, z) % 三维等值线绘图legend(&#x27;string1&#x27;,&#x27;string2&#x27;) % 标注绘制的图形的名称xlabel() ylabel() zlabel() % 标注x,y,z轴title()\t% matlab绘图标题设置set() % 设置图像属性axis() % 对坐标轴进行缩放操作\n\n\n\n123% matlab里的一些基本规范% 数值% matlab里的一些基本规范% 数值% 字符串\n\n\nfloor函数详解\nrandperm函数详解\nnormrnd函数详解\nrepmat函数详解\nsize函数详解\nmagic函数详解\nsum函数详解\nprod函数详解\neig函数详解\nfind函数详解\nplot命令详解\nmeshgrid函数详解\ncontour3函数详解\nstem函数详解\nhold on 和 hold off 语句详解\nlegend函数详解\nxlabel函数详解\nset函数详解\naxis函数详解\ntitle函数详解+matlab二维画图基本操作\nxlsread函数详解\ndisp函数详解\ninput函数详解\nsave 和 load详解\n\n一、矩阵及数组操作例题：\n1234567891011121314151617181920212223% 生成一个3x3和15x8的单位矩阵eye(3, 3)eye(15, 8)% 生成全1矩阵ones(3)ones(15, 8)% 全0矩阵zeros(3)zeros(15, 8)% 均匀分布随机矩阵（[-1, 1]之间）2 * rand(3, 3) - 12 * rand(15, 8) - 1% 正态分布矩阵（均值为1，方差为4）1+sqrt(4)*randn(3,3)% 利用fix及rand函数生成[0,10]上的均匀分布的10x10的整数随机矩阵a，然后统计a中大于等于5的元素的个数。a = fix(10*rand(10,10));b = [a&gt;=5];c = [sum(b)];sum(c&#x27;)% 在给定的矩阵中删除含有整行内容全为0的行，删除整列内容全为0的列。a = [1 2 0 4;0 0 0 0;5 6 0 8; 9 1 0 2];a(:,find(sum(abs(a&#x27;))==0)) = [];a(find(sum(abs(a&#x27;))==0),:) = [] % 生成一个3x3和15x8的单位矩阵eye(3, 3)eye(15, 8)% 生成全1矩阵ones(3)ones(15, 8)% 全0矩阵zeros(3)zeros(15, 8)% 均匀分布随机矩阵（[-1, 1]之间）2 * rand(3, 3) - 12 * rand(15, 8) - 1% 正态分布矩阵（均值为1，方差为4）1+sqrt(4)*randn(3,3)% 利用fix及rand函数生成[0,10]上的均匀分布的10x10的整数随机矩阵a，然后统计a中大于等于5的元素的个数。a = fix(10*rand(10,10));b = [a&gt;=5];c = [sum(b)];sum(c&#x27;)% 在给定的矩阵中删除含有整行内容全为0的行，删除整列内容全为0的列。a = [1 2 0 4;0 0 0 0;5 6 0 8; 9 1 0 2];a(:,find(sum(abs(a&#x27;))==0)) = [];a(find(sum(abs(a&#x27;))==0),:) = [] % 没看懂，该写法待确认\n\n二、绘图：\n123456789101112% 在同一图形窗口画出下列两条曲线图像，并用legend标注：x=0 : 1 : 10;y1=2*x+5;y2=x.^2-3*x+1;plot(x, y1, x, y2);legend(&#x27;y1&#x27;,&#x27;y2&#x27;)% 画出下列函数的曲面及等高线% z = x^2 + y^2 + sin(xy).[x, y] = meshgrid(0:0.25:4*pi);z=x.^2+y.^2+% 在同一图形窗口画出下列两条曲线图像，并用legend标注：x=0 : 1 : 10;y1=2*x+5;y2=x.^2-3*x+1;plot(x, y1, x, y2);legend(&#x27;y1&#x27;,&#x27;y2&#x27;)% 画出下列函数的曲面及等高线% z = x^2 + y^2 + sin(xy).[x, y] = meshgrid(0:0.25:4*pi);z=x.^2+y.^2+sin(x*y);contour3(x, y, z);meshc(x, y, z)\n\n三、简单程序设计\n123456789101112131415161718192021222324% 求分段函数x=input(&#x27;请输入x的值：&#x27;);if x&gt;=-3 &amp;&amp; x &lt; -1    y=(-x^2-4*x-3)/2;elseif x&gt;=-1 &amp;&amp; x&lt;1    y=-x^2+1;elseif x&gt;=1 &amp;&amp; x&lt;=3    y=(-x^2+4*x-3)/2;else    y=&#x27;error&#x27;endy% 分数序列求和m = 1;n = 2;sum = 0;for k=1:15    f=n/m;    sum=sum+f;    t=n;    n=m+n;    m=t;% 求分段函数x=input(&#x27;请输入x的值：&#x27;);if x&gt;=-3 &amp;&amp; x &lt; -1    y=(-x^2-4*x-3)/2;elseif x&gt;=-1 &amp;&amp; x&lt;1    y=-x^2+1;elseif x&gt;=1 &amp;&amp; x&lt;=3    y=(-x^2+4*x-3)/2;else    y=&#x27;error&#x27;endy% 分数序列求和m = 1;n = 2;sum = 0;for k=1:15    f=n/m;    sum=sum+f;    t=n;    n=m+n;    m=t;endsum\n\n一些注意事项:\n\n在变量定义的时候多写注释，注明每个变量的作用。\n好的数学建模matlab的代码部分注释都很详细。\n可以将代码分成几个部分，这样更加清晰，e.g. 数据清除，导入数据，数据预处理，相关步骤等….\n在很多代码开头会遇到：clear;clc 这两条一起使用，起到“初始化”的作用，防止之前的结果对新脚本文件（后缀名是 .m）产生干扰。\n\n","categories":["技术"],"tags":[]},{"title":"Hyperledger Fabric平台搭建笔记","url":"https://dicemy.github.io/29920.html","content":"centos7.9系统的安装和基础配置\n记得选择语言，汉语，这是在安装界面可以看到的。ps：选错语言的话酒删了重装吧。\n记得选择磁盘位置\n记得连接网络，很重要！！！ps：如果在有图形的安装界面不进行勾选的话 ，之后再更改配置会十分的困难。\n记得勾选基本的安装包。ps：如果不勾选的话一些基本的yum或者tar指令都无法使用。但是也不要选择太多的包，不然有可能会和自己安装的服务产生冲突。\n然后进行安装即可。ps：这样进行的安装是没有图形界面的。\n\n如何更换字体和字号：\n\n进入/lib/kbd/consolefonts，选择合适的字体。\n输入setfont指令，后面跟上字体的名称。\n输入echo &#39;setfont latarcyrheb-sun32&#39; &gt;&gt; /etc/profile指令将字体设置设为开机启动。\n\nwget的安装：\n\n刚开始安装好的centos系统是没有wget的，需要用yum安装。\nyum -y install wget\n\nGo语言安装\nGo语言安装\n从官网下载最新的linux-amd64.tar.gz压缩包（这里是go1.15.6.linux-amd64.tar.gz）\n1wget https://golang.google.cn/dl/go1.15.6.linux-amdwget https://golang.google.cn/dl/go1.15.6.linux-amd64.tar.gz\n\n将其解压到/usr/local目录下：\n1sudo tar -C sudo tar -C /usr/local -zxf [压缩包名]\n\n配置环境变量，在/etc/profile文件的末尾加入（在加入之前创建/home/gopath目录）\n12export GOPATH=/home/gopathexport PATH=$PATHexport GOPATH=/home/gopathexport PATH=$PATH:/usr/local/go/bin\n\n配置中国的代理\n12go env -w GO111MODULE=ongo env -w GOPROXY=https://goproxy.go env -w GO111MODULE=ongo env -w GOPROXY=https://goproxy.cn,direct\n\n查看是否配置成功\n1go go env\n\n\n\n\nmwget安装wget太慢使用mwget\n12345678910wget http://jaist.dl.sourceforge.net/project/kmphpfm/mwget/0.1/mwget_0.1.0.orig.tar.bz2yum install bzip2 gcc-c++ openssl-devel intltool -ybzip2 -d mwget_0.1.0.orig.tar.bz2tar -xvf mwget_0.1.0.orig.tar cd mwget_0.1.0.orig./configure makemake install　　echo wget http://jaist.dl.sourceforge.net/project/kmphpfm/mwget/0.1/mwget_0.1.0.orig.tar.bz2yum install bzip2 gcc-c++ openssl-devel intltool -ybzip2 -d mwget_0.1.0.orig.tar.bz2tar -xvf mwget_0.1.0.orig.tar cd mwget_0.1.0.orig./configure makemake install　　echo \"至此，安装完成\"% 断点续传wget -c 要下载的文件，实现断点续传。\n\n最后的配置工作生成身份材料\n\n进入BasicNetwork-2.0/artifacts/channel目录，执行\n1././create-artifacts.sh\n\n进入BasicNetwork-2.0/artifacts目录执行\n1./docker-compose up -d\n\n进入BasicNetwork-2.0\n1./createChannel.sh\n\n\n\n智能合约部署\n\n进入BasicNetwork-2.0/artifacts/src/github.com/fabcar/go/目录下，执行（为智能合约安装依赖）\n\n1GO111MODULE=GO111MODULE=on go mod vendor\n\n\n进入BasicNetwork-2.0/，执行智能合约的部署和测试在执行deployChaincode.sh之前，按以下命令修改文件夹的权限\n\n1sudo chmod 777 sudo chmod 777 /home/gopath/*\n\n\n开始部署\n\n1./deployChaincode.sh\n\n部署explorer\n\n启动Explorer, 进入ContainerisingBlockchainExplorer目录下\n1docker-compose up -d\n\n\n\n服务全部启动成功，可以在windows上查看相关的服务。\n注意：hyperledge Fabric搭建完成后将虚拟机挂起后再重新开启并不能恢复所有的服务，需要重新开启一遍。\n平台使用查看可视化的区块链信息，访问：\n1[ip地址]:[ip地址]:8080\n\n查看产的最新状态，访问：\n1[ip地址]:[ip地址]:5984/_utils\n\n常用操作超级账本的下载地址：\n1wget -c https://github.com/hyperledger/fabric/releases/download/v2.2.1/hyperledger-fabric-linux-amd64-2.2.1.tar.gz\n\n超级账本的解压缩：\n1sudo tar -C ./ -zxf hyperledger-fabric-linux-amd64-2.2.1.tar.gz\n\n超级账本的bin目录内的东西放到/usr/local/bin下\n1sudo mv ./bin/* /usr/local/bin\n\n启动docker服务\n1systemctl systemctl restart docker.service\n\n关闭所有运行着的docker容器\n1docker rm -f $(docker ps -a -docker rm -f $(docker ps -a -q)\n\n","categories":["技术"],"tags":[]},{"title":"Hyperledger Fabric学习笔记","url":"https://dicemy.github.io/22539.html","content":"Hyperledger Fabric文档阅读介绍区块链： 分布式网络，节点维护，不可篡改的账本，共识协议来验证交易，节点执行交易来维护账本的副本，账本以区块的方式存在，区块通过哈希和之前的区块相连。\n区块链的应用：加密货币：比特币、以太坊：智能合约：为分布式应用创建平台。：公共非许可区块链技术，公共网络，匿名互动。\n公共非许可区块链技术的缺点：性能较差，身份匿名。\n企业级应用的需求：身份识别，性能强，低延迟，隐私性和机密性。\nHyperledger  Fabric的自身定位：开源企业级许可分布式账本技术平台。高度*模块化**，可配置*的架构，支持**通用编程语言编写智能合约，平台是*许可的**，参与者确实*存在信任，**可插拔的共识协议，可以利用*不需要原生加密货币的共识协议**，性能较好*，**隐私和保密。\n特性的一些解释：非许可区块链：匿名，信任通过工作量证明进行，采用挖矿来抵消工作量证明的成本。许可区块链:**使用共识协议来进行信任，不需要昂贵的挖掘。**智能合约：“链码”，受信任的分布式应用程序。从区块链中获得信任，在节点中达成共识。共识协议：验证，排序交易，传播到所有节点，各节点按顺序执行交易。一种新方法消除了非确定性，标准编程语言。隐私和保密性：公共非许可区块链网络中，基于Pow的拜占庭容错共识牺牲了合约和数据的保密性。加密数据：可能被破解，零知识证明：使用其他共识，将机密信息限制于授权节点中。可插拔共识：模块化的共识性能和可扩展性：\n介绍什么是区块链？：一个分布式账本，记录网络上所有的交易。去中心化，协作维护。信息仅能以附加的方式记录到区块链上，并使用加密技术保证一旦将交易添加到账本就无法修改。简化了信息的溯源。区块链有时被描述为 证明系统 。\n智能合约：为了支持以同样的方式更新信息，并实现一整套账本功能（交易，查询等），区块链使用 智能合约 来提供对账本的受控访问。智能合约不仅是在网络中封装和简化信息的关键机制，它还可以被编写成自动执行参与者的特定交易的合约。\n共识：保持账本在整个网络中同步的过程称为 共识 。该过程确保账本仅在交易被相应参与者批准时更新，并且当账本更新时，它们以相同的顺序更新相同的交易。\n区块链的不同：一套在网络上建立身份，执行交易和存储数据的标准方法。资产来源可以通过查看交易列表来确定，此列表一旦写入，无法更改，因此可信任。\nHyperledger Fabric 与其他区块链系统不同的地方是 私有 和 许可 。与允许未知身份参与网络的开放式非许可系统（需要诸如“工作量证明”之类的协议来验证交易并保护网络）不同，Hyperledger Fabric 网络的成员需要从可信赖的 成员服务提供者（MSP） 注册。\nHyperledger Fabric 还提供创建 通道 的功能，允许一组参与者创建各自的交易账本。对于某些网络而言，这是一个特别重要的选择。这些网络中，一些参与者可能是竞争对手，并且不希望他们做出的每笔交易都被每个参与者知晓，例如，他们只向某些参与者提供的特殊价格，而其他人不是。如果两个参与者组成一个通道，那么只有这两个参与者拥有该通道的账本副本，而其他参与者没有。\n智能合约：Hyperledger Fabric 智能合约用 链码 编写，当该应用程序需要与账本交互时，由区块链外部的应用程序调用。在大多数情况下，链码只与账本的数据库、世界状态（例如，查询）交互，而不与交易日志交互。\nHyperledger Fabric 支持私有网络（使用通道）是很重要的，因为网络是相对开放的。\n共识：交易必须按照发生的顺序写入账本，即使它们可能位于网络中不同的参与者集合之中。为此，必须建立交易的顺序，且必须采用一种方法来拒绝错误（或恶意）插入到账本中的非法交易。\n这是一个彻底的计算机科学研究领域，且有很多方法可以实现它，每个方法都有不同的权衡。例如，PBFT（实用拜占庭容错算法）可以为文件副本提供一种机制，使其能够保持各个副本的一致性，即使在发生损坏的情况下也是如此。或者，在比特币中，通过称为挖矿的过程进行排序，其中竞争计算机竞相解决加密难题，该难题定义所有过程随后构建的顺序。\nHyperledger Fabric 被设计为允许网络启动者选择最能代表参与者间存在的关系的共识机制。与隐私一样，有一系列需求；从他们的关系高度结构化的网络，到更加点对点的网络。\n","categories":["技术"],"tags":[]},{"title":"大学物理复习笔记","url":"https://dicemy.github.io/4612.html","content":"第16章第1-3节：q = ne    电荷是量子化的    e = 1.62×10 ^ -19 C密立根油滴实验：电荷的量子性。mC        uC        nC        pC10^-3    10^-6    10^-9    10^-12质子的质量：1.6×10^-27电子的质量：9×10^-31\n极化：电中性的物体中，正负电荷的中心不重合的现象。\n库伦定律：\nK的值：9×10^9 N·㎡/C^2\n同号相斥，异号相吸\n场是一种物质，无静止质量\n第4节：电场强度：单位： N/C  or   V/m   是电场中某一点的一个性质\n    q是场源电荷    \n两条电场线不会相交，电场线不闭合\n电偶极子：电偶极矩：p ⃑ = ql ⃑   方向从负电荷指向正电荷\n薄金属球壳中电场线的分布\n第5节：“无限大”带电平面所激发的电场\nσ:平面上的电荷面密度。“无限大”带电平面所激发的电场强度与离平面的距离无关，即在平面两侧形成一均匀场.\n带有等量异号的平行金属板所产生的电场\nσ:平面上的电荷面密度\n第6节：导体处于静电平衡时，内部电场为0。静电荷分布在导体表面，尖端电荷密度最高。导体内部没有电场线，电场线垂直与导体表面尖端放电现象。\n当腔内无导体时：空腔导体不接地的时候外面的电场不会影响腔内当腔内有导体时：空腔导体接地时外面的电场不会影响腔内\n在空腔中的导体位置进行移动的话，对腔内和腔外的电场分布没有影响。\n第7节：电通量：通过电场中某一给定平面的电场线的总条数叫做通过该面的电通量（垂直穿过或者斜着穿过对电通量的大小相同）电通量计算公式：\n\n\n\n\n简单来说，就是某块平面的电场强度乘以这块平面的面积。几何意义：通过闭合曲面的电场线的净条数。\n高斯定理：\n\n\n静电场的高斯定理(Gauss’s law) 的表述:在静电场内,任一闭合面的电通量等于这闭合面所包围的电量的代数和(净电荷)除以ε0 .该定理将一任意闭合曲面上的电场和闭合曲面内所包围的净电荷联系起来。静电场是有源场。高斯定理求出来的是电通量，电通量乘以面积得到的是电场强度。\n高斯定理在求解场强方面的应用：\n\n均匀带电球面的电场分布，设球面半径为R，球面上所带总电量为q。\n\n电荷均匀分布在一条长直细线上。线上单位长度所带电荷恒定为λ。求距离细线r处电场的大小，假设此处与线的两端相距很远。\n\n求无限大均匀带电平面的电场分布。已知带电平面电荷面密度为σ。\n\n\n第17章第1节：保守力：力所做的功和始末位置有关，和路径无关。静电场环路定理：静电场强沿任意闭合路径的线积分为零。反映了静电场是保守力场（无旋场）。\n凡保守力都有与其相关的势能，静电场是有势场。\n势能与做功的关系\n电势能只与物体的位置有关，与路径无关。\n电场力推出的电势能的公式。\n第2节：\n当取试验电荷为单位正电荷时，V_a和U_a等值，这表示静电场中某点的电势在数值上等于单位正电荷放在该点处时的电势能，也等于单位正电荷从该点经过任意路径到电势零点时电场力所做的功。\n求均匀带电球面的电势分布。设球面半径为R，带电量为Q：\n电势分布：\n\n\n  一个带电的导体球外的电场和其上所带电荷都集中在球心时形成的点电荷产生的电场相同。\n\n\n\n\n点电荷的电势：\n点电荷的电势能：\n注意：电场是矢量，电势是标量电场为零的地方电势可以不为零；电势为零的地方电场也可以不是零。\n第3-4节：等势面：将电势相等的场点连成连续的曲面——等势面相邻等势面的电势差为常量，可以得到一系列的等势面\n电荷沿等势面移动，电场力不做功。\n电势能只与物体的位置有关，与路径无关。\n静电平衡下的导体内部和导体表面处处电势相等，整个导体是个等势体，导体表面成为等势面。\n第5节：电容器：一种储存电能的原件，由电介质隔开的两块任意形状导体组合而成。两导体称为电容器的极板。\n定义式：单位：F(法拉)\n\nC 是描述电容器储电本领的物理量\n C 取决于电容器两板的形状、大小、相对位置及中间电介质的种类和分布情况；\n\n物理意义：导体每升高单位电势所需的电量。\n组成：用真空或绝缘体分开的两个导体。\n\n平行板电容器的推导式。\n球形电容器的推导式。\n圆柱形电容器的推导式。当极板间距d&lt;&lt; RA时，圆柱形电容器类似于平行板电容器。\n\n电容的串并联：\n并联：\n串联：\n第6节：相对介电常数：相对介电常数是一个量纲为一的数，即有介质时的电容和没有介质时的电容比值。\n电介质的介电常数与真空介电常数的比值。电容器存储的电势能\n能量密度：单位体积的电势能该能量密度的表达式对任意电场都普遍成立。只要有电场的地方就有能量。\n第18章：第1-3节：电流：单位时间通过垂直于电流方向的某一面积的净电量。载流子：自由电子、离子、空穴（正的载流子叫作空穴）\n电池的电动势：\n普通电池尺寸不同，电池越大，它储存的化学物质的量就越多，相应储存的化学能就越多，但它们都提供相同的电动势（1.5V）大小电池的另外一个区别就是大电池通常能更快的抽运电荷，也就是说大电池能提供更大的电流。\n电流可表示为：单位体积内传导电子的数量：n，在体积A vD Δt内的电子数为N = nA vD Δt，电量为： ΔQ=Ne= neA vD Δt，\n第4节：欧姆定律：\n电阻定义： 单位：欧姆（Ω）1 Ω=1V/A电阻率：\n电阻率和温度的关系：\n路端电压（V）：\n第5节:基尔霍夫节点电流定律：流入一个节点的所有支路的电流之和等于流出这个节点的所有支路的电流之和。任何一个电的连接点即为节点。\n\n\n基尔霍夫回路电压定律:适用于电路中起始和终止于同一点的任何回路。电势改变的代数和为零。\n\n\n第6节：串联与并联电路：串联电阻器:\n\n\n串联电容器:\n\n\n并联电阻器:\n\n\n并联电容器：\n\n\n第8-11节：电路中的功率与能量：功率的单位：J/s=A·V=W\n在电阻上的能量可表示为:    \n\n\n\n\n电流表和电压表\nRC电路：同时包含电阻器和电容器的电路。\n第19章：第1-2节：磁感应强度B：单位 (SI)： T(特斯拉) \n\n\n第3节：垂直于匀强磁场运动的带电粒子：粒子做匀速圆周运动\n\n\n速度选择器:\n\n\n质谱仪：\n\n\n回旋加速器：\n\n\n\n\n第4-5节：粒子作螺旋线向前运动，轨迹是螺旋线：\n霍耳效应：\n\n\n第6节：\n注意对无线长载流直导线的B的求法。其中μ0 = 4π\n第7节：\n第8节：\n\n\n第9节：一、恒定磁场的高斯定理：\n\n二、安培环路定理：\n","categories":["文化课"],"tags":[]},{"title":"Git学习笔记","url":"https://dicemy.github.io/8520.html","content":"","categories":["技术"],"tags":["学习笔记"]},{"title":"Web复习","url":"https://dicemy.github.io/48416.html","content":"HTML标题类元素：h1，h2，h3，h4，h5，h6p元素：段落文字br元素：段内换行&amp;nbsp：空格pre元素：预留格式hr元素：水平标记线\ndiv 元素属性：idnameheightwidthpadding    内边距margin    外边距borderdiv是块级元素，独占一行，用于页面的分区（相当于容器） \nspan 元素属性：span是行级标签，宽度会根据内容变化，一行内可以并列多个行级标签。\nimg 元素属性：src    图像源文件alt    提示文字widthheightborder    表框\na 元素的常用属性：id    超链接的唯一标识name    给超链接命名href    链接目标的url，可以是一个a标签的name或者id来完成页内跳转格式#namehref = “mailto: …”    电子邮箱target    指定链接的目标窗口，取值有_self, _blank, _parent, _top等title    给链接提示文字rel    规定当前文档与目标文档之间的关系\n列表元素：ul    无序列表ol    有序列表dl    定义列表\n表格常用元素：table    定义表格caption    表格标题th    表格表头tr    行td    表格单元thead    页眉tfoot    页脚colgroup    列的组\ntable 的常用属性：bgcolor    背景色border    边框宽度cellspacing    单元格之间的大小cellpadding    单元格边框和内容之间的大小width    表格宽度heigth    表格高度\ntr 的常用属性：widthheighalign    行的对齐方式（水平）left, right, centervalign    行的对齐方式（垂直）left, right, centerbgcolor    行的底色bordercolor    边框颜色\ntd 的常用属性：widthheighcolspan    向右通栏的栏数rowspan    向下通栏的栏数alignvalignbgcolorbordercolor\naudio 和 video 的常用属性：src    音频或者视频的路径width    video独有height    video独有autoplay    文件是否自动播放controls    文件是否显示控制面板loop    文件循环播放的次数poster    video独有，如果视频播放失败，则展示一副替代的图片preload    是否预加载\n表单元素：form    供用户输入的表单input    定义输入域textarea    定义文本域label    控制的标签select    选择列表option    下拉列表中的选项button    定义一个按钮\nCSS外部样式表内部样式表内嵌样式\n外部样式表的引入：在head区内使用link来引入外部的样式表。\n内部样式表的使用：在head区内使用style type = “text/css” 来进行样式的定义。\n内嵌样式的使用：在body内元素里加入style属性，style属性的内容就是CSS的内嵌样式\n选择器：*    通用选择器.    类选择器#    id选择器E    标签选择器E F    后代选择器    选择E元素的所有后代F元素E &gt; F    子代选择器    选择E元素下所有的子（第一代）元素FE + F    相邻兄弟选择器    选择紧接在E元素后的F元素E ~ F    通用兄弟选择器    选择E元素后面的所有兄弟元素E, F    群组选择器    E和F都被选择:link    链接伪类选择器    定义了超链接的元素    未被访问过的:visited    链接伪类选择器    定义了超链接元素    已被访问过:active    用户行为伪类选择器        元素被激活（鼠标点击不动时超链接的状态）:hover    用户行为伪类选择器        鼠标悬停在元素上:focus    用户行为伪类选择器        获得焦点\n:first-child    匹配父元素的第一个元素:nth-child(n)    匹配父元素的第n个子元素:first-of-type    匹配父元素第一个类型为E的元素E[att]    选择具有属性att的E元素E[att=val]    选择具有属性att并且属性值为val的E元素E[att | = val]    选择属性值是有一个具有val或者以val-开始的属性值。E[att $ = val]    选择具有属性att并且属性值后缀为val的E元素E[att ^ = val]    选择具有属性att并且属性值为以val开头的字符串的E元素\nborder：border-width    边框的宽度border-colorborder-style    设置边框的样式：none(无边框),hidden(隐藏),soild(实线),double(双线框)border-radius    边框圆角提供两个参数，参数之间用/来分割\nbackground:background-color    设置背景颜色background-image    设置背景图像background-position    设置背景图像的起始位置:background-repeat    背景图像是否重复\ntext:text-align    设置文本对齐方式：left, right, centervertical-align    设置文本垂直对齐方式text-indent    设置首行缩进line-height    设置行高text-shadow    产生阴影：text-shadow: color（阴影颜色） x-offset（X轴位移） y-offset（Y轴位移） blur-radius（阴影模糊半径）\n盒子模型：白色边框和内容会显示出来，剩下的灰色的部分都是空白。\npadding    元素边框和内容之间的距离，padding-top等四个margin:    元素周围的空间的距离，margin-top等四个box-shadow    定义元素的盒子阴影\n浮动和定位：float:    将元素进行浮动,脱离文档流    属性有：none, left, rightposition:    定位是指将某个元素放在某个位置上    属性有：static(静态定位，默认值，top等属性无效), relative(相对位置，相对正常的位置), absolute(绝对定位，相对于 static 定位以外的第一个父元素进行定位), fixed(固定定位，相对于window固定)\nJS数据类型NumberString    用单引号和双引号包围BooleanObjectUndefined    未被赋值之前的值Null    没有任何值JS变量区分大小写\nJS内置对象Object    对象String    字符串Date    时间对象Array    数组对象\n如何去创建一个自定义的对象？\n1.通过对象字面量的方式创建对象：var obj = {}2.通过new object的方式创建对象:var obj = new Object()//创建一个空对象var arr = new Array()/创建一个空数组对象3.通过构造函数的形式创建对象：function Person(){};或者：var Person=function(){};4.通过Object.create()创建\nArray常用方法：join()    将数组中的元素通过一个分隔符拼接为一个字符串，默认的分隔符是逗号pop()push()reverse()    翻转\nDate常用方法：getDate()    返回月份的第几天getDay()    返回星期几，0是周日getMonth()    返回月份值，0表示1月getFullYear()    返回四位数的年份getHours()    返回小时getMinutes()getSeconds()getMilliseconds()    返回毫秒值getTime()    返回1970年1月1日至今的毫秒总数getTimezoneOffset()    \nsetDate()    传递参数为月份的第几天setMonth()setFullYear()setHours()setMinutes()setSeconds()setMilliseconds()setTime()\nMath常用方法：E    数学常量e的值LN2    2的自然对数值PI    圆周率的值SQRT2    2的平方根rand()    返回0~1之间的随机数ceil()    对参数向上取整floor()    对参数向下取整\nJS内置事件：鼠标事件：onclick    鼠标单击（在当前区域按下并且在当前区域内抬起）onmouseover    鼠标滑入onmouseout    鼠标滑出onmousedown    鼠标按下（在当前区域内按下）onmouseup        鼠标按下并释放（在当前区域内抬起即可）\n键盘事件：onkeypress    某个键盘上的按键按下并释放onkeydown    某个按键被按下onkeyup\n网页相关事件：onload    页面加载时onunload    页面关闭或者重载时onerror    脚本出现错误时onresize    窗口大小发生改变时onscroll    网页滚动条发生变化时onmove    网页窗口移动时\n表单相关事件：onblur    失去键盘焦点时onfocus    获得键盘焦点时onreset    表单重置时onsubmit    表单提交时\nDOM是一个树形结构，当一个元素被触发时，路径所经过的结点都会收到该事件，这个传播过程的顺序可称为DOM事件流。\n事件动态绑定：JS所有事物都是对象，如果获得对象使用：document.getElemenByID(“ID”)\n事件监听器：addElementListener(event, function, useCapture)参数event表示监听的事件，不加on，比如click，touchstart等。函数可以是外部函数或者匿名函数。useCapture选择true表示捕获，false表示冒泡。\nDOM\n\nDOM是一个树\nDOM方法访问元素节点：getElementById(“”)getElementByName(“”)    通过name属性值来查找getElementByTagName(“”)    通过标签名来查找，返回一个对象集合，返回的顺序是它们在文档中的顺序getElementByClassName(“”)    通过样式名来查找\n创建，插入节点：createElement()    创建元素节点createTextNode()    创建文本节点createAttribute()    创建属性节点appendChild()    把新的子节点添加到指定节点insertBefore()    在指定的节点前面插入新的子节点\n替换，删除节点：removeChild()    删除子节点replaceChild()    替换子节点\n获取，设置属性节点：getAttribute()    获取元素节点的属性setAttribute()    可以新增一个属性或者修改原来的属性节点    \nDOM属性innerHTML    innerHTML可与获取或者修改子节点的HTML结构，可以代替createElement()innerText    innerText可以获取或者修改节点的文本，nodeValue    规定了节点的值，元素的nodeValue是undefined或者Null；文本节点的nodeValue是文本本身；属性节点的nodeValue是属性值。nodeType    返回节点的类型\nDOM操作样式style属性    修改样式使用style.属性名class属性    通过className属性读取或者设置类样式\nBOM\n\nBOM和DOM的关系：DOM中的document对象也是window的子对象使用window对象时可以省略window，例如window.alert()可以略写成alert()。\nwindow对象常用方法prompt()    显示可以输入的对话框confirm()    显示一段消息，以及确认和取消按钮的对话框open()    打开某一个窗口close()    关闭浏览器窗口setInterval()    每隔指定的时间执行代码。clearInterval()    取消setInterval()的设置。setTimeout()    在指定的延迟时间之后来执行代码。clearTimeout()    取消setTimeout()的设置\n错题小记以下句子为正确易错的句子：\n\n静态网页都会显示固定的信息\n\nWEB 就是我们说网页，它是一系列技术的复合总称（包括网站的前台布局、后台程序、美工、数据库开发等），我们称它为网页，HTTP (英文Hypertext transfer protocol的缩写) 中文译为超文本传输协议，DNS （英文Domain Name System的缩写）是域名解析系统。这三个都是网页术语。\n\nWeb标准是由W3C与其他标准化组织共同制定的，不是各大厂商联合制定的。\n\nXHTML是更严谨纯净的HTML版本\n\nHTTP和HTTPS的差异：简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全。\n\nJavaScript可以做很多事情，但最主流的应用是在Web上创建网页特效或验证信息。\n\n标签就是放在“&lt; &gt;”标签符中表示某个功能的编码命令。\n\nHTML5扩展名：.html和.htm\n\n可以调整图像垂直边距的属性是：vspace\n\nHTML5的优势主要体现在兼容、合理、易用三个方面。\n\ncite标签可以创建一个引用，用于对文档引用参考文献的说明，一旦在文档中使用了该标签，被标注的文档内容将以斜体的样式展示在页面中，以区别于段落中的其他字符。\n\n层叠性是指多种CSS样式的叠加。而不是子标签会继承父标签的某些样式。\n\nCSS注释只有一种写法：/* 注释语句 */\n\n如果使用RGB代码的百分比颜色值，取值为0时也不能省略百分号，必须写为0%。\n\n并不是所有的CSS属性都可以继承。下面的属性就不具有继承性：边框属性，如border、border-top、border-right、border-bottom等外边距属性，如margin、margin-top、margin-bottom、margin-left等内边距属性，如padding、padding-top、padding-right、padding-bottom等背景属性，如background、background-image、background-repeat等定位属性，如position、top、right、bottom、left、z-index 等布局属性，如clear、float、clip、display、overflow等元素宽高属性，如width、height\n\nCSS3最突出的优势主要体现在节约成本和提高性能两方面。\n\n临近兄弟选择器使用加号“+”来链接前后两个选择器。\n\n子元素择器主要用来选择某个元素的第一级子元素。\n\nE[att$=value] 属性选择器是指选择名称为E的标签，且该标签定义了att属性，att属性值包含后缀为value的子字符串。\n\n：not选择器：如果对某个结构标签使用样式，但是想排除这个结构元素下面的子结构元素，让子结构元素不使用这个样式，可以使用:not选择器。\n\nRGBA模式用于设置背景与图片的不透明度。\n\npadding属性不允许使用负值。\n\n无序列表是网页中最常用的列表，之所以称为“无序列表”，是因为其各个列表项之间没有顺序级别之分，通常是并列的，并不存在主导从属的关系。\n\n当不设置list-style-position属性时，列表项目符号位于列表文本以外（默认值）。\n\n在HTML语言中，&lt;th&gt;标签用于设置表格的表头。\n\n在&lt;textarea&gt;表单控件中，cols用来定义多行文本输入框每行中的字符数\n\nautocomplete属性用于指定表单是否有自动完成功能，所谓“自动完成”是指将表单控件输入的内容记录下来，当再次输入时，会将输入的历史记录显示在一个下拉列表里，以实现自动完成输入。\n\n“overflow:visible;”：内容不会被修剪，会呈现在元素框之外（默认值）。\n\nz-index属性取值可为正整数、负整数和0\n\n在网页中，常用的命名方式有“驼峰式命名”和“帕斯卡命名”两种。 \n\n在HTML5中嵌入的视频格式主要包括ogg、mpeg4、webm\n\ntransition-duration属性用于定义完成过渡效果需要花费的时间。\nanimation-timing-function用来规定动画的速度曲线。\nanimation-duration属性用于定义整个动画效果完成所需要的时间。\nanimation-name属性用于定义要应用的动画名称。transition-delay的属性值可以为正整数、负整数和0。当设置为负数时，过渡动作会从该时间点开始，之前的动作被截断；设置为正数时，过渡动作会延迟触发。\n\n在CSS3中，transform属性可以实现网页中元素的变形效果。CSS3变形效果是一系列效果的集合，例如平移、缩放、倾斜和旋转。使用transform属性实现的变形效果，无需加载额外文件，可以极大提高网页开发者的工作效率和页面的执行速度。transform属性的基本语法如下：transform：none|transform-functions;在上面的语法格式中，transform属性的默认值为none，适用于行内元素和块元素，表示元素不进行变形。transform-function用于设置变形，可以是一个或多个变形样式，主要包括translate ()、scale()、skew()和rotate()等，具体说明如下： translate()：移动元素对象，即基于X和Y坐标重新定位元素。 scale()：缩放元素对象，可以使任意元素对象尺寸发生变化，取值包括正数、负数和小数。 skew()：倾斜元素对象，取值为一个度数值。 rotate()：旋转元素对象，取值为一个度数值。\n\nanimation属性是一个简写属性，用于在一个属性中设置animation-name、animation-duration、animation-timing-function、animation-delay、animation-iteration-count和animation-direction六个动画属性。其基本语法格式如下：animation: animation-name animation-duration animation-timing-function animation-delay animation-iteration-count animation-direction;在上述语法中，使用animation属性时必须指定animation-name和animation-duration属性，否则动画效果将不会播放。\n\n\n","categories":["文化课"],"tags":[]},{"title":"数据库复习","url":"https://dicemy.github.io/51347.html","content":"知识点：三类经典的数据模型是：1.层次模型，2.网状模型和3.关系模型。\n数据库的保护措施有1.安全性控制，2.完整性控制，3.并发控制和4.数据库恢复等。\n事务的四个性质是：1.原子性，2.一致性，3.隔离性，4.持久性。\n并发控制的主要方法是封锁，封锁有两种类型：即1.排它锁（X锁，写锁），2.共享锁（S锁，读锁）。\n故障恢复的基本手段有：1.数据转储，2.登记日志文件。\n数据库设计的步骤有：1.需求分析，2.概念结构设计，3.逻辑结构设计，4.物理设计，5.数据库实施，6.数据库的运行和维护。\n并发控制带来的三种数据不一致是：1.丢失数据，2.不可重复读，3.读脏数据。\n数据模型的三要素：1.数据结构，2.数据操作和3.数据完整性。数据结构是对数据系统的静态特性的描述，数据操作是对数据库系统的动态特性的描述。\n数据库系统的故障：1.系统故障，2.事务故障，3.介质故障，4.计算机病毒。\n当局部E-R图合成为全局E-R图时，可能出现冲突：1.属性冲突，2.结构冲突，3.命名冲突。\n传统的关系运算：1.交，2.并，3.差，4.笛卡尔积。\n专门的关系运算：1.选择，2.投影，3.连接，4.除。\n基本运算是：1、并，2、差，3、选择，4、投影，5、乘积（笛卡尔积）\n数据库的完整性是指：1.正确性，2.相容性 ， 3.有效性。\n一个关系模式的定义主要包括：1、关系名，2、属性名、3、属性类型、4、属性长度、5、关键字。\n关系数据库中基于数学上两类运算是1、关系代数、2、关系演算。\n数据库是长期存储在计算机内，有1.组织的，2.可共享的数据集合。\n数据库管理系统的主要功能有1.数据定义功能，2.数据库的组织存储和管理，3.数据操纵功能，4.数据库的运行管理和5.数据库的建立及维护等。\nSQL语言具有1、数据定义、2、数据操纵、3、数据控制的作用。\nSQL语言具有两种使用方式，分别为1、交互式SQL和2、嵌入式SQL。\n参照完整性是指在基本表中，外码可以是1、空值或者2、另一个关系主码的有效值。\n数据冗余可能导致的问题有：1、浪费存储空间及修改麻烦，2.潜在的数据不一致性。\n安全性控制的一般方法有：1、用户标识鉴定、2、存取控制、3、审计、4、数据加密。\n存取权限包括两方面的内容：1、要存取的数据对象，2、对数据对象进行操作的类型。\nDBMS存取控制极值主要包括两部分：1、自主存取控制，2、强制存取控制。\n在关系数据库规范化理论中，在执行分解时，必须遵守规范化原则：1、保持原有的依赖关系，和2、无损连接性。\n易错点：数据库在磁盘上的基本组织形式是文件。\n数据库的概念模型独立于具体的机器和DBMS。\n数据库是存储在计算机内有结构的数据的集合。\n在数据库中，产生数据不一致的根本原因是：数据冗余。\n数据库系统的最大特点是：数据的三级模式和二级映像。\n实体与之对应的数据库术语为记录。\n层次模型不能直接表示多对多的关系。\n数据库奠基人E.F从1970年起发表过多篇论文，主要论述的是关系数据模型。\n关系运算中花费时间可能最长的运算是：除\nSQL语言是非过程化语言。\nSQL是结构化查询语言。\n在SQL sever 中删除触发器用 DROP。\n关系规范化理论是设计逻辑结构的指南和工具。\n对于非规范化的模式，经过使属性域变为简单域转变为1NF，将1NF经过消除非主属性对主关键字的部分依赖转变为2NF，将2NF经过消除非主属性对主关键字的传递依赖转变为3NF。 \n数据流程图（DFD）是用于描述结构化方法中需求分析阶段的工具。\n在数据库设计中，把数据需求携程文档，他是各类数据描述的集合，包括数据项，数据结构，数据流，数据存储和数据加工过程等的表述，通常称为数据字典。\n若数据库中质保函成功事务提交的结果，则此数据库就称为处于一致状态。\n数据库恢复是将数据库从错误状态恢复到某一已知正确的状态的功能。\n数据库系统是利用存储在外村上其他地方的冗余数据来重建被破坏的数据库，他主要有两种：1.后援副本，2、日志文件。\n死锁不是并发操作带来的数据不一致性的问题。\n事务是用户定义的一个数据库操作序列。\n简答：试述视图的作用？ \n\n视图能够简化用户的操作。（1 分） \n\n视图使用户能以多种角度看待同一数据。（1 分） \n\n视图对重构数据库提供了一定程度的逻辑独立性。（1 分） \n\n视图能够对机密数据提供安全保护。（1 分） \n\n\n登记日志文件时必须遵循什么原则？登记日志文件时必须遵循两条原则： \n\n登记的次序严格按并发事务执行的时间次序。（1 分） \n\n必须先写日志文件，后写数据库。（2 分） \n\n\n简述系统故障时的数据库恢复策略：\n\n正像扫描日志文件，找出在故障发生前已经提交的事务，将其事务标识记入 REDO队列。同时找出故障发生时尚未完成的事务，将其事务标识记入 UNDO队列。\n对 UNDO队列中的各个事务进行撤销处理。\n对REDO队列中的各个事务进行重做处理。(错一个扣1.5分，全错不得分)\n\n简述等值连接与自然连接的区别和联系：\n连接运算符是“=”的连接运算称为等值连接。它是从关系 R 与 S 的广 义笛卡尔积中选取 A，B 属性值相等的那些元组。自然连接是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是相同的属性组，并且在结果中把重复的属性列去掉。                                           \n说明视图与基本表的区别和联系？ \n视图是从一个或几个基本表导出的表，它与基本表不同，是一个虚表，数据库中只存放视图的定义，而不存放视图对应的数据，这些数据存放在原来的基本表中，当基本表中的数据发生变化，从视图中查询出的数据也就随之改变。视图一经定义就可以像基本表一样被查询、删除，也可以在一个视图之上再定义新的视图，但是对视图的更新操作有限制\n简述事务的特性。 \n事务具有四个特性，即 ACID 特性：\n\n原子性：事务中包括的所有操作要么都做，要么都不做。 \n\n一致性：事务必须使数据库从一个一致性状态变到另一个一致性状态。 \n\n隔离性：一个事务内部的操作及使用的数据对并发的其他事务是隔离的。 \n\n持续性：事务一旦提交，对数据库的改变是永久的。 \n\n\n试述数据、数据库、数据库管理系统、数据库系统的概念。 \n数据：描述事物的符号记录。（1 分）数据库：长期存储在计算机内的、有组织的、可共享的数据集合。（1 分）数据库管理系统：是位于用户与操作系统之间的具有数据定义、数据操纵、数据库的运行管理、数据库的建立和维护功能的一层数据管理软件。（1 分）数据库系统：在计算机系统中引入数据库后的系统，一般由数据库、数据库管理系统(及其开发工具)、应用系统、数据库管理员和用户构成。\n","categories":["文化课"],"tags":["数据库"]},{"title":"kuangbin刷题柱","url":"https://dicemy.github.io/390.html","content":"Dungeon Master（5.23）bfs，细节在于搜索到点之后入队时就进行标记已经搜索到了。不然会反复入队导致超时。\nFind The Multiple（5.25）一个技巧，在dfs中如果不想让递归回到上一层之后继续执行的话，不要把dfs的返回类型设为void，而是设为bool，让多层的dfs返回到上一层就遇到一个if，就保证找到答案之后就会返回，不会寻找到多个值。常常用于有spj的搜索题。\nPrime Path（8.1）水题，素数筛 + bfs。\nShuffle’m Up（8.2）水题，字符串模拟。注意：字符串为空的时候不要进行下标赋值，会出现问题，用s.push_back向空字符串中放置字符，否则会出现下标可以访问字符但是整体字符串为空的情况发生。\nPots（8.2）BFS，寻找最小变换次数即最小步数。比较特殊的是这个需要保存操作的步骤，可以用一个三维vector来保存每一次操作的动作编号，然后在到达状态之后依次输出即可。\nFire Game（8.3）离谱的是FZU挂掉了，没办法评测，样例都过了， 复习了一下如何求联通块的个数和双起点BFS。经验：下次做题前看一下uoj在那个网站提交的标志是不是红色。。。\n","categories":[],"tags":[]},{"title":"刷题打卡","url":"https://dicemy.github.io/18382.html","content":"5.8： 5道。挺麻的，又开始觉得自己是个fw了\n5.15：1道题，被张宇说的网络流刺激到了，又滚来刷题了。\n5.23：1道题，kuangbin的题单质量就是高，把之前的一道题改对了，还是浮躁，张文军教练的话，很有道理。\n\n5.24：1道题，今天晚上有cf的#722的div2的比赛。但是进晚了怕掉分没打，写了一下t1，水体一道。\n5.25：1道题，kuangbin的搜索专题。\n","categories":[],"tags":[]},{"title":"牛客刷题柱","url":"https://dicemy.github.io/58203.html","content":"队列蚯蚓（5.4）https://ac.nowcoder.com/acm/problem/16430\n这道题的解法是维护三个单调队列，由题可知蚯蚓切完的性质仍然满足蚯蚓的长度是依次递减的，由于是按照比例切的，那么切的是相同比例的蚯蚓放到一个队列中，由于靠前切的蚯蚓一定切出来的也是比之后切出来的蚯蚓长，所以当前的最长的蚯蚓只需从这三个队列中找到队头即可。\nCow Line（5.5）https://ac.nowcoder.com/acm/problem/24876\n这道题就是一个简单的双端队列的模拟，题中数据的范围是模拟可以接受的，看出来题考的数据结构是双端队列就行了，维护两边的进队和出队即可。\nTeam Queuehttps://ac.nowcoder.com/acm/problem/50966\n又是一道模拟题，团队队列只需用团队编号作为大队伍的标志，然后再委会每一个团队队列的内部次序即可。用一个queue和一个queue数组和一个map即可，细节还行，难度适中。出现的问题是数组越界了。最后发现标志该团队是否入大队列的bool数组并不是必要的。可以用检查该团队队列是否为空来代替。\n长跑（5.6）https://ac.nowcoder.com/acm/problem/14570\n是道队列bfs，从起点开始搜索，如果当前节点加上maxn可以到达并且钱够的商店就入队，然后如果碰到终点就退出。就是一道朴素的bfs，但是如果看不出来的还是有点迷惑的。\n道路铺设（5.8）https://ac.nowcoder.com/acm/problem/21222\n再次做到NOIP2018提高组的题，感慨万千。隐约记得在考场上发现是前两天做过的原题的兴奋的心情了。当时的我先发现是差分，处理出差分数组之后经过观察是差分数组为正值的所有值的和即为答案，当时并没有经过严谨的证明，隐约感觉正值和负值之间一定会相互抵消。今天重新写到，当时的感觉重新涌上心头。\n其实就是一道水题，并不是优先队列，差分之后将正值加到一块即可。可以进行一个简单的证明，一个数列的差分数组的所有元素的和一定为0，那么想要将这个差分数组的正数变为0，那么每一个正数都要和负数相对应结合。其中一个问题是如果确定进行变化的一对差分中间没有0，其实这也好证明，因为每一个正数会找到最近的一个负数进行中和，那么可以保证在对更远的负数进行中和的时候，比较最近的负数已经进行了中和，级这个比较大的数通过和附近的数进行中和，已经和周围的数的大小基本相同，所以不会出现跨过一个比较小的数然后进行更行的情况发生。第二个问题是，会不会出现前面的正数不能将一个比较大的负数使用完就直接跳到后面的正数了，显然也是不会的，因为这个数列是一个正整数列。\n栈好串（5.7）https://ac.nowcoder.com/acm/problem/21874\n一个栈的水题。\n吐泡泡https://ac.nowcoder.com/acm/problem/15029\n一个栈的应用，水题。\n表达式计算4（5.8）https://ac.nowcoder.com/acm/problem/50999\n栈的经典应用，表达式求值。这是一个中缀表达式求值。维护两个栈，一个栈存数字，一个栈存符号，数字进栈没有什么要求，如果有一个符号要进栈的话，先把比该符号优先级高的在符号栈中的符号都先弹出栈，符号两边的数字进行运算。这样就保证了每一个运算都是优先级高的先运算。模拟的过程会比较繁琐，而且注意栈如果为空的话调用栈的.top()会报错，所以把原来的表达式的最外层加一对括号来保护。\n括号画家https://ac.nowcoder.com/acm/problem/50998\n括号匹配，寻找最长合法括号匹配串。由于如果出现不合法的情况，那么之前的合法的长度就不能加到后面的括号序列上了。所以只需维护一个括号匹配栈即可，如果出现了不合法的情况就将最长串和目前的最长串进行一个更新即可，最后答案中的长度就是最长的合法括号字串的长度。\n并查集奶酪（5.8）https://ac.nowcoder.com/acm/problem/16417\n经典并查集例题，怎么写都能过的无极数据友好的题，只用将两两洞进行测距然后看距离满足，如果满足就直接将两个洞用并查集连在一起。然后看离地下比较近的洞和离上面比较近的洞是否联通即可。这道题应该也可以用其他测联通的方法写出来。\n关押罪犯https://ac.nowcoder.com/acm/problem/16591\n并查集的经典应用，一个非常好的思路是：我们将并查集的f数组进行拓展一下来表示更多的状态，来简化一些比较困难的逻辑表示。我们将f数组拓展一倍，i表示一个监狱i+n表示另一个监狱。我们对于每一对罪犯，都默认将他们装到不同的两个监狱中即a和b+n，a+n和b，然后检查他们在相同的监狱中是否出现冲突。这个做法其实是将一个状态拆成了比较好表示的两个状态。将逻辑上很复杂才能检测的问题变成一些很简单能判断的问题。这种方法叫做建立虚点。\n虚点的建立可以拓展表示一个点的多个状态。\n食物链（5.9）https://ac.nowcoder.com/acm/problem/16884\n这题本质上应该是然用带权的并查集来写，但是有一种比较好写的方法是开虚点。用三倍的n的数组来表示每一个点的三个不同性质，对不同性质之间进行操作，这样就减小了处理复杂问题的难度。\n棋盘问题（5.15）http://poj.org/problem?id=1321\n一道经典的搜索题，用dfs进行搜索，一个控制层数，一个控制放了几个棋子。注意dfs中需要将每一层的情况都列出来。\n","categories":[],"tags":[]},{"title":"html学习笔记","url":"https://dicemy.github.io/50736.html","content":"","categories":[],"tags":[]},{"title":"python语法点杂记","url":"https://dicemy.github.io/26139.html","content":"1234567import表示引入某一个模块。import [... ] as  (...) 表示引入一个 [...] 模块并且重命名为 (...)。from [...] import (...) 表示从[...]模块中引入(...)函数。from [...] import (...) import表示引入某一个模块。import [... ] as  (...) 表示引入一个 [...] 模块并且重命名为 (...)。from [...] import (...) 表示从[...]模块中引入(...)函数。from [...] import (...) as &#123;...&#125;表示从[...]模块中引入(...)函数并且重命名为 &#123;...&#125;。\n\n\n\n","categories":["技术"],"tags":["python"]},{"title":"观影小记","url":"https://dicemy.github.io/56512.html","content":"2021/4/15《卡尔·拉格斐：孤独的时尚大师》\n123456789摘录：博物馆成了一个地方的商店，商店成为了一个地方的博物馆。“我只是想拒绝平庸而已。”感想：法国的文艺记录片，镜头很有冲击力，剪辑感觉很有想法，但是看完这个纪录片之后，并没增加我对卡尔·拉格斐的理解或者认识...像是一个宣传片，又像是一个没有主题和内容的谈话节目。关于卡尔·拉格斐：卡尔·拉格斐（1933年9月10日-摘录：博物馆成了一个地方的商店，商店成为了一个地方的博物馆。“我只是想拒绝平庸而已。”感想：法国的文艺记录片，镜头很有冲击力，剪辑感觉很有想法，但是看完这个纪录片之后，并没增加我对卡尔·拉格斐的理解或者认识...像是一个宣传片，又像是一个没有主题和内容的谈话节目。关于卡尔·拉格斐：卡尔·拉格斐（1933年9月10日-2019年2月19日，Karl Lagerfeld），出生于德国汉堡市，德国著名服装设计师。人们称他为“时装界的凯撒大帝”或是“老佛爷”。说起卡尔·拉格斐，脑海里的第一反映永远是Chanel的艺术总监招牌式的表情，佩戴着墨镜，手拿抓扇、脑后拖着辫子，就是这永恒的墨镜白发长辫的人却占领时尚圈制高点。他永远像“吃饱人参”一样精力旺盛，精通德、英、法、意文，妙语连珠，他情迷传统，又憧憬未来，被传媒封为“当代文艺复兴的代表”。\n\n《绣春刀》\n12感想：适合一个人啃着鸭脖，喝着啤酒和可乐一个人看的电影。本质上和喝着啤酒和可乐看的足球比赛是一个性质，只不过说足球比赛可能更平淡一些，这个电影的节奏会更快那么一丢丢。\n\n","categories":["生活"],"tags":[]},{"title":"数据库SQL语言学习","url":"https://dicemy.github.io/2352.html","content":"Create命令12345678910111213141516171819202122232425262728#创建一个数据库create database [database_name]; #创建一个表create table [table_name] (     [  ] [， [ ] ] … [， ] ); #创建一个视图create view   [(  [，]…)]asselect [查询内容][WITH  CHECK  OPTION]；/*子查询不允许含有 order by 和 distinct 语句。视图只是一个表结构，不储存数据。使用视图和使用表的语法基本相同。WITH CHECK OPTION 语句使得插入操作只能插入满足视图的限制条件的元组。*/#创建登录用户 create user [user_name] identified by [user_password]#创建一个普通用户#创建数据库角色create role &#x27;R1&#x27;;\n\n\nGrant 命令1234567891011121314#授予某个用户权限Grant [,]...[on  ] #对象可以是一个表或者是一个视图，或者是一个数据库to [,]with grant option.#with grant option子句表示该权限可以进行传播，否则不能。#grant权限时可以用all表示所有的权限，或者也可以是select等具体的权限。#在进行授权的时候可以具体到某一个列比如说: Grant update(cname) on ...#to的后面也可是一个角色。#将某个角色授予某个用户Grant &#x27;role_name&#x27; to [user_name];#这样可以批量修改一类用户的权限。\n\nRevoke命令1234567#收回某个用户的权限Revoke [,]...[on]From [,]...#Revoke权限时可以用all表示收回所有的权限，或者也可以是select等具体的权限。#From的后面也可是一个角色。\n\nAlter命令12345678910111213141516#Alter命令是在建好表后修改表结构时使用的语句。alter table [table_name] add [column_name] [数据类型] [完整性约束] #在表中添加一个新列alter table [table_name] add foreign key([column_name]) references [table_name]([column_name])#在表中添加一外键alter table [table_name] modify column [column_name]  [完整性约束]；#修改表中的一列alter table [table_name] drop column [column_name]#删除表中的一列alter table [table_name] drop primary key;#删除表的主键alter table [table_name] drop foreign key [key_name];#删除表的一个外键\n\nDrop命令1234567#Drop命令是删除表或者数据库结构时使用的语句。drop database [database_name]; # 删除一个数据库drop table [table_name]; # 删除一个数据库中的表#注意：如果有外键，不能删除表，应该先删除外键或者先删除外键连接的表。#删除登录用户drop user [user_name]\n\n\nInsert命令12345678910111213141516171819#插入一条元组insert into [table_name]([column_name1], [column_name2] ...)values([column_name1_value], [column_name2_value] ...);#如果table_name后面属性列为空，则默认为定义表时的属性和顺序。#在table_name后面的属性可以自定义顺序。#插入的属性值可以是default, null或者具体的值。#插入子查询的结果insert into [table_name]([column_name1], [column_name2] ...)select ...from ...where ...#插入多条元组insert into [table_name]([column_name1], [column_name2] ...)values([column_name1_value], [column_name2_value] ...),([column_name1_value], [column_name2_value] ...),([column_name1_value], [column_name2_value] ...),... ;\n\nUpdate命令12345#带子查询的修改语句（修改满足条件的元组）update [table_name] set [column_name1] = [column_name1_value]，[column_name2] = [column_name2_value]，where [column_name] = [column_name_value]#在修改值时注意实体完整性和参照完整性。#主码不允许修改，用户定义的完整性，NOT NULL约束，UNIQUE约束，值域约束\n\nSelect命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#一个查询语句的基本结构select [all/distinct]  , ,  ... from , , ...where group by \thaving order by  [asc/desc]\tlimit (num)/*选择表中的若干列*/#如果选中所有的属性列那么用*来表示#DISTINCT关键词消除取值重复的行，如果没有指定，则缺省为ALL #如果要将属性列更名的话在需要更名的列后面加上 as 新名字#在查询语句中还可以自定义表名，方法为 from [table_name] as [new_name]#在定义别名的时候可以省略 as ，但是不建议。#目标列表达式可以为：/*算术表达式\t2016 - Sage字符串常量\t&#x27;出生年份：&#x27;函数\tyear(curdate()) //表示当前的年份列别名 sno as 学号*//*常用的查询条件:比较运算符：=，>，=，<=，!=，<>，!>，!<；确定范围：\tBETWEEN  AND ，\tNOT BETWEEN  AND 确定集合:\tIN(...)，\tNOT IN(...)字符匹配：\tLIKE &#x27;&#x27;，\tNOT LIKE &#x27;&#x27;通配符：\t% 任意长度的字符\t_ 一个长度的字符\t/ 将后面紧跟的一个符号转义成正常符号空值：\tIS NULL，\tIS NOT NULL多重条件（逻辑运算）:\tAND，OR，NOT\t\t可以用括号改变优先级*//*ORDER BY子句*/#可以按照一个或者多个属性进行排序#升序：ASC；降序：DESC；缺省值为升序#当排序列含空值时#ASC：排序列为空值的元组最后显示#DESC：排序列为空值的元组最先显示 #e.g.\tORDER BY Grade DESC；#e.g.\tORDER BY Sdept，Sage DESC； #limit后面跟的数字为输出表中的前几行。/*自然连接*/SELECT  Student.*，SC.*FROM    Student，SCWHERE   Student.Sno = SC.Sno；#将student和sc表将sno相同的元组自然连接然后输出/*聚集函数*/#聚集函数：/*计数\tCOUNT（[ DISTINCT | ALL ] *）\tCOUNT（[ DISTINCT | ALL ] ）//这两个值在all条件下是相等的计算总和\tSUM（[ DISTINCT | ALL ] ）\t计算平均值\tAVG（[ DISTINCT | ALL ] ）最大最小值\tMAX（[ DISTINCT | ALL ] ）\tMIN（[ DISTINCT | ALL ] ）*//*GROUP BY子句*/#细化聚集函数的作用对象/* 未对查询结果分组，聚集函数将作用于整个查询结果 对查询结果分组后，聚集函数将分别作用于每个组  作用对象是查询的中间结果表 按指定的一列或多列值分组，值相等的为一组*//*Having子句*/#Having短语作用于组，从中选择满足条件的组#Where子句作用于基表或者视图，从中选择满足条件的元组/*ORDER BY子句*/#将结果进行排序之后再输出/*ASC 升序（小的在前面）DESC 降序（大的在前面）缺省为升序order by 后面可以跟多个列名，按照顺序进行排序。*/#当排序存在空值时/*ASC 空值的元组最后显示DESC 空值的元组最先显示*//*limit子句*/#只输出排序结果中的前num个元组。#limit 3 的意思是输出前三行，limit 1,3 的意思是输出2道4行#表中的元组的序号是从0开始的/*Percent子句（！该知识点没有细讲，考试不考）*//*select top  percent ...from ...where ...表示输出前半分之n的数据，如果结果不够一条的话会向上取整为一条。*//*into子句（！该知识点没有细讲，考试不考）*//*select * into [table_name] from ...where ...表示将查询结果保存到table_name的表中。*/\n\nSelect查询进阶12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/*连接查询*/#将两个表进行自然连接select *from A, bwhere A.a = B.a;#将三个表进行自然连接select *from A, B, Cwhere A.a = B.a and A.a = C.a;#将一个表进行自身连接select A.a, A.pa, B.pafrom table1 as A, table1 as Bwhere A.pa = B.a;/*[例35]查询每一门课的间接先修课（即先修课的先修课），输出：课程号、先修课的课程号、先修课的先修课的课程号。*//*SELECT  FIRST.Cno, FIRST.Cpno, SECOND.CpnoFROM  Course As FIRST，Course As SECONDWHERE FIRST.Cpno = SECOND.Cno；*/#两个表用inner join来写自然连接select *from A inner join B on (A.a = A.b)where ...#两个表用left outer join来写左外连接select *from A left outer join B on(A.a = B.a)where ...#两个表用right outer join来写右外连接select *from A right outer join B on(A.a = B.a)where ...#嵌套查询/*将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询*/#不相关子查询select *from A where a in (    select a    from B    where ...);#相关子查询select *from A where a in (    select a    from B    where A.b = B.b and ... );/*可以进行多层嵌套，当可以确定内层返回为单值的话，in可以用=或者等代替。*/#带有ANY和ALL谓词的子查询select *from Awhere a >= ANY(    select a    from B    where ...);/*ANY表示查询结果中的某个值，ALL表示查询结果中的所有值*/#带有EXISTS谓词的子查询/*存在谓词谓词的查询不返回任何数据，只产生逻辑真值或者逻辑假值，若内层查询为空则返回假，若内层查询为非空则返回为真。EXISTS内层只要有结果，外层对应的记录就输出。NOT EXISTS内层只要没有结果，外层就被输出。*/select *from Awhere exists (    select *    from B    where ...)#集合查询：交并差查询#Union, Intersect, Except。/**/\n\nDelete命令12345#带查询的删除（删除满足条件的元组）delete from [table_name]where ...#where中的语句格式和select的where一样。\n\n其他常用命令1234567show databases;select database();use [database_name];DESC [table_name];#查看该表的结构select user();#查看当前用户select * from mysql.user #查看所有用户#用户授权\n\n数据类型123456intsmallintchar([num])varchar([num])#变长字符串dateenum(a, b, ...) #枚举类型，值只能是枚举集合中的一个元素\n\n常用约束条件123456789101112131415161718default [val] # 默认值unique # 唯一性约束not null # 非空值约束primary key([column_name],...) # 主码约束foreign key([column_name]) references [table_name]([column_name]) # 外键约束chekc([条件])\t# 用户定义auto_increment # 序号自动加一constraint [constraint_name]  # 为后面的限制条件起一个名字on delete \tno action\tcascade\tset null#在外键被参照的元组的属性进行删除时进行参照的元组的属性值的变化情况on update \tno action\tcascade \tset null#针对外键被参照的元组的属性进行更新值时进行参照的元组的属性值的变化情况\n\n常用列函数12345Count()\t#统计某一列的元组数量，某一列的Count运算结果和Count(*)的结果是相等的。Sum()\tAvg()Max()Min()","categories":["文化课"],"tags":["数据库"]},{"title":"搜索","url":"https://dicemy.github.io/50622.html","content":"树与图邻接表用head数组为表头，使用ver和edge数组分别存储边的终点和权值，用next数组模拟链表指针。\n在一个图中添加一个从x到y边的权值为z的有向边：\n123456int head[maxn &lt;&lt; 2], ver[maxn], edge[maxn], next[maxn &lt;&lt; 2];int tot;//tot表示边的编号 inline void adde(int x, int y, int z) &#123;\tver[++tot] = y;\tnext[tot] = head[x]; //这句话表示原来x指向的所有边都挂到tot这条新的边的后面。 \thead[x] = tot;\tedge[tot] = z;int head[maxn &lt;&lt; 2], ver[maxn], edge[maxn], next[maxn &lt;&lt; 2];int tot;//tot表示边的编号 inline void adde(int x, int y, int z) &#123;\tver[++tot] = y;\tnext[tot] = head[x]; //这句话表示原来x指向的所有边都挂到tot这条新的边的后面。 \thead[x] = tot;\tedge[tot] = z;//这句话表示在x原来指向的tot边的前面插入了新来的这个边。 &#125;\n图从x访问所有x相连的点。\n12345void serch() &#123;\tfor (int i = head[x]; i; i = next[i]) &#123;\t\tvoid serch() &#123;\tfor (int i = head[x]; i; i = next[i]) &#123;\t\t//从x的最后输入的那条边开始，便利所有x为出发点的边。next数组是为指出x出发的每一条边之间的关系。\t&#125;&#125;\n图从x的一个深度优先遍历。\n12345678910bool v[maxn];void dfs(int x) &#123;\tv[x] = 1;\tfor (int i=head[x]; i; i = next[i]) &#123;\t\tint y = ver[i];\t\tif (v[y])\tcontinue;\t\tdfs(y);\t&#125;&#125;bool v[maxn];void dfs(int x) &#123;\tv[x] = 1;\tfor (int i=head[x]; i; i = next[i]) &#123;\t\tint y = ver[i];\t\tif (v[y])\tcontinue;\t\tdfs(y);\t&#125;&#125;//这个搜索的时间复杂度是O(n+m)。\n\n树的dfs序。\n12345678910void int(x) &#123;\ta[++m] = x;\tv[x] = 1;\tfor (int i = head[x]; i; i = next[i]) &#123;\t\tint y = ver[i];\t\tif(v[y])\tcontinue;\t\tvoid int(x) &#123;\ta[++m] = x;\tv[x] = 1;\tfor (int i = head[x]; i; i = next[i]) &#123;\t\tint y = ver[i];\t\tif(v[y])\tcontinue;\t\tdfs(y);\t&#125;\ta[++m] = x;&#125;\n\n树的深度。\n1234567891011int d[maxn];void dfs(int x) &#123;\tv[x] = 1;\tfor(int i = head[x]; i; i = next[i]) &#123;\t\tint y = ver[i];\t\tif(v[y])\tcontinue;\t\td[y] = d[x] + 1;\t\tdfs(y);\t&#125;&#125;int d[maxn];void dfs(int x) &#123;\tv[x] = 1;\tfor(int i = head[x]; i; i = next[i]) &#123;\t\tint y = ver[i];\t\tif(v[y])\tcontinue;\t\td[y] = d[x] + 1;\t\tdfs(y);\t&#125;&#125;//d[i]中储存的是编号为i的节点从根节点往下的深度。\n\n树的重心。\n定义：设max_part(x)表示再删除节点x后产生的子树中，最大的一颗的大小。是max_part函数取到最小值的节点p就成为整棵树的重心。下面的代码我们可以统计出size数组，并且找到这棵树的重心。\n1234567891011121314151617int size[maxn];void dfs(int x) &#123;\tv[x] = 1; size[x] = 1;\tint max_part = 0;//删掉子树x之后分成的若干个子树中最大的那个的大小 \tfor (int i=head[x];i;i=next[i]) &#123;\t\tint y = ver[i];\t\tif (v[y])\tcontinue;\t\tdfs(y);\t\tsize[x] += size[y];//从子节点向上更新 \t\tmax_part = max(max_part, size[y]);//x的子节点中最大的那个节点的size \t&#125;\tmax_part = max(max_part, n - size[x]);//现在max_part中储存的是删掉x之后形成的若干个子树中最大的那个大小 \tif (max_part &lt; ans) &#123;\t\tans = max_part;\t\tpos = x;int size[maxn];void dfs(int x) &#123;\tv[x] = 1; size[x] = 1;\tint max_part = 0;//删掉子树x之后分成的若干个子树中最大的那个的大小 \tfor (int i=head[x];i;i=next[i]) &#123;\t\tint y = ver[i];\t\tif (v[y])\tcontinue;\t\tdfs(y);\t\tsize[x] += size[y];//从子节点向上更新 \t\tmax_part = max(max_part, size[y]);//x的子节点中最大的那个节点的size \t&#125;\tmax_part = max(max_part, n - size[x]);//现在max_part中储存的是删掉x之后形成的若干个子树中最大的那个大小 \tif (max_part &lt; ans) &#123;\t\tans = max_part;\t\tpos = x;//pos中储存的就是这个树的重心的节点号。\t&#125; &#125; \n\n图的连通块的划分\n1234567891011121314int cnt;void dfs(int x) &#123;\tv[x] = cnt;\tfor (int i=head[x];i;i=next[i]) &#123;\t\tint y = ver[i];\t\tif (v[y])\tcontinue;\t\tdfs(y);\t&#125;&#125;for (int i=1;i&lt;=n;++i) &#123;\tif(v[i]) continue;\tcnt++;\tdfs(i);&#125;int cnt;void dfs(int x) &#123;\tv[x] = cnt;\tfor (int i=head[x];i;i=next[i]) &#123;\t\tint y = ver[i];\t\tif (v[y])\tcontinue;\t\tdfs(y);\t&#125;&#125;for (int i=1;i&lt;=n;++i) &#123;\tif(v[i]) continue;\tcnt++;\tdfs(i);&#125;//cnt值相同的节点在同一个连通块中，cnt值表示连通块的个数。\n\n图的广度优先遍历按照层级进行遍历。\n1234567891011121314void bfs() &#123;\tmemset(d, 0, sizeof(d));//d中存储的是每一个节点的深度。\tqueue&lt;int&gt; q;\tq.push(1);d[1] = 1;\twhile(q.size()) &#123;\t\tint x = q.front();\tq.pop();\t\tfor (int i=head[x];i;i=next[i]) &#123;\t\t\tint y = ver[i];\t\t\tif (d[y]) continue;\t\t\td[y] = d[x] + 1;\t\t\tq.void bfs() &#123;\tmemset(d, 0, sizeof(d));//d中存储的是每一个节点的深度。\tqueue&lt;int&gt; q;\tq.push(1);d[1] = 1;\twhile(q.size()) &#123;\t\tint x = q.front();\tq.pop();\t\tfor (int i=head[x];i;i=next[i]) &#123;\t\t\tint y = ver[i];\t\t\tif (d[y]) continue;\t\t\td[y] = d[x] + 1;\t\t\tq.push(y);\t\t&#125; \t&#125;&#125;\n\n拓扑排序这个算法可以判断是否存在环：如果cnt和n不相等的话，那么存在环，因为环中的每一个点的入度都不可能为0。\n12345678910111213141516171819202122232425262728293031int deg[maxn];void add(int x, int y, int z) &#123;\tver[++tot] = y;\tnext[tot] = head[x];\thead[x] = tot;\tedge[tot] = z;\tdeg[y]++;&#125;void topsort() &#123;\tqueue&lt;int&gt; q;\tfor (int i=1;i&lt;=n;++i)\t\tif (deg[i] == 0)\tq.push(i);//如果点的入度为0那么将这个点入队。\twhile(q.size()) &#123;\t\tint x = q.front(); \tq.pop();\t\ta[++cnt] = x;//将入度为0的那个点输出。\t\tfor (int i=head[x];i;i=next[i]) &#123;\t\t\tint y = ver[i];\t\t\tif (--deg[y] == 0)\tq.push(y);\t\t&#125;\t&#125;&#125;int main() &#123;\tcin &gt;&gt; n &gt;&gt; m;\tfor (int i=1;i&lt;=m;++i) &#123;\t\tint x, y;\t\tcin &gt;&gt; x &gt;&gt; y;\t\tadde(x, y, 0);\t&#125;\ttopsort();\tfor (int i=1;i&lt;=cnt;++i) &#123;\t\tcout &lt;&lt; a[i] &lt;&lt; int deg[maxn];void add(int x, int y, int z) &#123;\tver[++tot] = y;\tnext[tot] = head[x];\thead[x] = tot;\tedge[tot] = z;\tdeg[y]++;&#125;void topsort() &#123;\tqueue&lt;int&gt; q;\tfor (int i=1;i&lt;=n;++i)\t\tif (deg[i] == 0)\tq.push(i);//如果点的入度为0那么将这个点入队。\twhile(q.size()) &#123;\t\tint x = q.front(); \tq.pop();\t\ta[++cnt] = x;//将入度为0的那个点输出。\t\tfor (int i=head[x];i;i=next[i]) &#123;\t\t\tint y = ver[i];\t\t\tif (--deg[y] == 0)\tq.push(y);\t\t&#125;\t&#125;&#125;int main() &#123;\tcin &gt;&gt; n &gt;&gt; m;\tfor (int i=1;i&lt;=m;++i) &#123;\t\tint x, y;\t\tcin &gt;&gt; x &gt;&gt; y;\t\tadde(x, y, 0);\t&#125;\ttopsort();\tfor (int i=1;i&lt;=cnt;++i) &#123;\t\tcout &lt;&lt; a[i] &lt;&lt; &#x27; &#x27;;\t&#125;&#125;\n\n","categories":["编程"],"tags":["搜索"]},{"title":"郑州轻工工业20级新生赛","url":"https://dicemy.github.io/29692.html","content":"今天是3月14号。\n分数：10道题，A了6道题。\n\n\n今天的题还算比较友好，因为是郑州轻工工业的新生选拔赛，所以题目都比较基础。算是第一次比较正式的完整的参加了一次ACM赛制。感受还是很深的。\n首先我这一次的比赛开题顺序是有问题的…. 可以看到榜的记录上我第一道AC是在30分钟左右的时候。本来我对于这套题的认识出现了一点偏差，我本来以为这是一套巨难无比的刷我们威风的一套题。所以拿到题之后，看了前3道题之后觉得整体难度挺高的。就误认为a题就是签到题了。（因为其实a题的思路真的挺直接的。）于是我上来就直接开始莽a题了。但是结果其实很悲惨，由于我菜的一批的代码能力。让我没有很顺利的A掉a题。当我第一遍调完a题之后，时间已经来到了30分钟。心情十分郁闷的我看了眼榜单，发现好像签到题在后面，看完题就知道这场名次一定不太好了。于是赶紧过掉了几道签到题。当我跟随榜单的脚步把几道比较简单的题A掉之后。我的名次就逐渐跟上了第一部队。由于这场比赛允许使用纸质资料，所以这场比赛也不完全是由我独立完成的，一道二位前缀和的题我看了书中的代码。所以这也反映出我的知识点掌握能力还处于看到想到思路但是没法很好实现或者实现细节掌握并不是十分熟练的阶段。这是一个现阶段很大的问题。\n列一下这次比赛出现问题的知识点：\n\n博弈论\n二位前缀和（不熟练）\n\n（这是一个赛后总结帖，补题不在这个帖子上）\n列一下这次比赛出现的比赛技巧的问题：\n\n没有使用好acm排名榜单的作用。（跟着大佬做题，大佬开题跟着做就行了）\n\n没有完全理解acm排名的规则（先过水题，这样总时间会少一点。而不是上来无脑肝大题）\n\n\n写一下最近这段时间的计划：\n要开始拾起来之前的算法了，可以看到高中剩下来的老本基本上已经快吃完了，高中是竞赛队员的优势已经不是十分明显了。要考虑如何利用高中时的一些学习思路或者学习习惯来制造现阶段的继续领先了，可以看到20级中有一些学习势头很猛的学生，想要保持持续的领先需要开始真正的努力了。\n高中的经验告诉我，可以按照算法竞赛的知识树的顺序进行学习，而且由于大部分的知识其实已经学习过一遍，所以记忆中是有对这些知识点难易程度的排序的。可以知道哪样的学习安排更加适合我。\n同时，高中的经验告诉我，要有学长或者自己组专项题组进行专门的强化训练，由于高中阶段的算法竞赛是进行停课集训，所以刷题是在大段的时间中进行的，那样的刷题是连续的，对于知识点的理解也有利于加强。但是在大学首先没有了打断整块的时间进行算法训练，而且也没有了聚在一起的机房的队友可以有一个很好的氛围来督促自己学习算法。集中学习的要素由高中的集中起来，变成了大学的分散来到每一天的零碎时间中。这是对时间安排的更进一步的要求。\n我想起来了我在高三时在当时机房一个已经去西安电子科技大学的很厉害的学长，他的id我记得是cdcq。他在高中阶段算法竞赛十分的优秀，拿到了NOI的全国赛铜牌，在高三时放下了竞赛，拾起了文化课。最终去到了西安电子科技大学。在他入学后依然保持着博客的更新，但是我当时十分好奇，在高中阶段十分厉害，常常做并且出省选题的他为什么突然开始写起了基础题，开始写最最基本的板子。在当时的我认为那些板子是我都能看懂的题，这和我对他经常写一些十分复杂的题的印象产生了极大的差异，而且这样的博文持续了很长一段时间，我当时心里想：太可惜了，这么强的一个选手，竟然废掉了。直到现在，我才真正的明白，这是一种什么样的感受。算法竞赛，作为一种竞赛，需要保持长久持续的训练。一旦有一段时间的训练空白期，那将是致命的。他将会毁掉一个职业选手，他可能还存在着操作的意识，但是由于长时间的没有训练，他将不能完成最基本的东西。我觉得职业的体育选手或者电子竞技选手可以是相通的道理。https://www.cnblogs.com/cdcq/这是他的博客，有空我再看看，想一下如何度过这个时期。这将关系我如何更好的走下去。\n这其实也在提醒我，把自己当成一个普通的大一竞赛学生，不要有特殊的心理。这种心理会导致眼高手低。会导致不能很好的进步。这是一个很大的阻碍。不要再有优越的心理了，新生的水平其实也已经达到一个水平了，不要到最后自己泯然众人矣。静下心来学习东西吧。\n克服自己的心理障碍，现在总有一种感觉，觉得好像学这些已经学习过的东西没有什么意思。但是这部分东西已经忘记，复杂的东西由于这不牢的基础导致并写不了。这是一个恶性循环，而解决这个循环的方法就是沉下来开始学习东西，把那些已经学过的东西再复习一遍，以至于可以熟练掌握。而不是在眼高手低的飘。\n这就是这场比赛的总结，所思所想。希望的最后结果要不负我最初的选择吧。\n","categories":["编程"],"tags":["赛后总结"]},{"title":"20级训练赛(一)补题","url":"https://dicemy.github.io/36993.html","content":"A [NOIP1999 普及组] 导弹拦截题目描述某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。\n输入导弹依次飞来的高度（雷达给出的高度数据是≤50000的正整数），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。\n输入格式11行，若干个整数（个数≤100000）\n输出格式22行，每行一个整数，第一个数字表示这套系统最多能拦截多少导弹，第二个数字表示如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。\n输入输出样例输入 #1\n1389 207 155 300 299 170 158 389 207 155 300 299 170 158 65\n\n输出 #1\n1262\n\n说明/提示为了让大家更好地测试n方算法，本题开启spj，n方100分，nlogn200分\n每点两问，按问给分\n思路","categories":["编程"],"tags":["赛后总结","DP"]},{"title":"2021牛客寒假算法基础集训营3","url":"https://dicemy.github.io/50724.html","content":"J 加法和乘法链接：https://ac.nowcoder.com/acm/contest/9983/J来源：牛客网\n题目描述有一天牛牛和牛妹在做游戏，规则如下： 桌面上摆着n张纸牌，每张纸牌上写着一个正整数，由牛牛先手轮流执行以下操作： 1.如果桌面上只剩一张纸牌，游戏结束，这张纸牌上的数字如果是奇数则牛牛胜利，反之牛妹胜利。 2.当前行动玩家选择两张纸牌，设上面的数字分别为X,Y，接下来玩家从加法和乘法中选择一个并应用到这两个数字上，得到结果为Z，接下来将选择的两张纸牌丢弃，并拿一张新的纸牌放到桌面上，在上面写上Z。 假设双方均以最优策略行动，最后谁会赢？\n输入描述:1234第一行一个正整数n，代表开始的纸牌数。第二行n个空格分隔的正整数ai代表开始纸牌上的数字。1≤n≤10^61≤ai≤10^第一行一个正整数n，代表开始的纸牌数。第二行n个空格分隔的正整数ai代表开始纸牌上的数字。1≤n≤10^61≤ai≤10^9\n\n输出描述:1如果牛牛能赢，输出NiuNiu，否则输出NiuMei。\n\n示例1:输入\n123233 2333 3233 2333 23333\n\n输出\n1NiuMei\n\n示例2:输入\n1241 1 1 41 1 1 1\n\n输出\n1NiuNiu\n\n思路这道题只要在纸上进行演算一下即可，我们将两张牌的情况都列出来，可以发现，如果两张牌都是偶数的话，无论是加法还是乘法得到的都是偶数。剩下的两种情况下，加法和乘法可以一个得到偶数一个得到奇数。由此我们可以推出如果最后一次是牛妹进行操作的话，那么牛妹必胜，如果是牛牛的话，只要在最后一次不遇上两个偶数的情况就行。那么牛牛每一次的操作就是为了消除偶数，牛妹的操作就是为了造偶数。这就是两人的最优策略。\n那么，游戏的过程就变成了牛牛消一个偶数，牛妹产生一个偶数，直到最后一次判断是否有两个偶数即可。\n代码：1234567891011121314151617#include&lt;bits/stdc++.h&gt; using namespace std;long long n, a, cnt;int main() &#123;\tcin &gt;&gt; n;\tfor (int i=1;i&lt;=n;++i) &#123;\t\tcin &gt;&gt; a;\t\tif (a % 2 == 0) cnt ++;\t&#125;\tif (n == 1)\tcout &lt;&lt; (cnt == 0 ? &quot;NiuNiu&quot; : &quot;NiuMei&quot;); \telse &#123;\t\tif (cnt &gt; 1 || n % 2 == 1)\t\t\tcout &lt;&lt; &quot;NiuMei&quot;;\t\telse cout &lt;&lt; &quot;NiuNiu&quot;;\t&#125;\treturn #include&lt;bits/stdc++.h&gt; using namespace std;long long n, a, cnt;int main() &#123;\tcin &gt;&gt; n;\tfor (int i=1;i&lt;=n;++i) &#123;\t\tcin &gt;&gt; a;\t\tif (a % 2 == 0) cnt ++;\t&#125;\tif (n == 1)\tcout &lt;&lt; (cnt == 0 ? &quot;NiuNiu&quot; : &quot;NiuMei&quot;); \telse &#123;\t\tif (cnt &gt; 1 || n % 2 == 1)\t\t\tcout &lt;&lt; &quot;NiuMei&quot;;\t\telse cout &lt;&lt; &quot;NiuNiu&quot;;\t&#125;\treturn 0;&#125;","categories":["编程"],"tags":["赛后总结"]},{"title":"Linux系统操作学习","url":"https://dicemy.github.io/11830.html","content":"图形模式与文字模式的切换方式Linux预设提供了六个命令窗口终端机让我们来登录。\n默认我们登录的就是第一个窗口，也就是tty1，这个六个窗口分别为tty1,tty2 … tty6，你可以按下Ctrl + Alt + F1 ~ F6 来切换它们。\n如果你安装了图形界面，默认情况下是进入图形界面的，此时你就可以按Ctrl + Alt + F1 ~ F6来进入其中一个命令窗口界面。\n当你进入命令窗口界面后再返回图形界面只要按下Ctrl + Alt + F7 就回来了。\nLinux 关机在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。\n正确的关机流程为：sync &gt; shutdown &gt; reboot &gt; halt\n关机指令为：shutdown ，你可以man shutdown 来看一下帮助文档。\n例如你可以运行如下命令关机：\n12345678910111213141516171819sync 将数据由内存同步到硬盘中。shutdown 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：shutdown –h 10 ‘This server will shutdown after 10 mins’ 这个命令告诉大家，计算机将在10分钟后关机，并且会显示在登陆用户的当前屏幕中。shutdown –h now 立马关机shutdown –h 20:25 系统会在今天20:25关机shutdown –h +10 十分钟后关机shutdown –r now 系统立马重启shutdown –r +10 系统十分钟后重启reboot 就是重启，等同于 shutdown –r nowhalt 关闭系统，等同于sync 将数据由内存同步到硬盘中。shutdown 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：shutdown –h 10 ‘This server will shutdown after 10 mins’ 这个命令告诉大家，计算机将在10分钟后关机，并且会显示在登陆用户的当前屏幕中。shutdown –h now 立马关机shutdown –h 20:25 系统会在今天20:25关机shutdown –h +10 十分钟后关机shutdown –r now 系统立马重启shutdown –r +10 系统十分钟后重启reboot 就是重启，等同于 shutdown –r nowhalt 关闭系统，等同于shutdown –h now 和 poweroff\n\n最后总结一下，不管是重启系统还是关闭系统，首先要运行 sync 命令，把内存中的数据写到磁盘中。\n关机的命令有 shutdown –h now halt poweroff 和 init 0 , 重启系统的命令有 shutdown –r now reboot init 6。\n处理目录的常用命令接下来我们就来看几个常见的处理目录的命令吧：\n\nls（英文全拼：list files）: 列出目录及文件名\ncd（英文全拼：change directory）：切换目录\npwd（英文全拼：print work directory）：显示目前的目录\nmkdir（英文全拼：make directory）：创建一个新的目录\nrmdir（英文全拼：remove directory）：删除一个空的目录\ncp（英文全拼：copy file）: 复制文件或目录\nrm（英文全拼：remove）: 删除文件或目录\nmv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称\n\n你可以使用 man [命令] 来查看各个命令的使用文档，如 ：man cp。\nls (列出目录)在Linux系统当中， ls 命令可能是最常被运行的。\n语法：\n123[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称[root@www ~]# ls [--color=&#123;never,auto,always&#125;] 目录名称[root@www ~]# [root@www ~]# ls [-aAdfFhilnrRSt] 目录名称[root@www ~]# ls [--color=&#123;never,auto,always&#125;] 目录名称[root@www ~]# ls [--full-time] 目录名称\n\n选项与参数：\n\n-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)\n-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)\n-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)\n\n将家目录下的所有文件列出来(含属性与隐藏档)\n1[root@www ~][root@www ~]# ls -al ~\n\ncd (切换目录)cd是Change Directory的缩写，这是用来变换工作目录的命令。\n语法：\n123456789101112131415 cd [相对路径或绝对路径]#使用 mkdir 命令创建 runoob 目录[root@www ~]# mkdir runoob#使用绝对路径切换到 runoob 目录[root@www ~]# cd /root/runoob/#使用相对路径切换到 runoob 目录[root@www ~]# cd ./runoob/# 表示回到自己的家目录，亦即是 /root 这个目录[root@www runoob]# cd ~# 表示去到目前的上一级目录，亦即是 /root 的上一级目录的意思；[root@www ~] cd [相对路径或绝对路径]#使用 mkdir 命令创建 runoob 目录[root@www ~]# mkdir runoob#使用绝对路径切换到 runoob 目录[root@www ~]# cd /root/runoob/#使用相对路径切换到 runoob 目录[root@www ~]# cd ./runoob/# 表示回到自己的家目录，亦即是 /root 这个目录[root@www runoob]# cd ~# 表示去到目前的上一级目录，亦即是 /root 的上一级目录的意思；[root@www ~]# cd ..\n\npwd (显示目前所在的目录)pwd 是 Print Working Directory 的缩写，也就是显示目前所在目录的命令。\n1[root@www ~][root@www ~]# pwd [-P]\n\n选项与参数：\n\n-P ：显示出确实的路径，而非使用连结 (link) 路径。\n\n实例：单纯显示出目前的工作目录：\n12[root@www ~][root@www ~]# pwd/root   <== 显示出目录啦～\n\n实例显示出实际的工作目录，而非连结档本身的目录名而已。\n123456789[root@www ~]# cd /var/mail   &lt;==注意，/var/mail是一个连结档[root@www mail]# pwd/var/mail         &lt;==列出目前的工作目录[root@www mail]# pwd -P/var/spool/mail   &lt;==怎么回事？有没有加 -P 差很多～[root@www mail]# ls -ld /var/maillrwxrwxrwx 1 root root 10 Sep  4 17:54 /var/mail -&gt; spool/mail# 看到这里应该知道为啥了吧？因为 /var/mail 是连结档，连结到 [root@www ~]# cd /var/mail   &lt;==注意，/var/mail是一个连结档[root@www mail]# pwd/var/mail         &lt;==列出目前的工作目录[root@www mail]# pwd -P/var/spool/mail   &lt;==怎么回事？有没有加 -P 差很多～[root@www mail]# ls -ld /var/maillrwxrwxrwx 1 root root 10 Sep  4 17:54 /var/mail -&gt; spool/mail# 看到这里应该知道为啥了吧？因为 /var/mail 是连结档，连结到 /var/spool/mail # 所以，加上 pwd -P 的选项后，会不以连结档的数据显示，而是显示正确的完整路径啊！\n\nmkdir (创建新目录)如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。\n语法：\n1mkdir [-mp] 目录名称\n\n选项与参数：\n\n-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～\n-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！\n\n实例：请到/tmp底下尝试创建数个新目录看看：\n123456[root@www ~]# cd /tmp[root@www tmp]# mkdir test    &lt;==创建一名为 test 的新目录[root@www tmp]# mkdir test1/test2/test3/test4mkdir: cannot create directory `test1/test2/test3/test4&#x27;: No such file or directory       &lt;== 没办法直接创建此目录啊！[root@www tmp]# [root@www ~]# cd /tmp[root@www tmp]# mkdir test    &lt;==创建一名为 test 的新目录[root@www tmp]# mkdir test1/test2/test3/test4mkdir: cannot create directory `test1/test2/test3/test4&#x27;: No such file or directory       &lt;== 没办法直接创建此目录啊！[root@www tmp]# mkdir -p test1/test2/test3/test4\n\n加了这个 -p 的选项，可以自行帮你创建多层目录！\n实例：创建权限为 rwx–x–x 的目录。\n12345[root@www tmp]# mkdir -m 711 test2[root@www tmp]# ls -ldrwxr-xr-x  3 root  root 4096 Jul 18 12:50 testdrwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1drwx--x--x  2 root  root 4096 Jul[root@www tmp]# mkdir -m 711 test2[root@www tmp]# ls -ldrwxr-xr-x  3 root  root 4096 Jul 18 12:50 testdrwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1drwx--x--x  2 root  root 4096 Jul 18 12:54 test2\n\n上面的权限部分，如果没有加上 -m 来强制配置属性，系统会使用默认属性。\n如果我们使用 -m ，如上例我们给予 -m 711 来给予新的目录 drwx–x–x 的权限。\nrmdir (删除空的目录)语法：\n1rmdir [-p] 目录名称\n\n选项与参数：\n\n-p ：连同上一级『空的』目录也一起删除\n\n删除 runoob 目录\n1[root@www tmp][root@www tmp]# rmdir runoob/\n\n将 mkdir 实例中创建的目录(/tmp 底下)删除掉！\n12345678910[root@www tmp]# ls -l   &lt;==看看有多少目录存在？drwxr-xr-x  3 root  root 4096 Jul 18 12:50 testdrwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1drwx--x--x  2 root  root 4096 Jul 18 12:54 test2[root@www tmp]# rmdir test   &lt;==可直接删除掉，没问题[root@www tmp]# rmdir test1  &lt;==因为尚有内容，所以无法删除！rmdir: `test1&#x27;: Directory not empty[root@www tmp]# rmdir -p test1/test2/test3/test4[root@www tmp]# ls -l        &lt;==您看看，底下的输出中test与test1不见了！drwx--x--x  2 root  root 4096 Jul[root@www tmp]# ls -l   &lt;==看看有多少目录存在？drwxr-xr-x  3 root  root 4096 Jul 18 12:50 testdrwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1drwx--x--x  2 root  root 4096 Jul 18 12:54 test2[root@www tmp]# rmdir test   &lt;==可直接删除掉，没问题[root@www tmp]# rmdir test1  &lt;==因为尚有内容，所以无法删除！rmdir: `test1&#x27;: Directory not empty[root@www tmp]# rmdir -p test1/test2/test3/test4[root@www tmp]# ls -l        &lt;==您看看，底下的输出中test与test1不见了！drwx--x--x  2 root  root 4096 Jul 18 12:54 test2\n\n利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 一次删除。\n不过要注意的是，这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录。\ncp (复制文件或目录)cp 即拷贝文件和目录。\n语法:\n12[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)[root@www ~]# cp [options] source1 source2 source3 .... [root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)[root@www ~]# cp [options] source1 source2 source3 .... directory\n\n选项与参数：\n\n-a：相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)\n-d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；\n-f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；\n-i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)\n-l：进行硬式连结(hard link)的连结档创建，而非复制文件本身；\n-p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)；\n-r：递归持续复制，用於目录的复制行为；(常用)\n-s：复制成为符号连结档 (symbolic link)，亦即『捷径』文件；\n-u：若 destination 比 source 旧才升级 destination ！\n\n用 root 身份，将 root 目录下的 .bashrc 复制到 /tmp 下，并命名为 bashrc\n123[root@www ~]# cp ~/.bashrc /tmp/bashrc[root@www ~]# cp -i ~/.bashrc /tmp/bashrccp: overwrite `/tmp/bashrc[root@www ~]# cp ~/.bashrc /tmp/bashrc[root@www ~]# cp -i ~/.bashrc /tmp/bashrccp: overwrite `/tmp/bashrc&#x27;? n  <==n不覆盖，y为覆盖","categories":["技术"],"tags":["学习笔记","Linux"]},{"title":"大计划！微信小程序学习笔记","url":"https://dicemy.github.io/13114.html","content":"刚开始，先进行一个demo的学习。原文链接：https://blog.csdn.net/lu_embedded/article/details/86181251\n项目目录结构微信小程序的基本文件构造和项目目录结构说明如下：\n.\n├── app.js     # 小程序的逻辑文件\n├── app.json   # 小程序的配置文件\n├── app.wxss   # 全局公共样式文件\n├── pages      # 存放小程序的各个页面\n│   ├── index  # index页面\n│   │   ├── index.js     # 页面逻辑\n│   │   ├── index.wxml   # 页面结构\n│   │   └── index.wxss   # 页面样式表\n│   └── logs   # logs页面\n│       ├── logs.js      # 页面逻辑\n│       ├── logs.json    # 页面配置\n│       ├── logs.wxml    # 页面结构\n│       └── logs.wxss    # 页面样式表\n├── project.config.json\n└── utils\n    └── util.js\n\n页头页尾pages 属性用来设置页面路径，它是一个数组，每一项都是字符串来指定小程序由哪些页面组成。数组的第一项代表小程序的初始页面。小程序中新增或减少页面，都需要对 pages 数组进行修改。\nwindow 属性用于设置小程序的状态栏、导航条、标题、窗口背景色。\n我们把页头的标题和颜色修改一下，页尾部分我们做一个 tab 栏来切换页面，这个属性叫做 tabBar，代码如下：\n1234567891011121314151617181920212223242526272829303132&#123;  &quot;pages&quot;:[    &quot;pages/index/index&quot;,    &quot;pages/logs/logs&quot;  ],  &quot;window&quot;:&#123;    &quot;backgroundTextStyle&quot;:&quot;light&quot;,    &quot;navigationBarBackgroundColor&quot;: &quot;#2f2f8f&quot;,\t    &quot;navigationBarTitleText&quot;: &quot;GoZeroWaste&quot;,\t# 标题    &quot;navigationBarTextStyle&quot;:&quot;white&quot;  &#125;,  &quot;tabBar&quot;:&#123;\t\t\t\t\t    &quot;color&quot;: &quot;#bfc1ab&quot;,    &quot;selectedColor&quot;: &quot;#13b11c&quot;,    &quot;backgroundColor&quot;: &quot;#1f1f4f&quot;,    &quot;list&quot;: [\t# 导航栏的两个按钮      &#123;        &quot;pagePath&quot;: &quot;pages/index/index&quot;,        &quot;iconPath&quot;: &quot;image/icon_component.png&quot;,\t# 第一个按钮的图标        &quot;selectedIconPath&quot;: &quot;image/icon_component_HL.png&quot;,\t# 选择第二个按钮后第一个的按钮的图标        &quot;text&quot;: &quot;个人中心&quot;\t# 按钮的名字      &#125;,      &#123;        &quot;pagePath&quot;: &quot;pages/details/details&quot;,        &quot;iconPath&quot;: &quot;image/icon_API.png&quot;,\t# 第二个按钮的图标        &quot;selectedIconPath&quot;: &quot;image/icon_API_HL.png&quot;,\t# 选择第一个按钮后第二个的按钮的图标        &quot;text&quot;: &quot;生活指南&quot;\t&#123;  &quot;pages&quot;:[    &quot;pages/index/index&quot;,    &quot;pages/logs/logs&quot;  ],  &quot;window&quot;:&#123;    &quot;backgroundTextStyle&quot;:&quot;light&quot;,    &quot;navigationBarBackgroundColor&quot;: &quot;#2f2f8f&quot;,\t    &quot;navigationBarTitleText&quot;: &quot;GoZeroWaste&quot;,\t# 标题    &quot;navigationBarTextStyle&quot;:&quot;white&quot;  &#125;,  &quot;tabBar&quot;:&#123;\t\t\t\t\t    &quot;color&quot;: &quot;#bfc1ab&quot;,    &quot;selectedColor&quot;: &quot;#13b11c&quot;,    &quot;backgroundColor&quot;: &quot;#1f1f4f&quot;,    &quot;list&quot;: [\t# 导航栏的两个按钮      &#123;        &quot;pagePath&quot;: &quot;pages/index/index&quot;,        &quot;iconPath&quot;: &quot;image/icon_component.png&quot;,\t# 第一个按钮的图标        &quot;selectedIconPath&quot;: &quot;image/icon_component_HL.png&quot;,\t# 选择第二个按钮后第一个的按钮的图标        &quot;text&quot;: &quot;个人中心&quot;\t# 按钮的名字      &#125;,      &#123;        &quot;pagePath&quot;: &quot;pages/details/details&quot;,        &quot;iconPath&quot;: &quot;image/icon_API.png&quot;,\t# 第二个按钮的图标        &quot;selectedIconPath&quot;: &quot;image/icon_API_HL.png&quot;,\t# 选择第一个按钮后第二个的按钮的图标        &quot;text&quot;: &quot;生活指南&quot;\t# 按钮的名字      &#125;    ]  &#125;&#125;\n\n（所用到的图片放在项目的 image 目录，你也可以使用自己的图片）\n这里用到几个 tabBar 的属性是 color、selectedColor、backgroundColor 和 list，list 是一个数组，主要用于设定导航的路径。\n因为导航栏中一个按钮关联的是另一个页面，但是这个页面还没有存在，所以我们需要在app.json文件的list中直接添加，修改app.json文件：\n1234567&#123;    &quot;pages&quot;:[    &quot;pages/index/index&quot;,    &quot;pages/logs/logs&quot;,    &#123;    &quot;pages&quot;:[    &quot;pages/index/index&quot;,    &quot;pages/logs/logs&quot;,    \"pages/details/details\"    ],    \n\nCTRL + S 保存之后，模拟器就会自动刷新，马上可以看到效果。保存刷新之后就会发现，目录结构里自动创建了这一页。\n简单起见，我们就在 pages/index 目录下实现 “个人中心” 页面好了。双击打开 index.wxml，初始内容如下：\n这里已经有一些代码了，虽然现在可能还看不懂，但我们知道，这就是现在页面的源代码。我们把 “Hello World” 部分注释掉，增加我们希望显示的内容：\n12345678910111213141516171819202122232425&lt;!--index.wxml--&gt;&lt;view class=&quot;container&quot;&gt;  &lt;view class=&quot;userinfo&quot;&gt;    &lt;button wx:if=&quot;&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;&quot; open-type=&quot;getUserInfo&quot; bindgetuserinfo=&quot;getUserInfo&quot;&gt; 获取头像昵称 &lt;/button&gt;    &lt;block wx:else&gt;      &lt;image bindtap=&quot;bindViewTap&quot; class=&quot;userinfo-avatar&quot; src=&quot;&#123;&#123;userInfo.avatarUrl&#125;&#125;&quot; background-size=&quot;cover&quot;&gt;&lt;/image&gt;      &lt;text class=&quot;userinfo-nickname&quot;&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt;    &lt;/block&gt;  &lt;/view&gt;   &lt;!-- &lt;view class=&quot;usermotto&quot;&gt;    &lt;text class=&quot;user-motto&quot;&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt;  &lt;/view&gt;  --&gt;\t&lt;!--注释内容--&gt;    &lt;!--页面的三行字--&gt;  &lt;view class=&quot;ID_Badge&quot;&gt;    &lt;view&gt;      &lt;text class=&quot;ID_info&quot;&gt;&#123;&#123;company&#125;&#125;&lt;/text&gt;\t    &lt;/view&gt;    &lt;view&gt;      &lt;text class=&#x27;ID_info&#x27;&gt;&#123;&#123;position&#125;&#125;&lt;/text&gt;    &lt;/view&gt;    &lt;view&gt;      &lt;text class=&#x27;ID_info&#x27;&gt;&#123;&#123;lesson&#125;&#125;&lt;/text&gt;    &lt;/view&gt;  &lt;/view&gt;&lt;/&lt;!--index.wxml--&gt;&lt;view class=&quot;container&quot;&gt;  &lt;view class=&quot;userinfo&quot;&gt;    &lt;button wx:if=&quot;&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;&quot; open-type=&quot;getUserInfo&quot; bindgetuserinfo=&quot;getUserInfo&quot;&gt; 获取头像昵称 &lt;/button&gt;    &lt;block wx:else&gt;      &lt;image bindtap=&quot;bindViewTap&quot; class=&quot;userinfo-avatar&quot; src=&quot;&#123;&#123;userInfo.avatarUrl&#125;&#125;&quot; background-size=&quot;cover&quot;&gt;&lt;/image&gt;      &lt;text class=&quot;userinfo-nickname&quot;&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt;    &lt;/block&gt;  &lt;/view&gt;   &lt;!-- &lt;view class=&quot;usermotto&quot;&gt;    &lt;text class=&quot;user-motto&quot;&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt;  &lt;/view&gt;  --&gt;\t&lt;!--注释内容--&gt;    &lt;!--页面的三行字--&gt;  &lt;view class=&quot;ID_Badge&quot;&gt;    &lt;view&gt;      &lt;text class=&quot;ID_info&quot;&gt;&#123;&#123;company&#125;&#125;&lt;/text&gt;\t    &lt;/view&gt;    &lt;view&gt;      &lt;text class=&#x27;ID_info&#x27;&gt;&#123;&#123;position&#125;&#125;&lt;/text&gt;    &lt;/view&gt;    &lt;view&gt;      &lt;text class=&#x27;ID_info&#x27;&gt;&#123;&#123;lesson&#125;&#125;&lt;/text&gt;    &lt;/view&gt;  &lt;/view&gt;&lt;/view>\n\n123456发现HTML的几种特性，自己总结的：1.一个标签出现之后会有一个相同的带反斜线的作为结尾，所以每一个标签都是成对出现的比如：&lt;view&gt;&lt;/view&gt;   &lt;text&gt;&lt;/text&gt;  2.在一个标签可以修饰一个变量，然后这个变化的量有一个类，用class来说明，比如&lt;view class = &quot;ID_Badge&quot;&gt; &lt;text class = 发现HTML的几种特性，自己总结的：1.一个标签出现之后会有一个相同的带反斜线的作为结尾，所以每一个标签都是成对出现的比如：&lt;view&gt;&lt;/view&gt;   &lt;text&gt;&lt;/text&gt;  2.在一个标签可以修饰一个变量，然后这个变化的量有一个类，用class来说明，比如&lt;view class = &quot;ID_Badge&quot;&gt; &lt;text class = \"ID_info\">3.一个变量可以与.js文件中的date中的值相互关联，所以html只作为一个最前面的一个框架的作用，后面的.js文件支撑整个页面逻辑。4.只有html文件和js文件并不行，每一个类都需要在本页面的css文件内进行声明，并且设置这个类的样式属性。5.每一个text或者image的标签必须被一对view标签包围。\n\n","categories":["技术"],"tags":["学习笔记"]},{"title":"2021牛客寒假算法基础集训营6","url":"https://dicemy.github.io/50660.html","content":"A题  回文括号序列计数链接：https://ac.nowcoder.com/acm/contest/9986/A来源：牛客网\n题目描述我们定义一个字符串S是回文的，表示S的左右反转和S相同。\n 我们定义一个字符串是括号序列：\n​     \\1. 空串是括号序列。​     \\2. 两个括号序列P和Q的拼接是括号序列。​     \\3. 如果P是括号序列，’(‘+P+’)’是括号序列。\n 求长度为 n (0&lt;=n&lt;=10^9) 的回文括号序列的方案数，对 998244353 取膜。\n输入描述:\n第一行一个 T 表示数据组数。T&lt;=1000000。接下来 T 行，每行一个 n 。\n\n输出描述:\nT 行。对于每组数据，你的答案。\n\n示例1\n输入\n123201\n\n输出\n1210\n\n思路啥都不说了，凉心出题人。题目十分的阴间。\n看看这迷人的通过率，还浪费了我大把的卡常时间。\n说实话我现在还是没有看懂题，啥叫“一个字符串S是回文的，表示S的左右反转和S相同。”\nPS：在题解文档出来之后，并且翻阅了好多其他人的题解之后我懂了这个“（）”为什么不是回文：它指的回文是”abba”但是很显然（与）是两个符号。所以并不是aa形而是ab形，所以“（）”并不是一个回文序列。同理根据题中所给的构造条件可知，长度大于0的串都不可能是回文串。\n代码123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int ncase;    scanf(&quot;%d&quot;, &amp;ncase);    while (ncase--)    &#123;        int n;        scanf(&quot;%d&quot;, &amp;n);        if (n == 0) puts(&quot;1&quot;);        else puts(&quot;0&quot;);    &#125;    return #include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int ncase;    scanf(&quot;%d&quot;, &amp;ncase);    while (ncase--)    &#123;        int n;        scanf(&quot;%d&quot;, &amp;n);        if (n == 0) puts(&quot;1&quot;);        else puts(&quot;0&quot;);    &#125;    return 0;&#125;\n\n这短小精湛的代码告诉我们，写题之前先读题。\n（出题人还让答案对一个数取模，看起来跟真的似的，给忽悠瘸了）\nJ题  天空之城链接：https://ac.nowcoder.com/acm/contest/9986/J来源：牛客网\n题目描述天空之城有5个小镇，名字分别为Ada, Aed, Akk, Orz, Apq，他们也有相互的路径长度。  \n  希达早已期盼着天空之城，如今她登上了天空之城，就想走遍天空之城的每一个城市，但是她希望自己走的路的长度越小越好，以节省体力和节约时间。  \n  巴鲁同意了，但由于他是主力（男孩子嘛），需要帮希达计算出走遍所有城市的最短路径长度。  \n  由于天空之城具有魔力，如果希达想再走一次自己之前走过的路，则她可以在这条路上不花费任何时间。  \n  但是天空之城的城市太多了，他实在计算不过来，只得请你来帮帮忙了。\n输入描述:\n第一行，输入n，q, 表示有n个城市，q条边；\n第二行，输入一个名字tmp，表示希达想要从tmp城市开始行走；\n接下来q行，每行输入两个名字a,b和一个数字val, 表示a城市与b城市之间的距离为val.(注意可能有重边和自环)\n\n输出描述:\n帮助巴鲁计算出最短的路径长度，如果无法走遍所有城市，输出“No!”。\n\n示例1\n输入\n\n12345675 5OrzAda Aed 5Orz Ada 6Apq Aed 8Akk Apq 12Aed Orz 5 5OrzAda Aed 5Orz Ada 6Apq Aed 8Akk Apq 12Aed Orz 3\n\n\n输出\n\n128\n\n\n说明\n\n1Ada-&gt;Aed-&gt;Orz-&gt;Aed-&gt;AAda-&gt;Aed-&gt;Orz-&gt;Aed-&gt;Apq->Akk\n\n备注:\n多组输入输出（以EOF结束），保证数据组数不超过 10 。\n1 &lt;= n &lt;= 5000, 1 &lt;= q &lt;= 200000, 1 &lt;= val &lt;= 1e9. 每个城市的名字长度不超过10。\n保证 ∑q≤200000\\sum q \\le 200000∑q≤200000 。\n\n图论题，由题可知我们要求一个图中的最小生成树。\n复习一下Kruskal算法。\nKruskal算法的核心是贪心算法，我们根据边权进行从小到大排序，每次取出边权最小的那一个，然后将两点加入到生成树中，在添加的过程中需要注意的是，维护一个并查集，实时监测是否出现了环，如果出现了环那么这条边舍弃，结束的条件是当加入了n-1条边之后，最小生成树即建成。\n代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt; using namespace std;typedef long long ll;const int maxn = 5005;const int maxm = 200005;ll n, q, ans, tot;struct edge &#123;\tint from, to;\tll v;\tbool operator &lt; (const edge &amp;b)const&#123;\t\treturn v &lt; b.v;\t&#125;&#125;a[maxm];ll f[maxn];map&lt;string, ll&gt; mp;ll find(ll x)&#123;return x == f[x] ? x : f[x] = find(f[x]);&#125;void Kruskal() &#123;\tsort(a + 1, a + 1 + q);\tfor (int i=1;i&lt;=q;++i) &#123;\t\tll x = find(a[i].from);\t\tll y = find(a[i].to);\t\tif (x != y) &#123;\t\t\tf[x] = y;\t\t\tans += a[i].v;\t\t&#125;\t&#125;\tll x = find(1);\tfor (int i=2;i&lt;=n;++i) &#123;\t\tif (find(i) != x) &#123;\t\t\tcout &lt;&lt; &quot;No!&quot; &lt;&lt; endl;\t\t\treturn;//这个细节错了一次，忘记输出完no后直接返回\t\t&#125;\t&#125;\tcout &lt;&lt; ans &lt;&lt; endl;\treturn;&#125;int main() &#123;\twhile (cin &gt;&gt; n &gt;&gt; q) &#123;\t\tstring aaa, bbb;\t\tmp.clear();\t\ttot = 0;\t\tans = 0;\t\tfor (int i=1;i&lt;=n;++i)\tf[i] = i;\t\tcin &gt;&gt; aaa;\t\tfor (int i=1;i&lt;=q;++i)  &#123;\t\t\tcin &gt;&gt; aaa &gt;&gt; bbb;\t\t\tcin &gt;&gt; a[i].v;\t\t\tif (mp.count(aaa) == 0) mp[aaa] = ++tot;\t\t\tif (mp.count(bbb) == 0) mp[bbb] = ++tot;\t\t\ta[i].from = mp[aaa];\t\t\ta[i].to = mp[bbb];\t\t&#125;\t\tKruskal();\t&#125;\treturn #include&lt;bits/stdc++.h&gt; using namespace std;typedef long long ll;const int maxn = 5005;const int maxm = 200005;ll n, q, ans, tot;struct edge &#123;\tint from, to;\tll v;\tbool operator &lt; (const edge &amp;b)const&#123;\t\treturn v &lt; b.v;\t&#125;&#125;a[maxm];ll f[maxn];map&lt;string, ll&gt; mp;ll find(ll x)&#123;return x == f[x] ? x : f[x] = find(f[x]);&#125;void Kruskal() &#123;\tsort(a + 1, a + 1 + q);\tfor (int i=1;i&lt;=q;++i) &#123;\t\tll x = find(a[i].from);\t\tll y = find(a[i].to);\t\tif (x != y) &#123;\t\t\tf[x] = y;\t\t\tans += a[i].v;\t\t&#125;\t&#125;\tll x = find(1);\tfor (int i=2;i&lt;=n;++i) &#123;\t\tif (find(i) != x) &#123;\t\t\tcout &lt;&lt; &quot;No!&quot; &lt;&lt; endl;\t\t\treturn;//这个细节错了一次，忘记输出完no后直接返回\t\t&#125;\t&#125;\tcout &lt;&lt; ans &lt;&lt; endl;\treturn;&#125;int main() &#123;\twhile (cin &gt;&gt; n &gt;&gt; q) &#123;\t\tstring aaa, bbb;\t\tmp.clear();\t\ttot = 0;\t\tans = 0;\t\tfor (int i=1;i&lt;=n;++i)\tf[i] = i;\t\tcin &gt;&gt; aaa;\t\tfor (int i=1;i&lt;=q;++i)  &#123;\t\t\tcin &gt;&gt; aaa &gt;&gt; bbb;\t\t\tcin &gt;&gt; a[i].v;\t\t\tif (mp.count(aaa) == 0) mp[aaa] = ++tot;\t\t\tif (mp.count(bbb) == 0) mp[bbb] = ++tot;\t\t\ta[i].from = mp[aaa];\t\t\ta[i].to = mp[bbb];\t\t&#125;\t\tKruskal();\t&#125;\treturn 0;&#125;\n\n\n来总结一下Kruskal的一些小细节，首先是并查集函数的背诵和f数组的初始化不要忘。\n然后就是存贮边的结构体中要重载一下小于号的运算符，以w为排序的依据。\n\nF题  组合数问题链接：https://ac.nowcoder.com/acm/contest/9986/F来源：牛客网\n题目描述小 M 很喜欢组合数。\n 小 Z 给了她一个数 n （n为偶数），让她计算 (n0)+(n2)+(n4)..+(nn)\\binom{n}{0}+\\binom{n}{2}+\\binom{n}{4}..+\\binom{n}{n}(0n​)+(2n​)+(4n​)..+(nn​) ，小 M 一下子就秒掉了，觉得题好简单。\n 因此，小 Z 给了她一个难题：给定一个数 n （n 是4的倍数），计算 (n0)+(n4)+(n8)+…+(nn)\\binom{n}{0}+\\binom{n}{4}+\\binom{n}{8}+…+\\binom{n}{n}(0n​)+(4n​)+(8n​)+…+(nn​) ，答案对 998244353 取模。\n 小 M 不会做，请你来帮帮她吧！\n输入描述:\n1输入一个数 输入一个数 n 。\n\n输出描述:\n1输出答案对 输出答案对 998244353 取模的值。\n\n示例1\n输入\n\n112\n\n\n输出\n\n1992\n\n备注:\n对于所有的数据，1\\le n\\le 10^{18}1≤n≤10 18。\n\n思路:怎么说，这道题只看懂了题解，实现可能还差点东西（虚数快速幂）\n\n\n这是主办方的题解记录，最后的公式导出其实是用了高中组合数学中的一些公式推得的，所以这道题考验了高中的组合数学能力和虚数快速幂代码的能力。（然而百度了一下发现好像并没有虚数快速幂的相关资料）\n","categories":["编程"],"tags":["赛后总结","思考题","最小生成树","组合数学"]},{"title":"2021牛客寒假算法基础集训营5","url":"https://dicemy.github.io/16246.html","content":"B 比武招亲（上）链接：https://ac.nowcoder.com/acm/contest/9985/B来源：牛客网\n题目描述众所周知，天姐姐只喜欢天下最聪明的人，为了找到这样的人，她决定比武招亲！\n只见天姐姐在榜上留下了这样一道问题，谁做出来了就可以俘获她的芳心！\n爱慕天姐姐已久的泽鸽鸽问询赶来，只见榜上写着：\n\n给定 n,m，定义一种序列，构造方法如下：\n1.1. 在 [1,n] 中任意选择 m 次，得到了 m 个整数（显然数字可能相同）;\n2.2. 将选出的 m 个数字排序之后得到一个序列 {a1,a2,…,am}。\n定义一个序列的贡献为 max{a1,a2,…,am}−min{a1,a2,…,am}，求所有本质不同的序列的贡献和。\n为了防止结果过大，将答案为 998244353 取模后输出。（对于两个序列长度为m的序列 A、B，若 ∃i∈[1,m]，Ai≠Bi，则序列 A、B 本质不同）\n\n泽鸽鸽心有余而力不足，而你作为他最好的基友决定帮助泽鸽鸽俘获美人心！\n现在，这个重任就交给你啦！\n输入描述\n一行输入两个正整数 n，m【数据规模与约定】1 &lt;= n, m &lt;= 5*10^5\n\n输出描述\n一行一个整数，为答案对 998244353 取模后的结果。\n\n示例1输入\n3 2\n\n输出\n4\n\n说明\n本质不同的序列有如下几种：1 1、2 2、3 3、1 2、1 3、2 3，贡献为 0+0+0+1+2+1=4。\n\n看到的第一感觉是一个dp，思考f[n][m]怎样从f[n-1][m-1]或者f[n][m-1]，f[n-1][m]转移而来，但是没想出来，觉得像是和组合数的方法数统计有关。\n前置知识复习：1.组合数递推。2.乘法逆元。\n1.组合数可以通过用公式算得，所以只需递推出n的阶乘即可。\n公式为：C（n,m） = n ! / (n - m) ! * m !\n2.乘法逆元的线性递推，这个看起来好像有一点点的复杂，在两三年前我曾经懂得这个的完全推法，但是现在的我已经伤仲永了…. 先记住线性递推逆元的写法，至于原理之后再研究….但是 ！ 由于这道题的性质， p 是一个质数并且阶乘的数字比较大所以用小费马定理可以比较方便的求出逆元的大小。\n\ninv[i] = (mod-mod/i) * inv[mod % i] % mod; // 一行线性递推乘法逆元。小费马定理是： inv(x) = power(a, p-2, p);\n\n现在可以开始写这道题了。\n思路：根据问题，计算贡献和大致是dp或者排列组合计数来解。仔细一看发现和DP没啥关系，于是考虑组合计数。\n首先根据题意，知道一个序列的最大值和最小值后这个序列的贡献就可以被唯一确定出来，即最大值减最小值。不妨设某个长度为m的序列最大值为mx，最小值为mn，那么这个序列排序后究竟长什么样呢？是mn, .., .., .., ……. .., mx。肯定有一个mx和一个mn是确定的，关键在于剩下m - 2个数有多少种选法。我们用选法数乘以(mx - mn)就能得到最大值为mx最小值为mn的所有序列的总贡献了。而易知剩下m - 2个数肯定都在[mn, mx]内，现在就转化为一个高中常见的排列组合问题：x个相同的小球放入y个盒子，允许有空盒，问一共有多少种放法。答案是C(x + y - 1, y - 1)。对于这个问题而言，相当于m - 2个数分配到[mn, mx]的区间内，允许有数不被覆盖，问有多少种分配方法。即C(m - 2 + mx - mn, mx - mn - 1)。\n组合数取模有模版，根据卢卡斯定理，预处理出逆元来就可以计算。那么问题来了：最大值和最小值怎么确定。直接二重循环枚举肯定t得妈妈都不认识，但其实没有必要二重循环。注意到mn = 1, mx = 5和mn = 2, mx = 6的情况其实答案相同，因此我们直接枚举mx - mn（mx - mn其实也是贡献），再乘上这样的区间个数计算即可。\n坑点：预处理逆元的时候要开2倍n的大小！这个要根据组合数计算的范围来开！\n\n这中间用到了组合数学的一些知识，那一个盒子放数的模型也要等到后面再研究了。\n\n代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6 + 8;const int p = 998244353;ll n, m, ans = 0;ll f[maxn];ll power(ll a, ll b, ll p) &#123;    ll res = 1 % p;    while(b) &#123;        if (b&amp;1) res = (ll) res * a % p ;        a = (ll) a * a % p;        b &gt;&gt;= 1;    &#125;    return res;&#125;inline ll inv(ll x) &#123;\treturn power(x, p-2, p);&#125;void init() &#123;\tcin &gt;&gt; n &gt;&gt; m;\tf[0] = f[1] = 1;\tfor (int i=2;i&lt;=maxn;++i) \t\tf[i] = f[i - 1] * i % p; &#125;inline ll C(ll n, ll m) &#123;\tif (n == m|| m == 0)\treturn 1;\treturn (f[n] * inv(f[m]) % p * inv(f[n - m]) % p);&#125;int main() &#123;\tinit();\tfor (int d=1;d&lt;=n-1;++d) &#123;\t\tll tmp = d * (n - d) % p;\t\tans = (ans + tmp * C(d + m - 2, m - 2) % p) %p;\t&#125;\tcout &lt;&lt; ans;\treturn #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6 + 8;const int p = 998244353;ll n, m, ans = 0;ll f[maxn];ll power(ll a, ll b, ll p) &#123;    ll res = 1 % p;    while(b) &#123;        if (b&amp;1) res = (ll) res * a % p ;        a = (ll) a * a % p;        b &gt;&gt;= 1;    &#125;    return res;&#125;inline ll inv(ll x) &#123;\treturn power(x, p-2, p);&#125;void init() &#123;\tcin &gt;&gt; n &gt;&gt; m;\tf[0] = f[1] = 1;\tfor (int i=2;i&lt;=maxn;++i) \t\tf[i] = f[i - 1] * i % p; &#125;inline ll C(ll n, ll m) &#123;\tif (n == m|| m == 0)\treturn 1;\treturn (f[n] * inv(f[m]) % p * inv(f[n - m]) % p);&#125;int main() &#123;\tinit();\tfor (int d=1;d&lt;=n-1;++d) &#123;\t\tll tmp = d * (n - d) % p;\t\tans = (ans + tmp * C(d + m - 2, m - 2) % p) %p;\t&#125;\tcout &lt;&lt; ans;\treturn 0;&#125; \n\n这篇题解是从csdn上我的账号搬运过来的，新的博客搭好啦，开始搬运计划√\n","categories":["编程"],"tags":["赛后总结","组合数学","乘法逆元"]},{"title":"2021牛客寒假算法基础集训营2","url":"https://dicemy.github.io/1765.html","content":"F.牛牛与交换排序链接：https://ac.nowcoder.com/acm/contest/9982/F来源：牛客网\n题目描述牛牛有一个数组，数组元素是 1 到 n 的排列，即数组的值在 1 ∼ n 范围内，且每个数字仅出现 1 次。牛牛想要将该数组变为升序排列的，他可以进行如下的操作。\n首先他要确定一个长度 k ，k 的范围在 1 ∼ n 之间。接下来他将会进行若干次操作。在每轮操作中他都可以选择一段长度为k的子数组，然后进行区间的翻转操作。\n他可以做任意次数的操作，但是要求他每次选择的子数组区间满足 li &lt;= li+1，并且区间长度等于一开始选定的 k ，也就是说一旦某一次操作选择了数组的某个位置进行区间翻转操作，下一次做区间翻转的位置将会比上一次更靠右。\n牛牛发现，并不总是存在一个 k 可以使得数组排序变为有序，请你告诉牛牛是否存在一个 k 能够在满足规则的情况下完成排序。\n输入描述:第一行输入一个正整数 n ( 1 ≤ n ≤ 10^5 ) 表示数组的大小。接下来输出一行 n 个正整数表示一个排列，即每个数的大小范围在 1 到 n 且每个正整数仅出现一次。\n输出描述:如果存在至少一个 k 能够使牛牛完成排序，请先在一行中输出一个 “yes”，然后另起一行输出一个可以满足排序的k，要求k的范围在 [ 1 , n ]  之间，如果有多解，你可以输出任意一个。\n反之如果不存在任何一个k可以完成排序，请直接在一行输出一个”no”\n示例1\n输入\n123455 2 1 4 3155 2 1 4 312\n\n输出\n1234yes31yes312\n\n\n示例2\n输入\n123451 2 3 4 5151 2 3 4 512\n\n输出\n1234yes11yes112\n\n\n示例3\n输入\n123455 4 3 2 1155 4 3 2 112\n\n输出\n12yesyes5\n\n\n思路：首先，我们应该如何找到k。由于我们最后要得到的是一个排序好的数列，所以如果这个数列可以成功排序的话，对于1位置上的数来说一定是1，那么第一次交换一定得让1回到1这个位置上去，所以k的大小就是数字1的下标距离1的差值。如果，1就在1这个位置上的话，那么我们判断2，或者更大的数字来确定k的值。\n之后我们如何判断这个k是否可以完成排序呢。我们只需要遵守题目中的规则然后去模拟就可以了。如果模拟到底发现可以排序成功那么就可以，反之则不行。\n但是我们可以想到的是，单纯模拟的话时间复杂度起码是n^2以上的，所以我们有什么好一点的方法优化这个时间吗？答案当然是有的，我们可以通过反转标记和双端队列的方式来优化这个模拟的过程。\n这个过程就是，维护一个长度为k的双端队列，表示如果下一次进行翻转，会受到影响的那些数字，然后从头开始进行模拟，如果i和队列头或者尾的数字相同，那么让他出队然后在反方向上将新的数字入队，维持这一操作直到全部数字出队或者出现无法复位的数字时停止即可。\n\n代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt; using namespace std;const int N = 1e5 + 8;int n, k , flag = 0;int a[N], pos[N];deque&lt;int&gt; q;int main() &#123;\tcin &gt;&gt; n;\tfor (int i=1;i&lt;=n;++i) &#123;\t\tcin &gt;&gt; a[i];\t\tpos[a[i]] = i;\t&#125;\tfor (int i=1;i&lt;=n;++i) &#123;\t\tif (pos[i] != i) &#123;\t\t\tk = pos[i] - i + 1;\t\t\tbreak;\t\t&#125;\t&#125;\tif (!k)  &#123;\t\tcout &lt;&lt; &quot;yes\\n&quot; &lt;&lt; 1;\t\treturn 0;\t&#125;\tfor (int i=1;i&lt;=k;++i)\tq.push_back(a[i]);\tfor (int i=1+k;i&lt;=n+k;++i) &#123;\t\tif (!(flag % 2)) &#123;\t\t\tif (i - k == q.front())\tq.pop_front();\t\t\telse if(i - k == q.back())\tflag ^= 1, q.pop_back();\t\t\telse &#123;\t\t\t\tcout &lt;&lt; &quot;no&quot;;\t\t\t\treturn 0;\t\t\t&#125;\t\t&#125;\t\telse if (flag % 2)&#123;\t\t\tif (i - k == q.back())\tq.pop_back();\t\t\telse if (i - k == q.front())\tflag ^= 1, q.pop_front();\t\t\telse &#123;\t\t\t\tcout &lt;&lt; &quot;no&quot;;\t\t\t\treturn 0;\t\t\t&#125;\t\t&#125;\t\tif (i &lt;= n) &#123;\t\t\tif (flag % 2)\tq.push_front(a[i]);\t\t\telse\tq.push_back(a[i]);\t\t&#125;\t&#125;\tcout &lt;&lt; &quot;yes\\n&quot; &lt;&lt; k;\treturn #include&lt;bits/stdc++.h&gt; using namespace std;const int N = 1e5 + 8;int n, k , flag = 0;int a[N], pos[N];deque&lt;int&gt; q;int main() &#123;\tcin &gt;&gt; n;\tfor (int i=1;i&lt;=n;++i) &#123;\t\tcin &gt;&gt; a[i];\t\tpos[a[i]] = i;\t&#125;\tfor (int i=1;i&lt;=n;++i) &#123;\t\tif (pos[i] != i) &#123;\t\t\tk = pos[i] - i + 1;\t\t\tbreak;\t\t&#125;\t&#125;\tif (!k)  &#123;\t\tcout &lt;&lt; &quot;yes\\n&quot; &lt;&lt; 1;\t\treturn 0;\t&#125;\tfor (int i=1;i&lt;=k;++i)\tq.push_back(a[i]);\tfor (int i=1+k;i&lt;=n+k;++i) &#123;\t\tif (!(flag % 2)) &#123;\t\t\tif (i - k == q.front())\tq.pop_front();\t\t\telse if(i - k == q.back())\tflag ^= 1, q.pop_back();\t\t\telse &#123;\t\t\t\tcout &lt;&lt; &quot;no&quot;;\t\t\t\treturn 0;\t\t\t&#125;\t\t&#125;\t\telse if (flag % 2)&#123;\t\t\tif (i - k == q.back())\tq.pop_back();\t\t\telse if (i - k == q.front())\tflag ^= 1, q.pop_front();\t\t\telse &#123;\t\t\t\tcout &lt;&lt; &quot;no&quot;;\t\t\t\treturn 0;\t\t\t&#125;\t\t&#125;\t\tif (i &lt;= n) &#123;\t\t\tif (flag % 2)\tq.push_front(a[i]);\t\t\telse\tq.push_back(a[i]);\t\t&#125;\t&#125;\tcout &lt;&lt; &quot;yes\\n&quot; &lt;&lt; k;\treturn 0;&#125;\n\nI: 牛牛的“质因数”链接：https://ac.nowcoder.com/acm/contest/9982/I来源：牛客网\n题目描述算数基本定理，又称唯一分解定理，算术基本定理可表述为：任何一个大于1的自然数 N,如果N不为质数，那么N可以唯一分解成有限个质数的乘积。 朴素的质因子分解算法就是利用了算数基本定理，依次枚举p判断N是否包含素因子p。\n 牛牛最近对于质因数分解产生了浓厚的兴趣。\n 牛牛定义了一个函数F(x)，它表示将x做质因数分解后得到的数字从小到大升序排列，然后将其“拼接”成一个大整数。 例如1500=22355*5,F(1500)=223555。 牛牛现在想要知道∑(n, 2)F(i)的值。\n 由于这个结果非常大，所以你只用告诉牛牛最终答案对10^9 + 7取余数的结果即可。\n输入描述:1仅一行一个正整数n(仅一行一个正整数n(2 ≤ n ≤ 4×10^6)\n\n输出描述:1仅一行，表示答案对10^9+7仅一行，表示答案对10^9+7取余数的结果。\n\n示例1\n输入13\n\n输出15\n\n说明1\n\n\n示例2\n输入110\n\n输出1342\n\n说明12345678910F(2)=2F(3)=3F(4)=22F(5)=5F(6)=23F(7)=7F(8)=222F(9)=33F(10)=252+3+22+5+23+7+222+33+25=F(2)=2F(3)=3F(4)=22F(5)=5F(6)=23F(7)=7F(8)=222F(9)=33F(10)=252+3+22+5+23+7+222+33+25=342\n\n思路这道题的思路其实就是题中所说的进行模拟即可，素数筛法选择快一点的筛子，用线性筛O（n）的时间复杂度，然后维护一个 f[i] 数组即可。可以叫做：筛法DP。其中有一个细节需要注意的是写了两次都被卡到的一个点。对一个数进行数的长度处理的时候还进行了取模运算，这个时候之前的数字的长度其实是不准的。需要用一个数组将这些数据记录下来。\n注意：并不是在模运算下不出现除法得到的结果就一定是正确的了，还要考虑一个数取模之后长度的变化问题。\n\n代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt; using namespace std;typedef long long ll;const int maxn = 4e6 + 10;const int mod = 1e9 + 7;ll n, ans;ll prime[maxn], size = 0;ll f[maxn];ll P[maxn];bool vis[maxn]; ll F(ll x) &#123;\tint c = 0;\twhile(x) x /= 10, c++;\treturn c;&#125;ll power(ll a, ll b) &#123;\tll res = 1;\tfor (; b; b &gt;&gt;= 1) &#123;\t\tif (b &amp; 1) res = ll(res * a % mod);\t\ta = ll(a * a % mod); \t&#125;\treturn res;&#125;void init() &#123;    memset(vis, true, sizeof(vis));    memset(prime, 0, sizeof(vis));    vis[1] = false;    for (ll i=2;i&lt;=n;++i) &#123;        if (vis[i]) &#123;\t\t\tprime[++size] = i;\t\t\tf[i] = i;\t\t\tP[i] = F(i);\t\t&#125;        for (ll j=1;j&lt;=size&amp;&amp;i*prime[j]&lt;=n;++j) &#123;          \tvis[i * prime[j]] = false;          \tint p = P[i];            f[i * prime[j]] = ((prime[j] * power(10, p) % mod) % mod + f[i]) % mod;        \tP[i * prime[j]] = F(prime[j]) + P[i];            if (i % prime[j] == 0)\tbreak;        &#125;    &#125;&#125;int main() &#123;\tcin &gt;&gt; n;\tinit();\tfor (int i=2;i&lt;=n;++i)\tans = (ans + f[i]) % mod;\tcout &lt;&lt; ans;\treturn #include&lt;bits/stdc++.h&gt; using namespace std;typedef long long ll;const int maxn = 4e6 + 10;const int mod = 1e9 + 7;ll n, ans;ll prime[maxn], size = 0;ll f[maxn];ll P[maxn];bool vis[maxn]; ll F(ll x) &#123;\tint c = 0;\twhile(x) x /= 10, c++;\treturn c;&#125;ll power(ll a, ll b) &#123;\tll res = 1;\tfor (; b; b &gt;&gt;= 1) &#123;\t\tif (b &amp; 1) res = ll(res * a % mod);\t\ta = ll(a * a % mod); \t&#125;\treturn res;&#125;void init() &#123;    memset(vis, true, sizeof(vis));    memset(prime, 0, sizeof(vis));    vis[1] = false;    for (ll i=2;i&lt;=n;++i) &#123;        if (vis[i]) &#123;\t\t\tprime[++size] = i;\t\t\tf[i] = i;\t\t\tP[i] = F(i);\t\t&#125;        for (ll j=1;j&lt;=size&amp;&amp;i*prime[j]&lt;=n;++j) &#123;          \tvis[i * prime[j]] = false;          \tint p = P[i];            f[i * prime[j]] = ((prime[j] * power(10, p) % mod) % mod + f[i]) % mod;        \tP[i * prime[j]] = F(prime[j]) + P[i];            if (i % prime[j] == 0)\tbreak;        &#125;    &#125;&#125;int main() &#123;\tcin &gt;&gt; n;\tinit();\tfor (int i=2;i&lt;=n;++i)\tans = (ans + f[i]) % mod;\tcout &lt;&lt; ans;\treturn 0;&#125;\n\n","categories":["编程"],"tags":["赛后总结","双端队列","DP"]},{"title":"2021牛客寒假算法基础集训营1","url":"https://dicemy.github.io/1957.html","content":"I题 限制不互素对的排列链接：https://ac.nowcoder.com/acm/contest/9981/I来源：牛客网\n题目描述输入一个数 n ，请构造一个长度为 n 的排列，使得其中正好有 k 对相邻的数gcd（最大公约数）大于 1 。 排列是指 1 到 n 一共  n 个数，每个数都出现过且仅出现过 1 次。例如，{1, 3, 2, 5, 4}是一个排列，而 {1, 3, 5, 4, 3}、 {1, 2, } 则不是排列\n输入描述:\n两个整数 n 和  k ，用空格隔开。2 &lt;= n &lt;= 100000, 0 &lt;= k &lt;= n / 2\n\n输出描述:\n如果不存在可行的构造方案，输出-1。\n否则输出一行  n 数，用空格隔开。如果有多组可行的构造方案，输出任意一组即可。\n\n示例1\n输入\n12 2 1\n\n输出\n1-1\n\n说明\n1长度为2的排列有2个：&#123;1,2&#125;和&#123;2,1&#125;长度为2的排列有2个：&#123;1,2&#125;和&#123;2,1&#125;，显然都不符合题意\n\n示例2\n输入\n16 6 3\n\n输出\n15 3 6 2 4 5 3 6 2 4 1\n\n说明\n12共有3对相邻数不互素：&#123;3,6&#125;、&#123;6,2&#125;和&#123;2,4&#125;。共有3对相邻数不互素：&#123;3,6&#125;、&#123;6,2&#125;和&#123;2,4&#125;。这并不是唯一解，只要构造任意合法解即可。\n\n思路:由题中给的一个很重要的信息可知，k&lt;=n/2的，而且我们可以轻易地知道对于所有的偶数，他们的最大公因数是2满足大于1的条件，并且n以内偶数的个数正好也是n/2个。所以可以比较轻易的凑够n/2-1对儿满足条件的数对儿。这就是k&lt;=n/2-1的方法。对于k = n/2的情况，我们只需将6放到n/2个偶数的最后一个即可，然后后面放一个3来保证出现第n/2对儿。\n\n代码：123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt; using namespace std;int n, k;void work1() &#123;\tfor (int i=1;i&lt;=k+1;++i)\tcout &lt;&lt; i * 2 &lt;&lt; &#x27; &#x27;;\tfor (int i=k*2+3;i&lt;=n;++i)\tcout &lt;&lt; i &lt;&lt; &#x27; &#x27;;\tfor (int i=1;i&lt;=k+1;++i)\tcout &lt;&lt; 2 * i - 1 &lt;&lt; &#x27; &#x27;;&#125;void work2() &#123;\tif (n &lt; 6)\t&#123;\t\tcout &lt;&lt; -1;\t\treturn;\t&#125;\tfor (int i=4;i&lt;=k;++i)\tcout &lt;&lt; i * 2 &lt;&lt; &#x27; &#x27;;\tcout &lt;&lt; 2 &lt;&lt; &#x27; &#x27; &lt;&lt; 4 &lt;&lt; &#x27; &#x27; &lt;&lt; 6 &lt;&lt; &#x27; &#x27; &lt;&lt; 3 &lt;&lt; &#x27; &#x27;;   \tcout &lt;&lt; 1;// 问题出在这一句上，按照之前的写法，会出现9 4, 答案中 3 和 9 碰到一起的情况，这时候就不对了，所以我们用1来隔开。\tfor (int i=k*2+1;i&lt;=n;++i)\tcout &lt;&lt; i &lt;&lt; &#x27; &#x27;;\tfor (int i=3;i&lt;=k;++i)\tcout &lt;&lt; 2 * i - 1 &lt;&lt; &#x27; &#x27;;       //\tcout &lt;&lt; 1;// 问题出在这一句上&#125;int main() &#123;\tcin &gt;&gt; n &gt;&gt; k;\tif (k &lt;= n / 2 - 1) work1();\telse work2();\treturn 0;&#125;//有问题的代码，状态：已订正#include&lt;bits/stdc++.h&gt; using namespace std;int n, k;void work1() &#123;\tfor (int i=1;i&lt;=k+1;++i)\tcout &lt;&lt; i * 2 &lt;&lt; &#x27; &#x27;;\tfor (int i=k*2+3;i&lt;=n;++i)\tcout &lt;&lt; i &lt;&lt; &#x27; &#x27;;\tfor (int i=1;i&lt;=k+1;++i)\tcout &lt;&lt; 2 * i - 1 &lt;&lt; &#x27; &#x27;;&#125;void work2() &#123;\tif (n &lt; 6)\t&#123;\t\tcout &lt;&lt; -1;\t\treturn;\t&#125;\tfor (int i=4;i&lt;=k;++i)\tcout &lt;&lt; i * 2 &lt;&lt; &#x27; &#x27;;\tcout &lt;&lt; 2 &lt;&lt; &#x27; &#x27; &lt;&lt; 4 &lt;&lt; &#x27; &#x27; &lt;&lt; 6 &lt;&lt; &#x27; &#x27; &lt;&lt; 3 &lt;&lt; &#x27; &#x27;;   \tcout &lt;&lt; 1;// 问题出在这一句上，按照之前的写法，会出现9 4, 答案中 3 和 9 碰到一起的情况，这时候就不对了，所以我们用1来隔开。\tfor (int i=k*2+1;i&lt;=n;++i)\tcout &lt;&lt; i &lt;&lt; &#x27; &#x27;;\tfor (int i=3;i&lt;=k;++i)\tcout &lt;&lt; 2 * i - 1 &lt;&lt; &#x27; &#x27;;       //\tcout &lt;&lt; 1;// 问题出在这一句上&#125;int main() &#123;\tcin &gt;&gt; n &gt;&gt; k;\tif (k &lt;= n / 2 - 1) work1();\telse work2();\treturn 0;&#125;//有问题的代码，状态：已订正//一些奇妙的性质：相邻的两个数一定互质，相邻的两个奇数一定互质。\n\nJ.一群小青蛙呱蹦呱蹦呱链接：https://ac.nowcoder.com/acm/contest/9981/J来源：牛客网\n题目描述：有n个格子，每个格子里有一个数，1,2,3,4…n\n牛牛放出无穷只青蛙。第一只青蛙的路线是：1-&gt;2-&gt;4-&gt;8-&gt;16-&gt;…第二只青蛙的路线是：1-&gt;3-&gt;9-&gt;27-&gt;81-&gt;…第三只青蛙的路线是：1-&gt;5-&gt;25-&gt;125…第四只青蛙的路线是：1-&gt;7-&gt;49…。。。。。。用数学语言描述，第 只青蛙的路线是首项为1，公比为的等比数列，其中代表第个素数。当青蛙跳到一个格子上，如果这个格子上面有一个数，青蛙就会把这个数吃掉。牛牛想知道，所有没有被吃掉的数的lcm（最小公倍数 ，Least common multiple）是多少？由于这个lcm可能非常大，请输出它对 1 0 9 + 7 10^9+7109 +7 取模的值。\n输入描述:一个正整数\n输出描述:如果所有数都被吃掉了，请输出一个字符串”empty”否则输出所有没有被吃掉的数的lcm，对 1 0 9 + 7 10^9+710 9+7 取模\n示例1:\n输入\n17\n\n输出\n16\n\n说明\n12345678数字 1 可以被所有青蛙吃掉；数字 2 可以被第 1 只青蛙吃掉；数字 3 可以被第 2 只青蛙吃掉；数字 4 可以被第 1 只青蛙吃掉；数字 5 可以被第 3 只青蛙吃掉；数字 6 无法被吃掉；数字 7 可以被第 4 只青蛙吃掉。所以剩下的数字只有一个数字 1 可以被所有青蛙吃掉；数字 2 可以被第 1 只青蛙吃掉；数字 3 可以被第 2 只青蛙吃掉；数字 4 可以被第 1 只青蛙吃掉；数字 5 可以被第 3 只青蛙吃掉；数字 6 无法被吃掉；数字 7 可以被第 4 只青蛙吃掉。所以剩下的数字只有一个 6 ，所有数的 lcm 为 6\n\n示例2:\n输入\n1123456789\n输出\n1539747460\n\n思路：性质一：由题可知按照顺序划掉的是每一个素数的几次方，所以很明显的是最后留下来的数一定是由两个以上的素数相乘得到的。\n性质二：我们可以知道lcm是指两个数的最小公倍数，所以最后的答案一定是这些剩下的数字的质因数的某次方中最高那一个互相相乘的答案。\n性质三：我们可以知道一个数进行质因数分解的结果应该是唯一的。\n所以解法来了，先求出n / 2以内的质因数，然后对于2来说，找到log2(n/3)即为2的次方数。对于大于2小于n / 2的所有质数pi来说，logpi(n/2) 就是pi的次方数，然后将这些数都乘到一起就可以得到答案的lcm了。\n知识点复习：线性筛素数：\n1234567891011121314ll prime[maxn], size = 0;bool vis[maxn];void Prime() &#123;\tmemset(vis, true, sizeof(vis));\tmemset(prime, 0, sizeof(prime));\tvis[1] = true;\tfor (int i=2;i&lt;=n;++i) &#123;\t\tif (vis[i])\tprime[++size] = i;\t\tfor (int j=1;j&lt;=size&amp;&amp;i*prime[j]&lt;=n;++j) &#123;\t\t\tvis[i * prime[j]] = false;\t\t\tif (i % prime[j] == 0) ll prime[maxn], size = 0;bool vis[maxn];void Prime() &#123;\tmemset(vis, true, sizeof(vis));\tmemset(prime, 0, sizeof(prime));\tvis[1] = true;\tfor (int i=2;i&lt;=n;++i) &#123;\t\tif (vis[i])\tprime[++size] = i;\t\tfor (int j=1;j&lt;=size&amp;&amp;i*prime[j]&lt;=n;++j) &#123;\t\t\tvis[i * prime[j]] = false;\t\t\tif (i % prime[j] == 0) break;\t\t&#125;\t&#125;&#125;\n\n快速幂：\n12345678ll power(ll a, ll b) &#123;\tll res = 1 % mod;\tfor (; b; b &gt;&gt;= 1) &#123;\t\tif (b &amp; 1) res = ll(res * a % mod);\t\ta = ll(a * a % mod);\t&#125;\tll power(ll a, ll b) &#123;\tll res = 1 % mod;\tfor (; b; b &gt;&gt;= 1) &#123;\t\tif (b &amp; 1) res = ll(res * a % mod);\t\ta = ll(a * a % mod);\t&#125;\treturn res;&#125;\n\n代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 8e7;const int mod = 1e9 + 7;ll n, ans = 1; ll prime[maxn / 10], size = 0;bool vis[maxn];void Prime() &#123;\tmemset(vis, true, sizeof(vis));\tmemset(prime, 0, sizeof(prime));\tvis[1] = true;\tint t = maxn;\tfor (int i=2;i&lt;=t;++i) &#123;\t\tif (vis[i])\tprime[++size] = i;\t\tfor (int j=1;j&lt;=size&amp;&amp;i*prime[j]&lt;=t;++j) &#123;\t\t\tvis[i * prime[j]] = false;\t\t\tif (i % prime[j] == 0) break;\t\t&#125;\t&#125;&#125;ll power(ll a, ll b) &#123;\tll res = 1 % mod;\tfor (; b; b &gt;&gt;= 1) &#123;\t\tif (b &amp; 1) res = ll(res * a % mod);\t\ta = ll(a * a % mod);\t&#125;\treturn res;&#125;int main() &#123;\tPrime();\tcin &gt;&gt; n;\tif (n &lt; 6)  &#123;\t\tcout &lt;&lt; &quot;empty&quot;;\t\treturn 0;\t&#125;\tll tmp = n / 3, c = 0;\twhile(tmp &gt;= 2) tmp /= 2, c++;//细节是当tmp小于prime数之后就不要除了，不然次数都会大个1.\tans = (ans * power(2, c) % mod) % mod;\tfor (int i=2;i&lt;=size;++i) &#123;\t\tif(prime[i] &gt; n / 2)  break;//这也是一个小优化\t\ttmp = n / 2, c = 0;\t\twhile(tmp &gt;= prime[i]) tmp /= prime[i], c++;\t\tans = (ans * power(prime[i], c) % mod) % mod;\t&#125;\tcout &lt;&lt; ans % mod;\treturn #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 8e7;const int mod = 1e9 + 7;ll n, ans = 1; ll prime[maxn / 10], size = 0;bool vis[maxn];void Prime() &#123;\tmemset(vis, true, sizeof(vis));\tmemset(prime, 0, sizeof(prime));\tvis[1] = true;\tint t = maxn;\tfor (int i=2;i&lt;=t;++i) &#123;\t\tif (vis[i])\tprime[++size] = i;\t\tfor (int j=1;j&lt;=size&amp;&amp;i*prime[j]&lt;=t;++j) &#123;\t\t\tvis[i * prime[j]] = false;\t\t\tif (i % prime[j] == 0) break;\t\t&#125;\t&#125;&#125;ll power(ll a, ll b) &#123;\tll res = 1 % mod;\tfor (; b; b &gt;&gt;= 1) &#123;\t\tif (b &amp; 1) res = ll(res * a % mod);\t\ta = ll(a * a % mod);\t&#125;\treturn res;&#125;int main() &#123;\tPrime();\tcin &gt;&gt; n;\tif (n &lt; 6)  &#123;\t\tcout &lt;&lt; &quot;empty&quot;;\t\treturn 0;\t&#125;\tll tmp = n / 3, c = 0;\twhile(tmp &gt;= 2) tmp /= 2, c++;//细节是当tmp小于prime数之后就不要除了，不然次数都会大个1.\tans = (ans * power(2, c) % mod) % mod;\tfor (int i=2;i&lt;=size;++i) &#123;\t\tif(prime[i] &gt; n / 2)  break;//这也是一个小优化\t\ttmp = n / 2, c = 0;\t\twhile(tmp &gt;= prime[i]) tmp /= prime[i], c++;\t\tans = (ans * power(prime[i], c) % mod) % mod;\t&#125;\tcout &lt;&lt; ans % mod;\treturn 0;&#125;\n\n","categories":["编程"],"tags":["赛后总结","数论"]},{"title":"博弈论入门","url":"https://dicemy.github.io/39273.html","content":"\n\n\n巴什博弈：尼姆博弈(Nim)：","categories":["编程"],"tags":["博弈论","算法笔记"]},{"title":"第八届“图灵杯”NEUQ-ACM程序设计竞赛个人赛（同步赛）总结 + 补题","url":"https://dicemy.github.io/23417.html","content":"\n\n\nA题 切蛋糕题目链接 ：https://ac.nowcoder.com/acm/contest/11746/A基本思路是将1/k进行二进制拆分，比如说对于k=5，1 / 5 的二进制为 0.001100110011，则应存在5份大小为0.001的蛋糕，5份大小为0.0001的蛋糕，以此类推。（看到2的几次方相加就应该想到二进制拆分）代码不会写Orz，还不会实现，先留着之后补。\nB题 小宝的幸运数组题目链接 ：https://ac.nowcoder.com/acm/contest/11746/B题目的思路大概是一个同余的相互跳的一个搜索之类的东西，很巧妙。\n12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 10;typedef long long ll;ll T, n, k, ans, sum, t;ll head[maxn];int main() &#123;\tfor (scanf(&quot;%ld&quot;, &amp;T);T;T--) &#123;//学来的多组处理\t\tscanf(&quot;%ld%ld&quot;, &amp;n, &amp;k);\t\tans = sum = 0;\t\tfor (int i=0;i&lt;=k;++i)\thead[i] = -1;//head[x]表示的是第一次出现总和加到一起的余数为x的时候的a的位置是多少。这样可以一边加一边处理，如果某个数加到总和上之后和之前第一次的余数对应上了，说明这之间的数字的和可以被K整除。\t\thead[0] = 0;//显然对于余数为0来说，不需要有数字加上就行。\t\tfor (int i=1;i&lt;=n;++i) &#123;\t\t\tscanf(&quot;%ld&quot;, &amp;t);\t\t\tsum = (sum + t) % k;//维持一个加上当前值然后在k里的一个特征值。\t\t\tif (head[sum] != -1) \t\t\t\tans = max(ans, i - head[sum]);//维护答案 \t\t\telse \t\t\t\thead[sum] = i;//如果第一次出现的话就保存位置\t\t&#125;\t\tans = ans == 0 ? -1 : ans;\t\tprintf(&quot;%ld\\n&quot;, ans);\t&#125;\treturn #include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 10;typedef long long ll;ll T, n, k, ans, sum, t;ll head[maxn];int main() &#123;\tfor (scanf(&quot;%ld&quot;, &amp;T);T;T--) &#123;//学来的多组处理\t\tscanf(&quot;%ld%ld&quot;, &amp;n, &amp;k);\t\tans = sum = 0;\t\tfor (int i=0;i&lt;=k;++i)\thead[i] = -1;//head[x]表示的是第一次出现总和加到一起的余数为x的时候的a的位置是多少。这样可以一边加一边处理，如果某个数加到总和上之后和之前第一次的余数对应上了，说明这之间的数字的和可以被K整除。\t\thead[0] = 0;//显然对于余数为0来说，不需要有数字加上就行。\t\tfor (int i=1;i&lt;=n;++i) &#123;\t\t\tscanf(&quot;%ld&quot;, &amp;t);\t\t\tsum = (sum + t) % k;//维持一个加上当前值然后在k里的一个特征值。\t\t\tif (head[sum] != -1) \t\t\t\tans = max(ans, i - head[sum]);//维护答案 \t\t\telse \t\t\t\thead[sum] = i;//如果第一次出现的话就保存位置\t\t&#125;\t\tans = ans == 0 ? -1 : ans;\t\tprintf(&quot;%ld\\n&quot;, ans);\t&#125;\treturn 0;&#125;\nC题 上进的凡凡这道题的思路是：一个非降序数组的所有子串都为非降序，只要把给定数组分为若干个非降序部分（每个部分要尽可能长），然后计算子串数，对于长度为n的数组子串数为 n * (n + 1) / 2，遍历然后相加。思路的正确性：一个非降序数组的所有子串都为非降序串。\n123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100005;typedef long long ll;ll a[maxn];ll sum, n;int main() &#123;\tios :: sync_with_stdio(false);\tcin &gt;&gt; n;\tfor (int i = 1; i &lt;= n; i++)\tcin &gt;&gt; a[i];\tfor (ll i = 1,t = 1; i &lt;= n; ) &#123;\t\tt = i;\t\tt++;\t\twhile (a[t] &gt;= a[t - 1] &amp;&amp; t &lt;= n)\t\t\tt++;\t\tll ans = t - i;\t\tsum += ans * (ans + 1)/2;\t\ti = t;\t&#125;\tcout &lt;&lt; sum &lt;&lt; endl;\treturn #include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100005;typedef long long ll;ll a[maxn];ll sum, n;int main() &#123;\tios :: sync_with_stdio(false);\tcin &gt;&gt; n;\tfor (int i = 1; i &lt;= n; i++)\tcin &gt;&gt; a[i];\tfor (ll i = 1,t = 1; i &lt;= n; ) &#123;\t\tt = i;\t\tt++;\t\twhile (a[t] &gt;= a[t - 1] &amp;&amp; t &lt;= n)\t\t\tt++;\t\tll ans = t - i;\t\tsum += ans * (ans + 1)/2;\t\ti = t;\t&#125;\tcout &lt;&lt; sum &lt;&lt; endl;\treturn 0;&#125;\nD    Seek the Joker I这题是个：巴什博弈（终于要学新东西了啊）。\n","categories":["编程"],"tags":["赛后总结","搜索"]},{"title":"Python文档阅读","url":"https://dicemy.github.io/55956.html","content":"\n\n\n这是一个英语阅读生词总结笔记（大雾）Some prompts : \n\n(&gt;&gt;&gt;) (three greater-than signs) primary prompt\n(…) secondary prompt\n\nOperators :\n\n(//) to do floor division and get a integer result (discarding any flactional result)\n (\\)** to calculate power\n(_) if you use Python as a calculator you can type _ to get the last printed expression (ps. Don not assign the value to it)\nuse round(a, b) to keep a in the b decimal place \n(j or J) use the J suffix to indicate the imaginary part\n\nString operators : quotes : 单引号 double quotes : 双引号 backslashes : 反斜线 (\\) use \\‘ to escape the single quote (\\n) \\n means newline\nString operation :If you don’t want character prefaced by \\ to be interpreted as special characters, you can use raw string by adding an r  before the first quote.\n12345&gt;&gt;&gt; print(&#x27;C:\\some\\name&#x27;)C:\\someame&gt;&gt;&gt; print(&gt;&gt;&gt; print(&#x27;C:\\some\\name&#x27;)C:\\someame&gt;&gt;&gt; print(r&#x27;C:\\some\\name&#x27;)C:\\some\\name\n\nusing triple-quotes : &#39;&#39;&#39; or &quot;&quot;&quot; so that the strings literals can span multiple lines. and use \\at the end of the line to avoid that  end of lines are automatically included in the string.The following example:\n12345print(&quot;&quot;&quot;\\Usage: thingy [OPTIONS]     -h                        Display this usage message     -H hostname               Hostname to connect toprint(&quot;&quot;&quot;\\Usage: thingy [OPTIONS]     -h                        Display this usage message     -H hostname               Hostname to connect to\"\"\")\n123Usage: thingy [OPTIONS]     -h                        Display this usage message     -H hostname               Hostname to connect Usage: thingy [OPTIONS]     -h                        Display this usage message     -H hostname               Hostname to connect to\nStrings can be concatenated (glued together) with the + operator and repeated with *.Two or more string literals next to each other are automatically concatenated.\n1234&gt;&gt;&gt; text = (&#x27;Put several strings within parentheses &#x27;...         &#x27;to have them joined together.&#x27;)&gt;&gt;&gt; text&gt;&gt;&gt; text = (&#x27;Put several strings within parentheses &#x27;...         &#x27;to have them joined together.&#x27;)&gt;&gt;&gt; text&#x27;Put several strings within parentheses to have them joined together.&#x27;\nThis feature is only work with two literals, not with variables or expressions.\nThe string indices alse can be negative number,to counting from the right.negetive indices start from -1\nslicing  slicing is used to obtain the substringThere follwing examples :\n12345&gt;&gt;&gt; word = &#x27;Python&#x27;&gt;&gt;&gt; word[0:2]  # characters from position 0 (included) to 2 (excluded)&#x27;Py&#x27;&gt;&gt;&gt; word[2:5]  # characters from position 2 (included) to 5 (excluded)&gt;&gt;&gt; word = &#x27;Python&#x27;&gt;&gt;&gt; word[0:2]  # characters from position 0 (included) to 2 (excluded)&#x27;Py&#x27;&gt;&gt;&gt; word[2:5]  # characters from position 2 (included) to 5 (excluded)&#x27;tho&#x27;\nThe start is always included, and end always excluded.This make sure that s[:i] + s[i:] always equal to s.\nNote : an omitted first index defaults to zero.\nPython strings are immutable, so assigning to an indexed position in the string result in an error.\nList :Lists can contain different types, but usually the items all have the same type.List also can be indexed and sliced.(same as string)\n123456&gt;&gt;&gt; squares[0]  # indexing returns the item1&gt;&gt;&gt; squares[-1]25&gt;&gt;&gt; squares[-3:]  # slicing returns a new list[9, 16, &gt;&gt;&gt; squares[0]  # indexing returns the item1&gt;&gt;&gt; squares[-1]25&gt;&gt;&gt; squares[-3:]  # slicing returns a new list[9, 16, 25]\n\nList also support operations like concatenation.\n12&gt;&gt;&gt; squares + [36, 49, 64, 81, 100][1, 4, 9, 16, 25, 36, 49, 64, 81, &gt;&gt;&gt; squares + [36, 49, 64, 81, 100][1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\nUnlike string, list is a mutable type, it is possible to change their content.You can also add new items at the end of the list, by using the append() method (we will see more about methods later):\n1234&gt;&gt;&gt; cubes.append(216)  # add the cube of 6&gt;&gt;&gt; cubes.append(7 ** 3)  # and the cube of 7&gt;&gt;&gt; cubes[1, 8, 27, 64, 125, 216, &gt;&gt;&gt; cubes.append(216)  # add the cube of 6&gt;&gt;&gt; cubes.append(7 ** 3)  # and the cube of 7&gt;&gt;&gt; cubes[1, 8, 27, 64, 125, 216, 343]\nAssignment to slices is also possible, and this can even change the size of the list or clear it entirely:\n123456789101112131415&gt;&gt;&gt; letters = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;]&gt;&gt;&gt; letters[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;]&gt;&gt;&gt; # replace some values&gt;&gt;&gt; letters[2:5] = [&#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;]&gt;&gt;&gt; letters[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;f&#x27;, &#x27;g&#x27;]&gt;&gt;&gt; # now remove them&gt;&gt;&gt; letters[2:5] = []&gt;&gt;&gt; letters[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;f&#x27;, &#x27;g&#x27;]&gt;&gt;&gt; # clear the list by replacing all the elements with an empty list&gt;&gt;&gt; letters[:] = []&gt;&gt;&gt; letters = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;]&gt;&gt;&gt; letters[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;]&gt;&gt;&gt; # replace some values&gt;&gt;&gt; letters[2:5] = [&#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;]&gt;&gt;&gt; letters[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;f&#x27;, &#x27;g&#x27;]&gt;&gt;&gt; # now remove them&gt;&gt;&gt; letters[2:5] = []&gt;&gt;&gt; letters[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;f&#x27;, &#x27;g&#x27;]&gt;&gt;&gt; # clear the list by replacing all the elements with an empty list&gt;&gt;&gt; letters[:] = []>>> letters[]\nbuild-in function len() also applies to lists.nest list is also allowed.\nContains in whileThe condition may also be a string or list value, in fact any sequence; anything with a non-zero length is true, empty sequences are false. \nIndentation is Python’s way of grouping statements.\nThe keyword argument end can be used to avoid the newline after the output, or end the output with a different string:\n123456&gt;&gt;&gt; a, b = 0, 1&gt;&gt;&gt; while a &lt; 1000:...     print(a, end=&#x27;,&#x27;)...     a, b = b, a+b...0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,&gt;&gt;&gt; a, b = 0, 1&gt;&gt;&gt; while a &lt; 1000:...     print(a, end=&#x27;,&#x27;)...     a, b = b, a+b...0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,\n\n\nMore Control Flow Toolsif StatementsThe else part is optional.The keyword ‘elif’ is short for ‘else if’,and is useful to avoid excessive indentation.An if … elif … elif … sequence is a substitute for the switch or case statements found in other languages.\nfor StatementsPython’s for statement iterates over the items of any sequence (a list or a string), in the order that they appear in the sequence. For example (no pun intended):\n12345678&gt;&gt;&gt; # Measure some strings:... words = [&#x27;cat&#x27;, &#x27;window&#x27;, &#x27;defenestrate&#x27;]&gt;&gt;&gt; for w in words:...     print(w, len(w))...cat 3window 6defenestrate &gt;&gt;&gt; # Measure some strings:... words = [&#x27;cat&#x27;, &#x27;window&#x27;, &#x27;defenestrate&#x27;]&gt;&gt;&gt; for w in words:...     print(w, len(w))...cat 3window 6defenestrate 12\nThe range() Functionthe built-in function range() can make the sequence of numbers.These following example:\n12345678&gt;&gt;&gt; for i in range(5):...     print(i)...0123&gt;&gt;&gt; for i in range(5):...     print(i)...01234\nIt is possible to let the range start at another number, or to specify a different increment:\n12345678range(5, 10)   5, 6, 7, 8, 9range(0, 10, 3)   0, 3, 6, 9range(-10, -100, -30)  -10, -40, -range(5, 10)   5, 6, 7, 8, 9range(0, 10, 3)   0, 3, 6, 9range(-10, -100, -30)  -10, -40, -70\nA strange thing happens if you just print a range:\n12&gt;&gt;&gt; print(range(10))range(0, &gt;&gt;&gt; print(range(10))range(0, 10)\nHere is the solution:\n12&gt;&gt;&gt; list(range(4))[0, 1, 2, &gt;&gt;&gt; list(range(4))[0, 1, 2, 3]\nbreak and continue statements and else Clauses on Loops:break and continue are like in C++.\n1234567891011121314151617&gt;&gt;&gt; for n in range(2, 10):...     for x in range(2, n):...         if n % x == 0:...             print(n, &#x27;equals&#x27;, x, &#x27;*&#x27;, n//x)...             break...     else:...         # loop fell through without finding a factor...         print(n, &#x27;is a prime number&#x27;)...2 is a prime number3 is a prime number4 equals 2 * 25 is a prime number6 equals 2 * 37 is a prime number8 equals 2 * 49 equals 3 * &gt;&gt;&gt; for n in range(2, 10):...     for x in range(2, n):...         if n % x == 0:...             print(n, &#x27;equals&#x27;, x, &#x27;*&#x27;, n//x)...             break...     else:...         # loop fell through without finding a factor...         print(n, &#x27;is a prime number&#x27;)...2 is a prime number3 is a prime number4 equals 2 * 25 is a prime number6 equals 2 * 37 is a prime number8 equals 2 * 49 equals 3 * 3\nIn this code, the else is belongs to the for loop, not the if statement.The loop’s else clause runs when no break occurs. \npass Statement :It can be used when a statement is required syntactically but the program requires no action.pass can be used is as a place-holder for a function or conditional body when you are working on new code\nDefining Functions :Other names can also point to that same function object and can also be used to access the function:\n12345&gt;&gt;&gt; fib&lt;function fib at 10042ed0&gt;&gt;&gt;&gt; f = fib&gt;&gt;&gt; f(100)0 1 1 2 3 5 8 13 21 34 55 &gt;&gt;&gt; fib&lt;function fib at 10042ed0&gt;&gt;&gt;&gt; f = fib&gt;&gt;&gt; f(100)0 1 1 2 3 5 8 13 21 34 55 89\nThe example for the defining function:\n1234567891011def ask_ok(prompt, retries=4, reminder=&#x27;Please try again!&#x27;):    while True:        ok = input(prompt)        if ok in (&#x27;y&#x27;, &#x27;ye&#x27;, &#x27;yes&#x27;):            return True        if ok in (&#x27;n&#x27;, &#x27;no&#x27;, &#x27;nop&#x27;, &#x27;nope&#x27;):            return False        retries = retries - 1        if retries &lt; 0:            raise ValueError(&#x27;invalid user response&#x27;)        def ask_ok(prompt, retries=4, reminder=&#x27;Please try again!&#x27;):    while True:        ok = input(prompt)        if ok in (&#x27;y&#x27;, &#x27;ye&#x27;, &#x27;yes&#x27;):            return True        if ok in (&#x27;n&#x27;, &#x27;no&#x27;, &#x27;nop&#x27;, &#x27;nope&#x27;):            return False        retries = retries - 1        if retries &lt; 0:            raise ValueError(&#x27;invalid user response&#x27;)        print(reminder)\nThis function can be called in several ways:giving only the mandatory argument: ask_ok(‘Do you really want to quit?’)giving one of the optional arguments: ask_ok(‘OK to overwrite the file?’, 2)or even giving all arguments: ask_ok(‘OK to overwrite the file?’, 2, ‘Come on, only yes or no!’)\n","categories":["编程"],"tags":["文档阅读"]},{"title":"一天一个上分小技巧","url":"https://dicemy.github.io/18521.html","content":"\n\n\n一天一个上分小技巧：\n\n如果在用评测机做题的话，可以用当n大于某一值时while(1)来判断数据点的范围，如过范围猜中，这时这个测试点就会T掉，反复多交几次就可以判断出测试点的数据大小了\n可以将main函数的返回值类型设为signed，signed和int实质上等价，这时如果需要将全文中的int换为long long时会更加的方便。\nswap(a,b)等价于a ^= b ^= a ^= b\nlowbit(x) = -x&amp;x\n写图论的题的时候记得考虑分层图\n\n一天一个爆零小技巧：\n\n加法运算符的优先级要高于位移，i + j &gt;&gt; 1会优先运算加法，不需要加括号\n\n","categories":["编程"],"tags":["方法总结"]}]