[{"title":"数字逻辑复习","url":"/16132","content":"第一章 数字逻辑电路基础两类信号：模拟信号，数字信号。\n时间和幅值均连续，模拟信号。时间和幅值均离散，数字信号。\n处理数字信号的电路叫做数字电路。\n几种简单编码BCD码8421码， 5421码，2421码, 余三码。\n有权BCD码：8421码， 5421码，2421码。\n5421BCD码和2421BCD码不唯一。\n5421BCD码前五个码和后五个码一一对应，仅高位不同。\n2421BCD码后五个码以中心对称去反，这样的代码成为自反代码。4和5互为反码，3和6，… 0和9互为反码。\n余三码是无权BCD码，是在8421BCD码的基础上加上0011（3）形成的编码。每位数码无确定的位权。\n格雷码格雷码是循环码。\n\n\n奇偶校验码具有检错能力的代码\n奇校验：原代码的基础上加上一个码位使得代码中含有1的个数为奇数。\n偶校验：原代码的基础上加上一个码位使得代码中含有1的个数为偶数。\n通过检查代码中含有的1的奇偶性来判断代码的合法性。\n字符数字码ASCII码等\n算术运算有符号数的表示方法原码，反码，补码。\n一个正数和比他小的负数相加，多出符号位的进位忽略。\n两个负数相加，多出符号位的进位忽略。\n逻辑运算研究数字电路的基础是逻辑代数，也称布尔代数。\n基本逻辑运算逻辑代数中只有三种基本逻辑运算，即“与或非”。\n\n与门和或门可以有多个输入端。\n复合逻辑运算\n同或和异或互为反函数。\n正逻辑和负逻辑正逻辑：高电平有效。\n负逻辑：低电平有效。\n逻辑代数的基本定律和规则逻辑函数的相等如果两个函数的真值表相等，则这两个函数一定相等。\n基本定律\n逻辑代数的三条规则\n代入规则。将一个等式中的某一变量使用一个逻辑函数式F代替，则等式仍然成立。\n由1可证明反演律对n个变量仍然适用。\n\n反演规则。\n注意：1.要保持原式的优先顺序。2.原式中不属于单变量上的非号不变。\n\n对偶规则。\n\n注意：1.要保持原式的优先顺序。2.原式中的长短非号不变。3.单变量的对偶式为自己\n对偶规则：若有两个逻辑表达式F和G相等，则各自的对偶式F’和G’也相等。\n\n\n逻辑代数的常用公式\n\n同或和异或：\n偶数个变量：同或和异或互为反函数。\n奇数个变量：同或和异或相等。\n\n同或功能常常使用异或门来实现。\n逻辑函数的标准形式最小项和最大项\n2）最小项编号：使该最小项的值为1所对应的等效十进制数。\n3）最小项的性质：\n\n变量任取一组值，仅有一个最小项为1，其他最小项为0； \nn变量的全体最小项之和为1\n不同的最小项相与，结果为0\n两最小项相邻，相邻最小项相“或”，可以合并成一 项，并可以消去一个变量因子。\n\n\n2）最大项编号：使该最小项的值为0所对应的等效十进制数。\n3）最大项的性质：\n\n变量任取一组值，仅有一个最大项为0，其它最大项为1\nn变量的全体最大项之积为0\n不同的最大项相或，结果为1\n两相邻的最大项相“与”，可以合并成一项，并可以消去一个变量因子\n\n编号下标相同的最小项和最大项互为反函数。\n标准与或式和标准或与式任一逻辑函数都可以表达为最小项之和的形式,而且是唯一的\n\n逻辑函数式与真值表化为最小项之和的形式，最小项对应的为1。\n逻辑函数的化简卡诺图化简法相邻的2的n次方的项进行合并，从相邻数最少的那个开始。每一次合并可以消去n个变量。\n圈和圈可以重叠。\n用卡诺图求反函数的最简与或式合并卡诺图中的0方格。\n可以用来求最简与或非式。\n不完全确定的逻辑函数及其化简无关项看为1，然后进行化简，但是在最后写的时候记得写无关项恒等的条件。\n第二章 逻辑门电路晶体管的开关特性在数字电路中,常将半导体二极管,三极管和场效应管作为开关元件使用。\n\n半导体二极管的开关特性硅二极管的导通条件及导通时的特点：\n大于0.7V导通，小于0.5V截止。\n\n硅二极管的开启和关断时间都很小。\n半导体三极管的开关特性\n\n开关时间和导通的深度成正比。\nCMOS门电路CMOS反相器：静态功率极小。\n\n\n\n\n\n本质上就是一个非门。\n第三章 组合逻辑电路组合逻辑电路：电路在任一时刻的输出状态仅由该时刻的输入信号决定,与电路在此信号输入之前的状态无关\n组合逻辑电路的分析分析方法分析步骤：\n\n通过电路图写出逻辑函数表达式\n通过逻辑函数表达式列出真值表。\n通过真值表或者表达式分析电路的功能。\n\n组合逻辑电路的设计设计方法设计步骤：\n\n由实际逻辑问题列出真值表\n由真值表写出逻辑表达式\n化简，变换输出表达式。\n画出逻辑图。\n\n组合逻辑电路中的冒险产生冒险的原因由于门电路延迟时间的关系，可能会使逻辑电路产生错误输出。通常把这种现象称为竞争冒险。\n电路存在由非门产生的互补信号，且互补信号的状态发生变化时有可能出现冒险现象。\n消去冒险的方法\n发现并消除互补变量\n增加乘积项\n\n第四章 常用组合逻辑功能器件中规模集成电路分别具有特定的逻辑功能,称为功能模块。\n自顶向下的模块化设计方法分层设计树\n分层方框图\n\n编码器将信息(如数和字符等)转换成符合一定规则的二进制代码\n二进制编码器用n位二进制代码对N=2的n次方个特定信息进行编码的逻辑电路。\n4线 — 2线编码器（将四个信息编码为一个2位二进制数）（4线中只允许有一个输入有效）\n\n带输出使能端的优先编码器输出使能端: 用于判别电路是否有信号输入（是一个输出信号，当没有任何信号输入时输出1，否则输出0）\n优先: 对输入信号按轻重缓急排序,当有多个信号同时输入时,只对优先权高的一个信号进行编码.\n该编码器所对应的真值表和逻辑电路图：\n\n二 — 十进制编码器输入: I0 ,I1,I2 … …I9,表示十个要求编码的信号.输出: BCD码.\n电路有十根输入线,四根输出线,常称为10线—4线编码器\n通用编码器集成电路8线—3线优先编码器74148\n1）74148为8线—3线优先编码器，HPRI是最高位优先编码器的说明。2）编码器输入为低电平有效，输出为3位二进制反码。3）EI非表示输入使能端，当EI非为0时电路正常工作，反之则电路禁止工作。（相当于编码器的开关（当输入0时编码器工作））（当电路禁止工作时，输出为111）4）EO非表示选通输出端，当EO非为0时表示电路在工作状态但是没有输入。（用于区分开电路禁止工作时无输入的情况（等于0的时候））\n5）GS非表示扩展输出端，当GS非为0时表示电路在工作状态并且至少存在一个输入。（用于标识电路处于工作状态并且有输入的情况）\n\n使用两块74148来构成一个16线 — 8线编码器：\n\n当II编码器工作时，EI非输入使能端为0将II编码器打开，此时如果存在输入，则EO非为1，同时将EO非接入下一片I编码器的输入使能端。将I编码器关闭。I编码器输出全为1。\n当II编码器工作时，如果有输入时，GS非的输出都为0。将GS非输出的0作为编码后的最高位，即0111中的0（低电平有效）。此时按照8线—3线编码器中将II编码器中的输入编码成为一个3位的二进制编码，和I编码器的111相与之后的结果加上最高位的0即为最终的编码。\n\n当I编码器工作时，II编码器的EI非端输入还为0，但是此时的II编码器的输入全为1，即无输入。此时II编码器的EO非输出为0，表示II编码器正在工作但是没有输入。此时输出的EO非输入到I编码器中的EI非中，将I编码器开启进行编码，此时的II编码器的所有输出都为111（低电平有效）。并且II编码器的GS非端的输出为1，即最高位此时为1（低电平有效）。I编码器将输入编码为一个三位二进制数后和II编码器中的111相与，即为最后编码的结果。\n10线—4线优先编码器74147\n\n译码器/数据分配器译码是编码的逆过程，作用是将一组码转换为确定信息。\n二进制译码器输入：二进制代码，有n个；输出：2n 个特定信息。\n\nLSB：最低有效位\nMSB：最高有效位\n高电平输出有效的二进制译码器的输出逻辑表达式为Yi = mi（mi为输入变量所对应的最小项）\n低电平输出有效的二进制译码器的输出逻辑表达式为Yi非 = mi非（mi为输入变量所对应的最小项）\n\n\n译码器的使能控制端1）利用使能输入控制端，既能使电路正常工作，也能使电路处于禁止工作状态；2）利用使能输入控制端，能实现译码器容量扩展。\n\n\n\n通用译码器集成电路带使能端3线—8线译码器 74138\n\n1）电路输出低电平有效2）G1，G2A非，G2B非的值分别为100，此时电路才进行工作，否则，电路禁止工作。电路输出均为1。\n\n数据分配器数据分配是将一个数据源输入的数据根据需要送到不同的输出端上去，实现数据分配功能的逻辑电路称为数据分配器。分配器又叫多路复用器。\n数据分配器一般用带使能控制端的二进制译码器实现。\n用74138作为数据分配器\n\n\n此时D即为数据源，通过CBA的编码来将D的数据分配到0~7的某一个出口处。\n译码器应用举例用译码器实现组合逻辑函数原理: 二进制译码器能产生输入信号的全部最小项,而所有组合逻辑函数均可写成最小项之和的形式\n\n\n\n计算机输入/输出接口地址译码电路\n数据选择器功能: 从多路输入数据中选择其中的一路送至输出端.数据选择器简称MUX,数据选择器的数据输入端数称为通道数\n\n","categories":["文化课"],"tags":[]},{"title":"ICPC沈阳打铁实录","url":"/63075","content":"","categories":[],"tags":[]},{"title":"离散数学复习笔记","url":"/10033","content":"第一章 命题逻辑1.1 命题命题是指非真必假的陈述句。疑问句祈使句，感叹句无法判断真假，都不是命题。（悖论和判断结果不唯一的陈述句也不是命题）\n命题用小写的英文字母表示。\n命题的真值指的是命题判断的结果。\n真值的取值：真和假\n原子命题：不能再分解为更简单的命题，这个命题称作原子命题。（简单命题）\n分子命题：由简单命题与联结词按一定规则复合而成的命题（复合命题）\n\n\n联结词与符合命题：\n\n否定式：非p（¬）\n\n合取式：p并且q（∧）\n\n析取式：p或q（∨）\n\n\n命题的否定是指对整体进行否定而不是对局部进行否定。\n析取：相容或(可兼或) &amp; 排斥或(不可兼或)\n\n\n","categories":["文化课"],"tags":[]},{"title":"JAVA入门","url":"/59533","content":"《Java编程思想》笔记\n记录了在阅读《Java编程思想》中感到需要记录下的一些新的东西。\n\n第一章 对象导论\n面向对象语言的五个基本特性之一： java程序是对象的集合，他们通过发送消息来告知彼此所需要做的。\n对象的简洁描述：对象具有状态，行为和标识。\n在面对对象程序设计中实际上进行的是创建新的数据类型。- \n不要把多有的功能都塞到一个类中。\njava程序开发人员被分为类创造者，和客户端程序员。\n类中被隐藏的部分通常代表对象内部脆弱的部分。\nprotected表示继承的类可以访问protected成员。\n不要总想着用继承，这会导师制难以使用并过分复杂的设计，应该首先考虑组合。\n当继承时，新的类型复制了基类的接口。\n前期绑定：在编译器产生的函数调用会将这个调用解析到将要被执行的代码的绝对地址。\n后期绑定：程序知道运行时才能够确定代码的地址。\n虚函数是后期绑定的体现。（Java中所有的函数都是虚函数）。\n把导出类看做是它的基类的过程称为向上转型\n单根继承结构：终极基类是Objective，单根继承结构使垃圾回收期的实现变得容易很多。\n将对象的引用放入容器内中时，它会被被向上转型为基类型，因此它会丢失身份。\n参数化类型（范型/范式）用来解决容器中保存特定类型的类的问题。\nJava完全采用了动态内存分配方式。\nJava的异常不会干扰正常的执行代码，异常提供了一种从错误状况进行可靠恢复的途径。\n之前的并发编程是通过编写中断服务程序，主进程的挂起是通过硬件的中断来触发的，缺少可移植性。Java的并发编程是内置于语言中的，线程只是一种为单一处理器分配执行时间的手段，如果一个操作系统支持多处理器，那么每个任务都可以被指派给不同的处理器。如果只有一个处理器，那么程序在逻辑上被分为线程。\n中间件：将负载分赛在服务器端的其他机器。（中间件也被用来提高可维护性）\n\n","categories":["技术"],"tags":["JAVA"]},{"title":"2021ccpc省赛总结","url":"/17211","content":"2021ccpc河南省省赛，算是大学第一场比较正规的acm比赛吧，最后过了4道题，有点危险的拿到了银。\n\n打完比赛之后和高中机房的邱宇同学沟通了一下，发现自己的成绩并不算很好，给高中丢人了。。\n一些感受吧：\n高中竞赛的失败导致对acm抱有复杂的感情，爱并且怕着。\n从初中开始接触算法竞赛，到现在已经有六七个年头了。这些年里写了好多的代码。一些题已经做了两遍三遍，忘记了，再做，有一些题，看到就想吐。为了拾起来之前的东西，去做哪些已经做了太多次的题，我已经无法从那些做过的题中找到学习新东西的乐趣了，这让我有一些恶心。\n但是我还是爱着acm的。\n解一道没做过的题之后的快乐，那是一种高级的喜悦。每一次体会这种快乐，都不会让我感到厌烦。\n这可能也是为什么喜欢做新题的原因吧。\n在这场比赛中，有两道题是由我完成的。这两道题，都是提交一遍然后AC，我觉得这个过程，还是十分的令人激动，并且快乐的。\n总结一下这场比赛：\n团队的问题：\n签到有点慢，开始之后要看榜，这场比赛3分钟左右才开始看榜，这时候就已经比其他人慢了。\n写题没有什么比较大的问题。\n到最后两道题有点乱，没有分配好要写哪道题。\n大家的DP都比较薄弱。\n以后比赛还是上午留着睡觉吧，不然大家的状态都不好，都感觉晕乎乎的。。。\n自己的问题：\nDP比较薄弱。\n对自己的代码没有自信。\n","categories":[],"tags":["赛后总结"]},{"title":"深度学习初探","url":"/25262","content":"二分分类什么是Logistic 回归？logistic 回归函数：来对一组输入做一个 0 ~ 1 的概率判断。\nx为输入的特征向量，得到的回归函数值为 sigma(w^(T) * x + b) ，参数为w和b，是一个在0和1中间的一个概率。sigma(z) 是  1 / 1 + e ^ (- z) 。\n损失函数：lost(y^, y) = - ( y log y^ + (1 - y) log(1 - y^) ) （其中y^为y的预测值）。越小越好。\n成本函数：J(w, b) = 1 / m * Σ lost(y^, y) = -1 / m * Σ(y log y^ + (1 - y)log(1 - y^)) 。为m组损失函数的平均值，越小越好。\n梯度下降法：w := w - αd(J(w, b)) / d(w) ，b := b - αd(J(w, b)) / d(b) 。α是学习率。\n梯度就是函数对变量的偏导。\n正向传播：用参数计算出函数的值\n反向传播：利用函数来计算每一个参数的导数\n对Logistic 回归的一组数据进行梯度下降法：\n\n\nLogistic 回归的Python实现对Logistic 回归的m组数据进行一次梯度下降法：\nJ = 0; dw1 = 0; dw2 = 0; db = 0;\nfor i = 1 to m\n    z(i) = wx(i)+b;\n    a(i) = sigmoid(z(i));\n    J += -[y(i)log(a(i))+(1-y(i)）log(1-a(i));\n    dz(i) = a(i)-y(i);\n    dw1 += x1(i)dz(i);\n    dw2 += x2(i)dz(i);\n    db += dz(i);\nJ /= m;\ndw1 /= m;\ndw2 /= m;\ndb /= m;\nw = w - alpha * dw\nb = b - alpha * db\n\n如何减少循环的次数？使用向量化来减少显式For循环。\nimport numpy as np #导入numpy库\na = np.array([1,2,3,4]) #创建一个数据a\nprint(a)\nimport time #导入时间库\na = np.random.rand(1000000)\nb = np.random.rand(1000000) #通过round随机得到两个一百万维度的数组\ntic = time.time() #现在测量一下当前时间\n#向量化的版本\nc = np.dot(a,b) #对a，b进行矩阵乘法\ntoc = time.time()\nprint(“Vectorized version:” + str(1000*(toc-tic)) +”ms”) #打印一下向量化的版本的时间\n#继续增加非向量化的版本\nc = 0\ntic = time.time()\nfor i in range(1000000):\n    c += a[i]*b[i]\ntoc = time.time()\nprint(c)\nprint(“For loop:” + str(1000*(toc-tic)) + “ms”)#打印for循环的版本的时间\n\n通过使用numpy中的函数来进行向量运算从而减少显式For循环。\n可以使用向量化完全消除显式的For循环：\nZ = np.dot(w.T, x)+b\nA = σ(Z)\ndZ = A − Y\ndw = 1 / m ∗ X ∗ dZ.T\ndb = 1 / m ∗ np.sum(dZ)\nw = w − α ∗ dw\nb = b − α ∗ db\n\n\n现在我们利用前五个公式完成了前向和后向传播，也实现了对所有训练样本进行预测和求导，再利用后两个公式，梯度下降更新参数。我们的目的是不使用for循环，所以我们就通过一次迭代实现一次梯度下降，但如果你希望多次迭代进行梯度下降，那么仍然需要for循环，放在最外层。不过我们还是觉得一次迭代就进行一次梯度下降，避免使用任何循环比较舒服一些。\n\n学习进度：吴恩达深度学习课程第一课前两周课（24节）\n浅层神经网络什么是双层神经网络？神经网络的大致组成：输入层，隐藏层，输出层。\nlogistic 回归只有输入层和输出层。\n双层神经网络的两层是指隐藏层和输出层，输入层不算。（也可以叫单隐层神经网络）\n\n\n上图是一个双层神经网络的示意图。\n对比一般的Logistic 回归，对于一组输入来说，双层神经网络有多个a在第一层的输出到第二层去。在输出层中，输入是隐藏层中运算得到的a值，输出是经过Logistic 回归得到的最终值。\n\n上图是隐藏层中一个神经元的具体构造。\n同时我们也希望可以将这个双层神经网络进行向量化从而来简化我们的运算。\n如何将双层神经网络进行向量化？\n该图将一组数据进行了向量化，通过上图的运算，可以更快地得出一组数据经过一次双层神经网络处理的结果。\n\n如图的操作可以将多组数据进行向量化运算，即，经过一次操作对多组输入进行一次双层神行网络处理。\n如何选择激活函数？常见的激活分类有：σ函数，tanh函数，ReUL函数，Leaky Relu函数。\n对于tanh函数，是由σ函数向下平移和伸缩后得到的。相比于σ函数，数据的平均值更接近0，这会使下一层学习简单一点。\n\n选用适合的激活函数可以加快机器学习的速度，常用的Relu函数的优点如下：\n\n第一，在 z 的区间变动很大的情况下，激活函数的导数或者激活函数的斜率都会远大于0，在程序实现就是一个if-else语句，而sigmoid函数需要进行浮点四则运算，在实践中，使用ReLu激活函数神经网络通常会比使用sigmoid或者tanh激活函数学习的更快。\n第二，sigmoid和tanh函数的导数在正负饱和区的梯度都会接近于0，这会造成梯度弥散，而Relu和Leaky ReLu函数大于0部分都为常数，不会产生梯度弥散现象。(同时应该注意到的是，Relu进入负半区的时候，梯度为0，神经元此时不会训练，产生所谓的稀疏性，而Leaky ReLu不会有这问题)\n z 在ReLu的梯度一半都是0，但是，有足够的隐藏层使得z值大于0，所以对大多数的训练数据来说学习过程仍然可以很快。\n\n概括一下不同激活函数的过程和结论：\n\nsigmoid激活函数：除了输出层是一个二分类问题基本不会用它。\ntanh激活函数：tanh是非常优秀的，几乎适合所有场合。\nReLu激活函数：最常用的默认函数，，如果不确定用哪个激活函数，就使用ReLu或者Leaky ReLu。公式 a = max( 0.01 z , z ) 为什么常数是0.01？当然，可以为学习算法选择不同的参数。（注意ReLu函数是非线性的）\n\n注意：在选择激活函数的时候，要选择非线性函数，因为多层线性函数的组合得到的结果还是线性的，那么神经网络只是把输入线性组合再输出。只有在做机器学习中的回归问题的时候才可能会选择线性函数作为激活函数。\n激活函数的导数对于常见的几种激活函数的导数：\n\nsigmoid函数 **σ(x) = a 的导数为 **a (1 - a)\ntanh函数 tanh(x) = a 的导数为 1 - a^2\nRelu函数 max(0, x) = a 的导数在 x &lt; 0 的时候为0， 在 x &gt; 0 的时候为1，在 x = 0 的时候没有定义，一般手动定义为 0 或者 1 。\nLeaky Relu函数 max(0,01x, x) = a 的导数在 x &lt; 0 的时候为 0,01 ， 在 x &gt; 0 的时候为1，在 x = 0 的时候没有定义，一般手动定义为 0 或者 1 。\n\n双层神经网络的梯度下降法（反向传播的实现）由以上学习可知双层神经网络的正向传播就是按照所给的基本公式进行计算，而反向传播可以在每一轮中对模型中的参数进行调整。\n\n反向传播与普通Logistic回归不同的地方在于计算第一层的dz时的差别。\n\n这里np.sum是python的numpy命令，axis=1表示水平相加求和，keepdims是防止python输出那些古怪的秩数 ( n , )，加上这个确保矩阵 db[ 2 ] 这个向量输出的维度为 ( n , 1 ) 这样标准的形式。\n\n随机初始化为什么在Logistic回归中不能将W数组的初始化定为0？\n因为这样的话在第一层中的神经元就会计算出相同的结果，这样\n","categories":["技术"],"tags":[]},{"title":"河南大学暑假集训的日常（4）","url":"/43344","content":"DAY7（DP进阶）POJ - 2342 Anniversary party（树形DP）\n入门树形DP。\n用vector将边存下来，然后将一个点作为树的根节点进行dp，d[x][0]表示编号为x的员工不参加的愉悦值，d[x][1]表示编号为x的员工参加的愉悦值。v节点表示x节点所连的边，转移方程为：d[x][1] += d[v][0]; d[x][0] += max(d[v][1], d[v][0]); \n代码：\n#include&lt;vector>\n#include&lt;iostream>\n#include&lt;cmath>\n#include&lt;algorithm>\n#include&lt;cstring>\n#include&lt;string>\n#define endl '\\n'\nusing namespace std;\ntypedef long long ll;\nconst ll maxn = 6010;\nll n, u, v;\nll d[maxn][2];\nbool vis[maxn];\nvector&lt;int> son[maxn];\nvoid dfs(int x) {\n    vis[x] = 1;\n    for (int i=0;i&lt;son[x].size();++i) {\n        int v = son[x][i];\n        if (!vis[v]) {\n            dfs(v);\n            d[x][1] += d[v][0];\n            d[x][0] += max(d[v][1], d[v][0]);\n        }\n    }\n}\nint main() {\n    while(cin >> n) {\n        memset(d, 0, sizeof(d));\n        memset(vis, 0, sizeof(vis));\n        for (int i=1;i&lt;=n;++i) {\n            cin >> d[i][1];\n            d[i][0] = 0;\n            son[i].clear();\n        }\n        while(cin >> u >> v &amp;&amp; !(u == 0 &amp;&amp; v == 0)) {\n            son[u].push_back(v);\n            son[v].push_back(u);\n        }\n        dfs(1);\n        cout &lt;&lt; max(d[1][0], d[1][1]) &lt;&lt; endl;\n    }\n    return 0;\n}\n\nLibreOJ - 10156 战略游戏（树形DP）\n和上一道题很像，d[x][0]表示x站点处没有哨兵所需要的消耗，d[x][1]表示x站点处有哨兵所需要的消耗。转移方程做了一点小小的改动： d[x][0] += d[v][1]; d[x][1] += min(d[v][1], d[v][0]); \n代码：\n#include&lt;vector>\n#include&lt;iostream>\n#include&lt;cmath>\n#include&lt;algorithm>\n#include&lt;cstring>\n#include&lt;string>\n#define endl '\\n'\nusing namespace std;\ntypedef long long ll;\nconst ll maxn = 6010;\nll n, u, v, k;\nll d[maxn][2];\nbool vis[maxn];\nvector&lt;int> son[maxn];\nvoid dfs(int x) {\n    vis[x] = 1;\n    for (int i=0;i&lt;son[x].size();++i) {\n        int v = son[x][i];\n        if (!vis[v]) {\n            dfs(v);\n            d[x][0] += d[v][1];\n            d[x][1] += min(d[v][1], d[v][0]);\n        }\n    }\n}\nint main() {\n    while(cin >> n) {\n        memset(d, 0, sizeof(d));\n        memset(vis, 0, sizeof(vis));\n        for (int i=1;i&lt;=n;++i) {\n            cin >> u >> k;\n            d[u][1] = 1;\n            d[u][0] = 0;\n            for (int i=1;i&lt;=k;++i) {\n                cin >> v;\n                son[u].push_back(v);\n                son[v].push_back(u);\n            }\n        }\n        dfs(0);\n        cout &lt;&lt; min(d[0][0], d[0][1]) &lt;&lt; endl;\n    }\n    return 0;\n}\n\n","categories":["竞赛"],"tags":[]},{"title":"河南大学暑假集训的日常（3）","url":"/56657","content":"DAY5（线段树）HDU - 1394 Minimum Inversion Number（树状数组/线段树）\n和昨天的题撞了，用树状数组求数列的逆序对。\n代码：\n#include&lt;iostream>\n#include&lt;algorithm>\n#include&lt;cmath>\n#include&lt;cstdio>\n#include&lt;cstring>\n#include&lt;string>\n#define TobinMEng caicai\n#define int ll\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 5010;\nint n, a[maxn &lt;&lt; 2], f[maxn &lt;&lt; 2];\nint tmp, ans;\ninline int lowbit(int x) {return -x&amp;x;}\nvoid update(int x, int v) {for (; x&lt;=n; x+=lowbit(x))f[x] += v;}\nint ask(int x, int res = 0) {for (; x>=1;x-=lowbit(x)) res += f[x];return res;}\nsigned main() {\n    while(scanf(\"%d\", &amp;n) != EOF) {\n        memset(a, 0, sizeof(a));\n        memset(f, 0, sizeof(f));\n        tmp = ans = 0;\n        for (int i=1;i&lt;=n;++i) {\n            scanf(\"%d\", &amp;a[i]);\n            a[i]++; \n            update(a[i], 1);\n            tmp += (i - ask(a[i]));\n        }\n        ans = tmp;\n        for (int i=1;i&lt;n;++i) {\n            tmp += (n - 2 * a[i] + 1);\n            ans = min(ans, tmp);\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n\nHDU - 1698 Just a Hook（线段树）\n是一个将区间覆盖修改为一个相同的数并维护区间的和的一个线段树板子题。\n代码：\n#include&lt;iostream>\n#include&lt;cstdio>\n#include&lt;cstring>\n#define int long long\nusing namespace std;\nconst int maxn = 200010;\nint n, m, T, l, r, v;\nstruct SegmentTree {\n    int l, r;\n    int dat, add;\n    #define l(p) tree[p].l\n    #define r(p) tree[p].r\n    #define dat(p) tree[p].dat\n    #define add(p) tree[p].add\n}tree[maxn &lt;&lt; 2];\ninline int Read() {\n    int x=0,f=1;char ch=getchar();\n    while(ch>'9'||ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\ninline void update(int p) {dat(p) = dat(p &lt;&lt; 1) + dat((p &lt;&lt; 1) | 1);}\ninline void spread(int p) {\n    if (add(p)) {\n        add(p &lt;&lt; 1) =  add(p);\n        add((p &lt;&lt; 1) | 1) = add(p);\n        dat(p &lt;&lt; 1) = add(p) * (r(p &lt;&lt; 1) - l(p &lt;&lt; 1) + 1);\n        dat((p &lt;&lt; 1) | 1) = add(p) * (r((p &lt;&lt; 1) | 1) - l((p &lt;&lt; 1) | 1) + 1);\n        add(p) = 0;\n    }\n}\nvoid build(int p, int l, int r) {\n    l(p) = l; r(p) = r; add(p) = 0;\n    if (l == r) {dat(p) = 1;return;}\n    int mid = (l + r) >> 1;\n    build(p &lt;&lt; 1, l, mid);\n    build((p &lt;&lt; 1) | 1, mid + 1, r);\n    update(p);\n}\nvoid change(int p, int l, int r, int v) {\n    if (l &lt;= l(p) &amp;&amp; r(p) &lt;= r) {\n        dat(p) = v * (r(p) - l(p) + 1);//对于区间覆盖修改的值和区间加减修改的值是有区别的。\n        add(p) = v;\n        return;\n    }\n    spread(p);\n    int mid = (l(p) + r(p)) >> 1;\n    if (l &lt;= mid) change(p &lt;&lt; 1, l, r, v);\n    if (r > mid) change((p &lt;&lt; 1) | 1, l, r, v);\n    update(p);\n}\nsigned main() {\n    T = Read();\n    for (int t=1;t&lt;=T;++t) {\n        n = Read(); m = Read();\n        build(1, 1, n);\n        for (int i=1;i&lt;=m;++i) {\n            l = Read(); r = Read(); v = Read();\n            change(1, l, r, v);\n        }\n        printf(\"Case %lld: The total value of the hook is %lld.\\n\", t, dat(1));\n    }\n}\n\nHDU - 1754 I Hate It （线段树）\n单点修改+区间最值线段树模板\n代码：\n#include&lt;iostream>\n#include&lt;algorithm>\nusing namespace std;\nconst int maxn = 2000010;\nint n, m, l, r;\nint a[maxn];\nchar od[5];\nstruct node {\n    int l, r;\n    int dat, add; \n    #define l(x) tree[x].l\n    #define r(x) tree[x].r\n    #define dat(x) tree[x].dat\n}tree[maxn &lt;&lt; 2];\ninline int Read() {\n    int x=0,f=1;char ch=getchar();\n    while(ch>'9'||ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\ninline void update(int p) {dat(p) = max(dat(p&lt;&lt;1), dat(p&lt;&lt;1|1));}\nvoid build(int p, int l, int r) {\n    l(p) = l; r(p) = r;\n    if (l == r)    {dat(p) = a[l];return;}    \n    int mid = (l + r) >> 1;\n    build(p &lt;&lt; 1, l, mid);\n    build(p &lt;&lt; 1 | 1, mid + 1, r);\n    update(p);\n}\nvoid init() {\n    for (int i=1;i&lt;=n;++i)    a[i] = Read();\n    build(1, 1, n);\n}\nvoid change(int p, int x, int v) {\n    if (l(p) == r(p)) {\n        dat(p) = v;\n        return;\n    }\n    int mid = (l(p) + r(p)) >> 1;\n    if (x &lt;= mid) change(p &lt;&lt; 1, x, v);\n    if (x > mid) change(p &lt;&lt; 1 | 1, x, v);\n    update(p);\n}\nint ask(int p, int l, int r) {\n    if (l &lt;= l(p) &amp;&amp; r(p) &lt;= r)    return dat(p);\n    int mid = (l(p) + r(p)) >> 1;\n    int res = 0;\n    if (l &lt;= mid) res = max(res, ask(p &lt;&lt; 1, l, r));\n    if (r > mid) res = max(res, ask(p &lt;&lt; 1 | 1, l, r));\n    return res;\n}\nint main() {\n    while(scanf(\"%d%d\", &amp;n,&amp;m) != EOF) {\n        init(); \n        for (int i=1;i&lt;=m;++i) {\n            scanf(\"%s\", od);\n            l = Read(); r = Read();\n            if (od[0] == 'Q') printf(\"%d\\n\", ask(1, l, r));\n            else change(1, l, r);\n        }\n    }\n    return 0;\n}\n\nHDU - 1166 敌兵布阵（树状数组）\n一个简单的树状数组，区间加减，区间求和\n代码：\n#include&lt;iostream>\n#include&lt;cstdio>\n#include&lt;string>\n#include&lt;cstring>\ntypedef long long ll;\nusing namespace std;\nconst int maxn = 50010;\nint T, n, l, r;\nint a[maxn], c[maxn];\nstring od;\ninline int Read() {\n    int x=0,f=1;char ch=getchar();\n    while(ch>'9'||ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\ninline int ask(int x, int res = 0) {for (; x>=1; x-=(x&amp;-x))    res += c[x];return res;}\ninline void update(int x, int v) {for (; x&lt;=n; x+=(x&amp;-x)) c[x] += v;}\ninline int query(int l, int r) {return ask(r) - ask(l - 1);}\ninline void init() {\n    n = Read();\n    memset(c, 0, sizeof(c));\n    memset(a, 0, sizeof(a));\n    for (int i=1;i&lt;=n;++i) {\n        a[i] = Read();    \n        update(i, a[i]);\n    }\n}\nint main() {\n    T = Read();\n    for (int i=1;i&lt;=T;++i) {\n        init();\n        printf(\"Case %d:\\n\", i);\n        while(cin >> od &amp;&amp; od != \"End\") {\n            l = Read(); r = Read();\n            if (od == \"Add\") update(l, r);\n            if (od == \"Sub\") update(l, -r);\n            if (od == \"Query\") printf(\"%d\\n\", query(l, r));\n        }\n    }\n    return 0;\n} \n\nDAY6（DP入门）LibreOJ - 10147 石子合并（区间DP）\n经典区间DP。\n数组复制到2n保证成环，枚举区间长度，然后遍历每一个区间，每一个区间由该区间中间分开成的两个区间转移过来，f[i][j]表示i到j区间上进行合并的最大或者最小消耗是多少。转移方程为f1[l][r] = min(f1[l][r], f1[l][k] + f1[k+1][r]); f1[l][r] += sum[r] - sum[l-1];\n代码：\n# include &lt;iostream>\n# include &lt;cstring>\n# include &lt;cstdio>\n# include &lt;algorithm>\nusing namespace std;\nconst int INF = 99999999;\nint f1[205][205], f2[205][205], a[205], sum[205];\nint n, ans1 = INF, ans2 = 0;\n\nint main() {\n    scanf(\"%d\", &amp;n);\n    for (int i=1;i&lt;=n;++i) {\n        scanf(\"%d\", &amp;a[i]);\n        a[i+n] = a[i];\n    }\n    memset(f1, 0x3f, sizeof(f1));\n    for (int i=1;i&lt;=n*2;++i) {\n        f1[i][i] = 0;\n        sum[i] = sum[i-1] + a[i];\n    }\n    for (int len=2;len&lt;=n;++len) {\n        for (int l=1;l&lt;=n*2-len+1;++l) {\n            int r = l + len - 1;\n            for (int k=l;k&lt;r;++k) {\n                f1[l][r] = min(f1[l][r], f1[l][k] + f1[k+1][r]);\n                f2[l][r] = max(f2[l][r], f2[l][k] + f2[k+1][r]);\n            }\n            f1[l][r] += sum[r] - sum[l-1];\n            f2[l][r] += sum[r] - sum[l-1];\n        }\n    }\n    for (int i=1;i&lt;=n;++i) {\n        ans1 = min(ans1, f1[i][i+n-1]);\n        ans2 = max(ans2, f2[i][i+n-1]);\n    }\n    printf(\"%d\\n%d\\n\", ans1, ans2);\n    return 0;\n}\n\nHDU - 1257 最少拦截系统（LIS）\n最长上升子序列的板子题。\n该题要求一个序列的最长不下降子序列的个数，可以转化为求一个序列的最长上升子序列的长度。该写法时间复杂度O(n^2)。有nlogn的写法，暂时不想去复习:)\n代码：\n#include&lt;iostream> \n#include&lt;algorithm>\n#include&lt;cmath>\n#include&lt;cstring>\nusing namespace std;\ntypedef long long ll;\nconst ll maxn = 30010; \nll a[maxn], d[maxn];\nll n, ans;\nint main() {\n    while(~scanf(\"%d\", &amp;n)) {\n        ans = 0;\n        for (int i=1;i&lt;=n;++i)    scanf(\"%d\", &amp;a[i]);\n        for (int i=1;i&lt;=n;++i) {\n            d[i] = 1;\n            for (int j=1;j&lt;i;++j) {\n                if (a[j] &lt; a[i])\n                    d[i] = max(d[j] + 1, d[i]);\n                ans = max(ans, d[i]);\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n\nHDU - 1176 Bone Collector（01背包）\n经典01背包板子题。\n代码：\n#include&lt;iostream> \n#include&lt;algorithm>\n#include&lt;cmath>\n#include&lt;cstring>\nusing namespace std;\ntypedef long long ll;\nconst ll maxn = 1010;\nll T, n, v;\nll w[maxn], c[maxn], d[maxn];\nint main() {\n    scanf(\"%lld\", &amp;T);\n    while(T--) {\n        scanf(\"%lld%lld\", &amp;n, &amp;v);\n        memset(w, 0, sizeof(w));\n        memset(c, 0, sizeof(c));\n        memset(d, 0, sizeof(d));\n        for (int i=1;i&lt;=n;++i)    scanf(\"%lld\", &amp;c[i]);\n        for (int i=1;i&lt;=n;++i)    scanf(\"%lld\", &amp;w[i]);\n        for (int i=1;i&lt;=n;++i) {\n            for (int j=v;j>=w[i];--j) {\n                    d[j] = max(d[j], d[j-w[i]]+c[i]);\n            }\n        }\n        printf(\"%lld\\n\", d[v]);\n    }\n    return 0;\n}\n\nHDU - 2084 数塔（DP）\n经典入门DP\n代码：\n#include&lt;iostream> \n#include&lt;algorithm>\n#include&lt;cmath>\n#include&lt;cstring>\nusing namespace std;\nint n, T;\nint a[110][110];\nint d[110][110];\nvoid work() {\n    memset(a, 0, sizeof(a));\n    memset(d, 0, sizeof(d));\n    scanf(\"%d\", &amp;n);\n    for (int i=1;i&lt;=n;++i) {\n        for (int j=1;j&lt;=i;++j) {\n            scanf(\"%d\", &amp;a[i][j]);\n            d[i][j] = max(d[i-1][j-1] + a[i][j], d[i-1][j] + a[i][j]);\n        }\n    }\n    int ans = 0;\n    for (int i=1;i&lt;=n;++i)    ans = max(ans, d[n][i]);\n    printf(\"%d\\n\", ans);\n}\nint main() {\n    scanf(\"%d\", &amp;T);\n    while(T--) work();\n    return 0;\n}\n\n","categories":["竞赛"],"tags":[]},{"title":"Spring Boot入门","url":"/12868","content":"一、String Boot入门1、Spring Boot简介\n简化spring应用开发的一个框架；整个Spring技术栈的一个大整合；J2EE开发的一站式解决方案；\n\n2、微服务2014，martin fowler微服务：架构风格（服务微化）一个应用应该是一组小型服务；可以通过HTTP的方式进行互通；\n每一个功能元素最终都是一个可独立替换和独立升级的软件单元；\n环境约束-jdk1.8-maven3.3.9-IDEA-Spring Boot 1.5.9\n","categories":[],"tags":[]},{"title":"TobinMEng的代码模板大合集","url":"/58095","content":"代码模板。\n巨长的代码模板。\n拿来了高中的代码模板然后持续更新。\n图论图图的储存和插入int head[maxn], ver[maxm], Next[maxm], edge[maxm], tot;\ninline void adde(int x, int y, int v) {\n    Next[++tot] = head[x]; head[x] = tot;\n    ver[tot] = y; edge[tot] = v;\n} \n\n连通块的划分（图的染色）void dfs(int x) {\n    color[x] = cnt;\n    for (int i=head[x]; i; i=Next[i]) {\n        int y = ver[i];\n        if (color[y]) continue;\n        dfs(y);\n    }\n}\nfor (int i=1;i&lt;=n;++i) {\n    if (!color[i]) {\n        cnt++;\n        dfs(i);\n    }\n}\n\nBFS遍历一个树/图void bfs() {\n    queue&lt;int> q;\n    memset(d, 0, sizeof(d));//如果搜索的是一棵树的话， 那么d数组指的是节点x在树中的深度。如果是一张图的话， d数组指的是x的层次， （从起点1走到x所要经历的最少点数）。\n    q.push(1); d[1] = 1;\n    while(q.size()) {\n        int x = q.front(); q.pop();\n        for (int i=head[x]; i; i=Next[i]) {\n            int y = ver[i];\n            if (d[y]) continue;\n            d[y] = d[x] + 1;\n            q.push(y);\n        }\n    }\n}//bfs有两个重要的性质， 1.在访问过所有的第i层节点之后，才会开始访问i+1层节点2.任意时刻，队列里只会出现i层的节点和i+1层的节点，并且所有的第i层节点都在第i+1层节点之前。（简单来说就是满足“两端性”和“单调性”）\n//并且dfs的时间复杂度和bfs的时间复杂度是相同的， 都为O(n+e)的时间复杂度，只不过限制两个算法的一个是堆栈大小， 一个是队列的大小\n\nDijkstra简单的正确性证明\nvoid Dijkstra(int x) {\n    priority_queue&lt;pair&lt;ll ll> > q;\n    for (int i=1;i&lt;=n;++i)    dis[i] = INF, vis[i] = false;\n    dis[x] = 0;\n    q.push(make_pair(0, x));\n    while(q.size()) {\n        int x = q.top().second;    q.pop();\n        if (vis[x]) continue;\n        vis[x] = true;\n        for (int i=head[x]; i; i=Next[i]) {\n            int y = ver[i], w = edge[i];\n            if (dis[y] > dis[x] + w) {//由于是拿出现在堆中最小的点x来更新其相邻的点， 所以写的顺序需要注意\n                dis[y] = dis[x] + w;\n                q.push(make_pair(-dis[y], y));\n            }\n        }\n    }\n}//适用于有向图和无向图中，只适用于边长不为负的图。时间复杂度为O((n+m)log(n));\n\nSPFA\nvoid SPFA(int x) {\n    queue&lt;int> q;\n    for (int i=1;i&lt;=n;++i)    dis[i] = INT, vis[i] = false;\n    dis[x] = 0; q.push(x); vis[x] = true;\n    while (q.size()) {\n        int x = q.front();\n        q.pop(); vis[x] = false;//vis表示该点是否在队列中\n        for (int i=head[x];i;i=Next[i]) {\n            int y = ver[i], w = edge[i];\n            if (dis[y] > dis[x] + w) {\n                dis[y] = dis[x] + w;\n                if (vis[y] == false) {\n                    vis[y] = true;\n                    q.push(y);\n                }\n            }\n        }\n    }\n}//适用于有向图和无向图中，可以计算负权图，可以用来判断负环。时间复杂度为O(nm);\n\nFloyedvoid Floyed() {\n    for (int k=1;k&lt;=n;++k) \n        for (int i=1;i&lt;=n;++i) \n            for (int j=1;j&lt;=n;++j) \n                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n}//多源最短路，可以有负权边。适用于大部分的情况。但是时间复杂度高达O(n³)。\n\nKruskalstruct node {\n    ll x, y, v;\n    friend bool operator &lt; (const node&amp;a, const node&amp;b) {\n        return a.v &lt; b.v;\n    }\n}e[maxm];\nvoid Kruskal() {\n    for (int i=1;i&lt;=n;++i)    f[i] = i;\n    int cnt = 0;\n    sort(e+1, e+1+m);\n    for (int i=1;i&lt;=m;++i) {\n        int a = find(e[i].x), b = find(e[i].y);\n        if (a == b)    continue;\n        else {\n            ans += e[i].v;\n            f[b] = a;\n            ++cnt;\n        }\n        if (cnt == n - 1)    break;\n    }\n}//这个是求出最小生成树的所有边的权值和， 其实可以可以在计算所有边的权值和的同时从新建一棵最小生成树\n\n并查集void init() {\n    for (int i=1;i&lt;=n;++i) f[i] = i;\n}//使用并查集的初始化\nint find(int x) {\n    return (f[x] == x) ? x : f[x] = find(f[x]);\n}//进行路径压缩的并查集\nvoid un(int x, int y) {\n    int a = getf(x), b = getf(y);\n    if (a == b) return;\n    else f[b] = a;\n}\n\n拓扑排序void Topsort() {\n    queue&lt;int> q;\n    for (int i=1;i&lt;=n;++i) {\n        if (du[i] == 0) {\n            q.push(i);\n        }\n    }//找到入度为0的点， 入队\n    while(q.size()) {\n        int x = q.front(); q.pop();\n        a[++tot] = x;\n        for (int i=head[x]; i; i=Next[i]) {\n            if (--du[ver[i]] == 0) {\n                a[++tot] = ver[i];\n                q.push(ver[i]);\n            }\n        }\n    }\n}//有向图中使用，记清楚！必须是有向图。显然的是，在进行完成拓扑排序之后，图中还留下来的东西就是一些环。即tot != n;\n//算法的应用：1.有向图找环（无向图是不能使用拓扑排序的）\n\n二分图最大匹配bool find(int x) {\n    for (int i=1;i&lt;=m;++i) {  \n        if (Link[x][i] &amp;&amp; !used[i]) {\n            used[i] = true;\n            if (girl[i] == 0 || find(girl[i])) {\n                girl[i] = x;\n                 return true;   \n            }\n        }\n    }\n    return false;\n}//其实就是在寻找增广路的过程\nint Maxmatch() {\n    int ans = 0;\n    for (int i=1;i&lt;=n;++i) {\n        memset(used, 0, sizeof(used));\n        if (find(i)) ++ans;\n    }\n    return ans;\n}//匈牙利算法如果使用邻接矩阵的话可以在O(n³)的时间内找到一个二分图的最大匹配数。空间复杂度是一个邻接矩阵(n²)。\n\nTarjan求强联通分量void Tarjan(int x) {\n    dfn[x] = low[x] = ++tim;\n    Stack[++top] = x;\n    vis[x] = true;\n    for (int i=head[x]; i; i=Next[i]) {\n        if (!dfn[ver[i]]) {\n            Tarjan(ver[i]);\n            low[x] = min(low[x], low[ver[i]]);\n        }else if (vis[ver[i]]) {\n            low[x] = min(low[x], dfn[ver[i]]);\n        }\n    }\n    if (dfn[x] == low[x]) {\n        int temp = 0;\n        ++cnt;//一个新的强联通块\n        do{\n            temp = Stack[--top];\n            color[temp] = cnt;//color里存的是第i个点属于第几个联通块\n            vis[temp] = false;\n        }while(x != temp);\n    }\n}\nint main() {\n    for (int i=1;i&lt;=n;++i) {\n        if (!vis[i])\n            tarjan(i);//因为这张图可能不连通\n    }\n}\n\n缩点void Tarjan() {\n    dfn[x] = low[x] = ++tim;\n    Stack[++top] = x;\n    vis[x] = true;\n    for (int i=head[x]; i; i=Next[i]) {\n        if (!dfn[ver[i]]) {\n            Tarjan(ver[i]);\n            low[x] = min(low[x], low[ver[i]]);\n        }else if (vis[ver[i]]) {\n            low[x] = min(low[x], dfn[ver[i]]);\n        }\n    }\n    if (low[x] == dfn[x]) {\n        int temp;\n        ++cnt;\n        do {\n            temp = Stack[top--];\n            color[temp] = cnt;\n            vis[y] = false;\n        }while(x != temp)\n    }\n}\n/*缩点，其实就是拿着邻接表，和强连通分量们来建一张新的图，在新的图中，点就是原来的强连通分量，边的具体操作有点复杂，现在具体说一说，大致意思就是：既然点都变成了强连通分量，那么边就应该在他们当中去连接不是吗?那什么和什么连？似乎可以看到，连接同一个强连通分量里的点是没有任何意义的，所以就好办了，跑一遍原邻接表，如果一条边（u，v,w）的u和v不在同一个强连通分量中，那么就在新图中连这条边，就这样点就缩好了。听起来也许有些玄幻，但是它就真真切切的完成了？！*/\nfor (int i=1;i&lt;=m;++i) {//一共m条边\n    if (color[a[i]] != color[b[i]]) {//如果两条边的两个端点不在一个强连通分量里面， 那么我们在这两个点之间连一条边\n        adde(color[a[i]], color[b[i]], z[i]);\n    }\n}\n//等于用剩下的信息建了一张新图\n\n树LCA树上倍增void bfs() {\n    t = log(n)/log(2);\n    queue&lt;int> q;\n    d[s] = 1;\n    q.push(s);\n    while(q.size()) {\n        int x = q.front(); q.pop();\n        for (int i=head[x]; i; i=Next[i]) {\n            int y = ver[i];\n            if (d[y]) continue;\n            d[y] = d[x]　＋ 1;\n            f[y][0] = x;\n            for (int j=1;j&lt;=t;++j) {\n                f[y][j] = f[f[y][j-1]][j-1];\n            }\n            q.push(y);\n        }\n    }\n}\nint lca(int x, int y) {\n    if (d[x] > d[y]) swap(x, y);\n    for (int i=t;i>=0;--i) {\n        if (d[f[y][i]] >= d[x])    y = f[y][i];\n    }\n    if (x == y) return x;\n    for (int i=t;i>=0;--i) {\n        if (f[y][i] != f[x][i]) x = f[x][i], y = f[y][i];\n    }\n    return f[x][0];\n}\n\nTarjan算法离线求LCAvoid init() {\n    int a, b;\n    for (int i=1;i&lt;n;++i) {\n        a = Read(); b = Read();\n        adde(a, b); \n        adde(b, a);\n    }//一棵树n-1条边\n    for (int i=1;i&lt;=k;++i) {\n        a = Read(); b = Read();\n        qadde(a, b);\n        qadde(b, a);\n    }//k个询问\n    for (int i=1;i&lt;=n;++i) f[i] = i;\n}\nvoid Tarjan(int x) {\n    vis[x] = true;\n    for (int i=head[x]; i; i=Next[i]) {\n        if (vis[ver[i]])  continue;\n        tarjan(ver[i]);\n        f[ver[i]] = x;\n    }\n    for (int i=qhead[x]; i; i=Next[i]) {\n        if (vis[qver[i]]) \n            ans[edge[i]] = getf(qver[i]);\n    }\n}\n\n树的直径void dp(int x) {\n    vis[x] = true;\n    for(int i=head[x]; i; i=Next[i]) {\n        int y = ver[i];\n        if (vis[y]) continue;\n        dp(y);\n        ans = max(ans, d[x] + d[y] + edge[i]);\n        d[x] = max(d[x], d[y] + edge[i]);//d数组的含义是从x节点出发走向x的子树， 所能到达的最远距离。\n        //那么树上最长链的距离即为从x到x的子节点yi的距离加上x到x的子节点yj的距离加上d[yi]再加上d[yj]即可\n        //d[x]中存的是从x走向他的前i个子节点最长的路径， 再加上当前的点到它子节点最长的路径即可得到x所在链的长度， 取一下max即为最长链的长度， 即为树的直径\n    }\n}\n\n树的重心void dfs(int x) {//树的重心的定义就是将该点删去之后所形成的最大的子树最小的那个点\n    vis[x] = true;\n    size[x] = 1;//子树x的大小\n    int max_part = 0;//删掉子树x后分成的最大子树的大小\n    for (int i=head[x]; i; i=Next[i]) {\n        int y = ver[i];\n        if (vis[y])    continue;\n        dfs(y);\n        size[x] += size[y];//从子节点向上更新\n        max_part = max(maxn_part, size[y]);//x的子节点中最大的那个节点的size\n    }\n        max_part = max(maxn_part, n - size[x]);//现在max_part中储存的是该节点删去之后形成的若干个子树最大的那个的大小 \n    //n - max_part里存的是x向上连接他的父亲节点的那一棵子树的大小。\n    if (max_part &lt; ans) {\n        ans = max_part;\n        pos = x;\n    }\n}\n\n树的各点子树的大小void dfs(int x) {\n    vis[x] = true;\n    size[x] = 1;\n    for (int i=head[x]; i; i=Next[i]) {\n        int y = ver[i];\n        if (vis[y]) continue;\n        dfs(y);\n        size[x] += size[y];\n    }\n}\n\n树的各点的深度void dfs(int x) {\n    vis[x] = true;\n    for (int i=head[x]; i; i=Next[i) {\n        int y = ver[i];\n        if (vis[y])    continue;\n        d[y] = d[x] + 1;\n        dfs(y);\n    }\n}\nvoid bfs(int x) {\n    memset(d, 0, sizeof(d));\n    queue&lt;int> q;\n    d[x] = 1; q.push(x);\n    while(q.size()) {\n        int x = q.front(); q.pop();\n        for (int i=head[x];i;i=Next[i]) {\n            int y = ver[i];\n            if (vis[y]) continue;\n            d[y] = d[x] + 1;\n            q.push(y);\n        }\n    }\n}\n\n数论基础数论求一个数二进制的每个1的位置int H[37];\nvoid bit(int n) {\n    for (int i = 0;i &lt; 36; ++i) H[(1ll &lt;&lt; i) % 37] = i;\n    while(n > 0) {\n        cout &lt;&lt; H[(n &amp; -n) % 37] &lt;&lt; ' ';\n        n -= n &amp; -n;\n    }\n    cout &lt;&lt; endl;\n}\nbit(9) // 0 3\n\nGcd 和 Lcmint gcd(int a, int b) {\n    return b? gcd(b, a%b) : a;\n}\nint lcm(int a, int b) {\n    return a / gcd(a, b) * b;\n}\n\n线性筛求素数ll prime[maxn], Size = 0;\nbool vis[maxn]; \ninline void init() {\n    memset(vis, true, sizeof(vis));\n    memset(prime, 0, sizeof(prime));\n    vis[1] = false;\n    for (int i=2;i&lt;=n;++i) {\n        if (vis[i]) prime[++Size] = i;\n        for (int j=1;j&lt;=Size&amp;&amp;i*prime[j]&lt;=n;++j) {\n            vis[i*prime[j]] = false;\n            if (i % prime[j] == 0)    break;\n        }\n    }\n}//时间复杂度O(n)\n\n素数判断bool is_prime(ll x) {\n    if (x == 2) return true; \n    for(int i=2;i&lt;=sqrt(p);++i) if(x % i == 0) return false;\n    return true;\n}\n\nEXGCDvoid Exgcd(int a, int b, int&amp; d, int&amp; x, int&amp; y) {\n    if (!b) {\n        x = 1;\n        y = 0;\n        d = a;\n        return;\n    }\n    int x1, y1;\n    Exgcd(b, a%b, d, x1, y1);\n    x = y1;\n    y = x1 - (a / b) * y1;  \n}\n\n求逆元//如果p是素数那么可以使用小费马定理\nint inv(int a, int p) {\n    return power(a, p - 2, p);    \n}\n//如果p不是素数那么可以使用EXgcd\nint inv(int a, int p) {\n    int x, y, d;\n    exgcd(a, p, d, x, y);\n    return d == 1 ? (a + p)% p : -1;\n}//如果返回-1则这个数没有逆元\n//如果要求出n以内所有在膜p情况下的的逆元,可以线性递推\nvoid inv(int n, int p) {\n    inv[1] = 1;\n    for (int i=2;i&lt;=n;++i) {\n        inv[i] = (p - p / i) * inv[p % i] % p;\n    }\n}\n\n快速幂int power(int a, int b, int p) {\n    int res = 1 % p;\n    for(; b; b >>= 1) {\n        if (b &amp; 1) res = (long long)res * a % p;\n        a =(long long)a * a % p;\n    }\n    return res;\n}\n\n龟速乘ll Mul(ll a, ll b, ll p) {\n    ll res = 0;\n    for(; b; b >>= 1) {\n        if (b &amp; 1) res = (res % p + a % p) % p;\n        a = (a &lt;&lt; 1) % p;\n    }\n    return res;\n}//可以防止两数相乘过大炸掉long long\n\n组合数学void init() {\n    memset(c, 0, sizeof(c));\n    c[1][0] = c[1][1] = 1;\n    for (int i=2;i&lt;=maxn;++i) {\n        c[i][0] = c[i][i] = 1;\n        for (int j=1;j&lt;i;++j) {\n            c[i][j] =(c[i-1][j] % mod + c[i-1][j-1] % mod)% mod;\n        }\n    }\n}\n\n矩阵乘法struct Mat {\n    a[maxn][maxn];\n}A, e;\nMat Mul(Mat x, Mat y) {\n    Mat c;\n    for (int i=1;i&lt;=n;++i)\n    for (int j=1;j&lt;=n;++j)\n        c.a[i][j] = 0;\n       for (int k=1;k&lt;=n;++k)\n    for (int i=1;i&lt;=n;++i)    \n    for (int j=1;j&lt;=n;++j)\n        c.a[i][j] = c.a[i][j] % mod + (x.a[i][k] * y.a[k][j] % mod) % mod;\n    return c;\n}\nMat power(Mat x, int p) {\n    Mat ans = e;\n    for (; b; b>>=1) {\n        if (b &amp; 1) ans = Mul(ans, a);\n        a = Mul(a, a);\n    }\n    return ans;\n}\n\n博弈论巴什博奕/*\n只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个，最后取光者得胜。\n结论：\n    n % (m + 1) == 0 后手必胜\n    n % (m + 1) != 0 先手必胜\n*/\n/*\n只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个，最后取光者得输。\n结论：\n    n % (m + 1) == 1 后手必胜\n    n % (m + 1) != 1 先手必胜\n*/\n\n威佐夫博奕/*\n有两堆各若干个物品为x,y，两个人轮流从任意一堆中取出至少一个或者同时从两堆中取出同样多的物品，规定每次至少取一个，至多不限，最后取光者胜利。\n*/\ninline bool check(int x, int y) {\n    int a = min(x, y), b = max(x, y);\n    double c = (double)abs(b - a);\n    double r = (sqrt(5.0) + 1) / 2;//1.618\n    int tmp = int(c * r);\n    if (a == tmp) return 0; //后手必胜 \n    else return 1; //先手必胜 \n}\n\n尼姆博奕/*\n有N堆石子。A B两个人轮流拿，A先拿。每次只能从一堆中取若干个，可将一堆全取走，但不可不取，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N及每堆石子的数量，问最后谁能赢得比赛。\n结论：\n    n个数字进行异或，如果结果 = 0，后手必胜。如果结果 != 0，先手必胜。\n*/\n\n斐波那契博弈/*\n有一堆个数为n的石子，游戏双方轮流取石子，满足：\n    （1）先手不能在第一次把所有的石子取完；\n    （2）之后每次可以取的石子数介于1到对手刚取的石子数的2倍之间（包含1和对手刚取的石子数的2倍）。 约定取走最后一个石子的人为赢家。\n结论：\n    当n为Fibonacci数时，先手必败。即存在先手的必败态当且仅当石头个数为Fibonacci数。 \n*/\n\n数据结构基本数据结构链表inline void init() {\n    a[1].pre = 0;\n    a[1].next = -1;\n    a[0].next = 1;\n    a[0].pre = -1;\n}\ninline void insert(int x, int k, int p) {\n    if (p == 1) {\n        a[x].pre = k;\n        a[x].next = a[k].next;\n        a[a[k].next].pre = x;\n        a[k].pre = x;\n    }else {\n        k = a[k].pre;\n        a[x].pre = k;\n        a[x].next = a[k].next;\n        a[a[k].next].pre = x;\n        a[k].next = x;\n    }\n    return;\n}//在k的前或者后面插入一个值为x的点\n//p == 1 时表示在k的后面插入了x\n//p == 0 时表示在k的前面插入了x\ninline void del(int x) {\n    if (a[x].pre != -1) {\n        a[a[x].pre].next = a[x].next;\n        a[a[x].next].pre = a[x].pre;\n        a[x].pre = -1;\n    }\n}\n//一个数的pre为-1表示这个点已经被删除\nfor (int i=a[0].next;i!=-1;i=a[i].next) {\n    //一个链表的遍历\n}\n\n队列//STL\nqueue&lt;int> q;\n\nq.push(x);\nq.pop();\nint x = q.front();\nint size = q.size();\nbool is_empty = q.empty();\n\n//手写一个队列\ninline void init(){\n    head = 0; tail = 0;\n    memset(q, 0, sizeof(q));\n}\ninline void push(int x) {q[++tail] = x;}\ninline void pop()        {head++;}\ninline int  front()        {return q[tail];}\ninline bool empty()        {return head >= tail;}\ninline int     size()        {return tail - head;}\n\n优先队列//STL\npriority_queue&lt;int> q;\npriority_queue&lt;int, vector&lt;int>, greater&lt;int> > q;\n\nq.push(x);\nq.pop();\nint x = q.top();\nint size = q.size();\nbool is_empty = q.empty();\n//不会手写\n\n栈stack&lt;int> s;\ns.push(x);\ns.pop();\nint x = s.top();\nbool is_empty = s.empty();\n\n单调队列\n\n单调栈\n\nST表inline int lowbit(int x) {return x &amp; (-x);}\ninline int query(int l, int r) {\n    int t = log(abs(r - l + 1)) / log(2);\n    return max(f[l][t], f[r - (1 &lt;&lt; t) + 1][t]);\n}\nvoid ST_init(int t = log(n) / log(2) + 1) {\n    rep(i, 1, n) f[i][0] = a[i];\n    rep(j, 1, t - 1) {\n        rep(i, 1, n - (1 &lt;&lt; j) + 1) {\n            f[i][j] = max(f[i][j - 1], f[i + (1 &lt;&lt; (j - 1))][j - 1]);\n        }\n    }\n}//RMQ的离线算法，O(nlogn)的预处理，O(1)的查询。\n\n树状数组inline void add(int x, int v) {\n    for (; x &lt;= n; x += x &amp; (-x))    c[x] += v;\n}\ninline int ask(int x) {\n    int res = 0;\n    for (; x; x -= x &amp; (-x))    res += c[x];\n    return x;\n}\ninline void init() {\n    for (int i=1;i&lt;=n;++i)    add(i, a[i]);\n}\ninline int sum(int x, int y) {\n    return ask(y) - ask(x - 1);\n}\nadd(x, v);//单点修改x加上v\nint sum = sum(a, b)//区间求和， 从a到b的区间\n//区间修改，区间求和\ninline void change(int l, int r, ll d) {\n        \n}\n\n线段树struct Segment {\n    int l, r;\n    ll dat, add;\n    #define l(x)    tree[x].l\n    #define r(x)    tree[x].r\n    #define dat(x)    tree[x].dat\n    #define add(x)    tree[x].add\n}tree[maxn &lt;&lt; 2];\nint a[maxn];\n\ninline void update(int p) {\n    dat(p) = dat(p&lt;&lt;1) + dat(p&lt;&lt;1|1);\n}\nvoid build(int p, int l, int r) {\n    l(p) = l; r(p) = r;\n    if (l == r) {dat(p) = a[l];return;}\n    int mid = (l + r) >> 1;\n    build(p&lt;&lt;1,    l, mid);\n    build(p&lt;&lt;1|1,mid+1, r);\n    update(p);\n}\nvoid spread(int p) {\n    if (add(p)) {\n        dat(p&lt;&lt;1) += add(p) * (r(p&lt;&lt;1) - l(p&lt;&lt;1) + 1);\n        dat(p&lt;&lt;1|1) += add(p) * (r(p&lt;&lt;1|1) - l(p&lt;&lt;1|1) + 1);\n        add(p&lt;&lt;1) += add(p);\n        add(p&lt;&lt;1|1) += add(p);\n        add(p) = 0;\n    }\n}\nvoid change(int p, int l, int r, int d) {\n    if (l &lt;= l(p) &amp;&amp; r >= r(p)) {\n        dat(p) += (long long)d * (r(p) - l(p) + 1);\n        add(p) += d;\n        return;\n    }\n    spread(p);\n    int mid = (l(p) + r(p)) >> 1;\n    if (l &lt;= mid)    change(p&lt;&lt;1, l, r, d);\n    if (r > mid)    change(p&lt;&lt;1|1, l, r, d);\n    update(p);\n}\nlong long ask(int p, int l, int r) {\n    if (l &lt;= l(p) &amp;&amp; r >= r(p))    return dat(p);\n    spread(p);\n    int mid = (l(p) + r(p)) >> 1;\n    long long res = 0;\n    if (l &lt;= mid)    res += ask(p&lt;&lt;1, l, r);\n    if (r > mid)    res += ask(p&lt;&lt;1|1, l, r);\n    return res;\n}\n\n分块void build() {\n    block = sqrt(n);\n    num = n / block;  if (n % block) num++;\n    for (int i=1;i&lt;=num;++i)\n        l[i] = (i - 1) * block + 1, r[i] = i * block;\n    r[num] = n;\n    for (int i=1;i&lt;=n;++i) {\n        a[i] = Read();\n        belong[i] = (i - 1) / block + 1;\n        sum[belong[i]] += a[i];\n    }\n}\nvoid add(int x, int y, int d) {\n    for (int i=x;i&lt;=min(x, r[belong[x]]);++i) \n        a[i] += d, sum[belong[i]] += d;\n    if (belong[x] != belong[y]) {\n        for (int i=l[belong[y]];i&lt;=y;++i)\n            a[i] += d, sum[belong[i]] += d;\n    }\n    for (int i=belong[x]+1;i&lt;=belong[y]-1;++i)\n        sum[i] += block * d, tag[i] +=d;\n}\nint ask(int x, int y) {\n    ll ans = 0;\n    for (int i=x;i&lt;=min(x, r[belong[x]]);++i) \n        ans += tag[belong[i]] + a[i];\n    if (belong[x] != belong[y]) {\n        for (int i=l[belong[y]];i&lt;=y;++i)\n            ans += tag[belong[i]] + a[i];\n    }\n    for (int i=belong[x]+1;i&lt;=belong[y]-1;++i)\n        ans += sum[i];\n    return ans;\n}\n\n字符串基本字符串算法Hash表unsigned long long h(char s[]) {\n    int len = strlen(s);\n    unsigned long long ans = 0;\n    for (int i=0;i&lt;len;++i) \n        ans += ans * 131 + (unsigned long long)(s[i] - 'a' + 1);\n    return ans;\n}\n\nKMPvoid prekmp() {\n    m = strlen(b + 1);\n    Next[1] = 0;\n    for (int i=2,j=0;i&lt;=m;++i) {\n        while(j &amp;&amp; b[i] != b[j + 1])j = Next[j];\n        if (b[i] == b[j + 1]) ++j;\n        Next[i] = j;\n    }\n}\nll kmp() {\n    n = strlen(a + 1); ans = 0;\n    for (int i=1,j=0;i&lt;=n;++i) {\n        while(j &amp;&amp; a[i] != b[j + 1])j = Next[j];\n        if (a[i] == b[j + 1]) ++j;\n        if (j == m) {\n            ++ans;\n            j = Next[j];\n        }\n    }\n    return ans;\n}\n\nManachervoid init() {\n    int len = strlen(str), j = 1;\n    s[0] = '$', s[1] = '#';\n    rep(i, 0, len-1) {\n        s[++j] = str[i];\n        s[++j] = '#';\n    }\n    s[++j] = '\\0';\n}\nint Manacher() {\n    int len = strlen(s);\n    int mx = 0, id = 0, ans = -1;\n    rep(i, 0, len - 1) {\n        if (mx>i) p[i]=min(mx-i, p[2*id-i]);else p[i] = 1;\n        while(i-p[i]>=0&amp;&amp;s[i+p[i]]==s[i-p[i]])p[i]++;\n        if(p[i]+i>mx) mx = p[i]+i, id = i;\n        ans = max(ans, p[i] - 1);\n    }\n    return ans;\n}\n\n搜索基本搜索算法Dfsvoid dfs(int x) {\n    if (x > n) {\n        ...\n        return;\n    }\n    ...\n    dfs(x + 1);\n}\n\nBfsvoid bfs(int x) {\n    queue&lt;int> q;\n    q.push(x);\n    while(q.size()) {\n        int x = q.front();\n        ...\n        q.push(...);\n    }\n}\n\n迭代加深\n\n其他常见思路二分//求小于等于x最大的那一个\ninline bool check(int x) {\n    if (...) return true;\n    else return false;\n}\nint work() {\n    int l = 0; r = max_n;\n    while(l &lt; r) {\n        int mid = (l + r + 1) >> 1;\n        if (check(mid))    l = mid;\n        else r = mid - 1;\n    }\n    return l;\n}\n//求大于等于x的最小的那一个\nint work() {\n    int l = 0; r = max_n;\n    while(l &lt; r) {\n        int mid = (l + r) >> 1;\n        if (check(mid)) r = mid;\n        else l = mid + 1;\n    }\n    return l;\n}\n\n预热模板开新题的模板#include&lt;bits/stdc++.h>\n#define rep(i, a, n) for (int i=a;i&lt;=n;++i)\n#define per(i, n, a) for (int i=n;i>=a;--i)\n#define endl '\\n'\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\nconst int maxn =\ninline void write(int x) {if(x > 9) write(x/10);putchar(x % 10 + '0');return;}\ninline int Read() {\n    int x=0,f=1;char ch=getchar();\n    while(ch>'9'||ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint main() {\n    \n    return 0;\n}\n\n#include &lt;iostream>\n#include &lt;cstdio>\n#include &lt;cstring>\n#include &lt;cmath>\n#include &lt;string>\n#include &lt;algorithm>\n#include &lt;queue>\n#include &lt;deque>\n#include &lt;map>\n#include &lt;set>\n#include &lt;vector>\n#include &lt;cstdlib>\n#include &lt;bitset>\n#include &lt;stack> \n#define rep(i, a, n) for (int i=a;i&lt;=n;++i)\n#define per(i, n, a) for (int i=n;i>=a;--i)\n#define endl '\\n'\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\nconst int maxn = \ninline void write(int x) {if(x > 9) write(x/10);putchar(x % 10 + '0');return;}\ninline int Read() {\n    int x=0,f=1;char ch=getchar();\n    while(ch>'9'||ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint main() {\n    return 0;\n}\n\n关联文件inline void send() {\n    freopen(\"1.in\",  \"r\",  stdin);\n    freopen(\"1.out\", \"w\", stdout);\n}\n\n快读freadll f[maxn], c[maxn], ans = 0, n, tmp;\nchar buf[1&lt;&lt;15], *fs, *ft;\ninline char getc(){return(fs==ft&amp;&amp;(ft=(fs=buf)+fread(buf,1,1&lt;&lt;15,stdin),fs==ft))?0:*fs++;}\ninline ll Read() {\n    ll x=0,f=1;char ch=getc();\n    while(ch>'9'||ch&lt;'0'){if(ch=='-')f=-1;ch=getc();}\n    while(ch>='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getc();}\n    return x*f;\n}\n\n","categories":["竞赛"],"tags":[]},{"title":"河南大学暑假集训的日常（2）","url":"/8528","content":"DAY3（并查集）HDU - 1213 How Many Tables（并查集）\n\n简单题。\n代码：\n#include&lt;iostream>\nusing namespace std;\nconst int maxn = 11000;\nint T, n, m, a, b;\nint f[maxn];\nint ans() {\n    int res = 0;\n    for (int i=1;i&lt;=n;++i) if (f[i] == i) res++;\n    return res;\n}\nint find(int x) {return (f[x] == x) ? x : f[x] = find(f[x]);} \nint main() {\n    cin >> T;\n    for (int i=1;i&lt;=T;++i) {\n        cin >> n >> m;\n        for (int i=1;i&lt;=n;++i)    f[i] = i;\n        for (int i=1;i&lt;=m;++i) {\n            cin >> a >> b;\n            int x = find(a), y = find(b);\n            f[y] = x;\n        }\n        printf(\"%d\\n\", ans());\n    }\n    return 0;\n}\n\nHDU - 3038 How Many Answers Are Wrong（带边权并查集）\n\n该题是一道时带边权的并查集。\n对于每一个节点，不仅要维护它的祖先节点（若该节点上向右的区间有值的话右端点所对应的节点）的编号，还要维护该节点到它祖先节点的距离。\n距离可以为负数，在计算区间的时候减去距离就行了。在对一组区间的数据检测是否合法的时候，检测两个端点是否可以通过某一种方式通过某一种路径联通，即两节点的祖先节点是否为同一节点。如果联通，那么就可以通过这两个节点到其祖先节点的距离来计算出这两个节点之间的距离了。\n对于节点到其祖先节点的距离的维护，可以通过递归寻找祖先节点的过程中更新。在每一次寻找的过程中，如果该节点不是最终的祖先节点的话，那么将该节点到祖先节点的距离加上其父节点到祖先节点的距离。\n对于新插入的节点，需要维护两节点的根节点的距离关系，可以通过画出向量的方式较为清楚的表达出来：\n\n带边权并查集参考博客\n代码：\n#include &lt;cstdio>\n#include &lt;cstring>\n#include &lt;iostream>\nusing namespace std;\nconst int maxn = 200010;\nint f[maxn], d[maxn];\nint n, m;\nint find(int x) {\n    if (x != f[x]) {\n        int t = f[x];\n        f[x] = find(f[x]);\n        d[x] += d[t];//这句话会在find函数进行递归的过程中进行更新路径上的距离值。\n    }\n    return f[x];\n}\nint main() {\n    while(cin >> n >> m) {\n        memset(d, 0, sizeof(d));\n        for (int i=0;i&lt;=maxn-2;++i)    f[i] = i; \n        int l, r, v, ans = 0;\n        for (int i=1;i&lt;=m;++i) {\n            scanf(\"%d%d%d\", &amp;l,&amp;r,&amp;v);\n            l--;\n            int fl = find(l);\n            int fr = find(r);\n            if (fl == fr)  {\n                if (d[r] - d[l] != v) ans++;\n            }//这个位置没有加大括号WA了好几发，但是我现在还是不知道这里为啥需要加大括号。。。\n            //这个括号到这我在HDU上WA了10+发\n            else {\n                f[fr] = fl;\n                d[fr] = d[l] + v - d[r];\n            }\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n\nPOJ - 2492A Bug’s Life（种类并查集/拓展域并查集）\n开两倍的f数组，x+n表示与x不相同的种类，（这种方法也叫作拆点）每一对虫子只需要保证性别不同即可，即x和y+n是联通的x+n和y也是联通的，但是x和y并不联通。如果在同一种类一侧出现了连接，即为产生了矛盾。\n代码：\n#include&lt;iostream>\n#include&lt;algorithm>\nusing namespace std;\nconst int maxn = 2010;\nint T, n, m, x, y;\nbool flag = true;\nint f[maxn &lt;&lt; 1];\nint find(int x) {return f[x] == x ? x : f[x] = find(f[x]);}\ninline bool check(int x, int y) {\n    int px = find(x), py = find(y);\n    return px == py;\n}\ninline void unino(int x, int y) {\n    int px = find(x), py = find(y);\n    f[py] = px;\n}\nint main() {\n    cin >> T;\n    for (int i=1;i&lt;=T;++i) {\n        scanf(\"%d%d\", &amp;n,&amp;m);\n        flag = true;\n        for (int i=1;i&lt;=n*2;++i)    f[i] = i;\n        for (int i=1;i&lt;=m;++i) {\n            scanf(\"%d%d\", &amp;x,&amp;y);\n            if (!flag)    continue;\n            if (check(x, y) || check(x+n, y+n)) flag = false;\n            else {\n                unino(x, y+n);\n                unino(x+n, y);\n            }\n        }\n        if (!flag) printf(\"Scenario #%d:\\nSuspicious bugs found!\\n\\n\", i);\n        else printf(\"Scenario #%d:\\nNo suspicious bugs found!\\n\\n\", i);\n    }\n    return 0;\n}\n\nPOJ - 1988 Cube Stacking（带边权并查集）\n这道题同样也是带边权的并查集，有点像银河英雄传说这道题。每一个节点需要维护的值有到底部的距离和该栈的元素个数。核心部分还是在合并时权值的处理。\n代码：\n#include&lt;iostream>\n#include&lt;cstring>\n#include&lt;string>\nusing namespace std;\nconst int n = 50010;\nint m, x, y;\nint f[n], d[n], h[n];\ninline void init() {\n    cin >> m;\n    for (int i=1;i&lt;n;++i)    {\n        f[i] = i;\n        h[i] = 1;\n        d[i] = 0;\n    }\n}\nint find(int x) {\n    if (x != f[x]) {\n        int t = f[x];\n        f[x] = find(f[x]);\n        d[x] += d[t];\n    }\n    return f[x];\n}\nint main() {\n    init();\n    string od;\n    for (int i=1;i&lt;=m;++i) {\n        cin >> od;\n        if (od[0] == 'C') {\n            cin >> x;\n            find(x);\n            printf(\"%d\\n\", d[x]);\n        }else {\n            cin >> x >> y;\n            int px = find(x);\n            int py = find(y);\n            if (px != py) {\n                f[px] = py;\n                d[px] = h[py];\n                h[py] += h[px];\n            }\n        }\n    }\n    return 0;\n}\n\nPOJ - 1182食物链（拓展域并查集）\n经典的拓展域并查集。\n\n拓展域并查集：首先对与最简单的并查集来说，如果两个是同一类，那么就p[pa]=pb对吧，但是对于两个相互排斥类的怎么办呢，这就涉及到拓展与并查集了，首先想法就是建立两个并查集，但是怎么把两个并查集联系起来呢？拓展个体。\n这里的拓展个体是什么意思呢，一个个体我们要拆成多个，比方说两个集合存在队立关系，那么对于一个个体a，我们假设存在一个个体a+n ，a和a+n这两个是处于对立关系的，所以当我们说a和b对立的时候，意思就是在说，a+n和b在同一并查集，b+n和a在同一并查集，当我们说，a和b是同类的时候，那么也就是说a和b属于一个并查集，且a+n和b+n属于一个并查集。\n\n开三倍的数组，除了本身的域之外拓展的两个域表示域和本身的关系。分别表示天敌和捕食。\n代码：\n#include&lt;iostream>\n#define rep(i, a, n) for (ll i=a;i&lt;=n;++i)\n#define per(i, n, a) for (ll i=n;i>=a;--i)\n#define IOS std::ios::sync_with_stdio(false)\n#define enter putchar('\\n')\ntypedef long long ll;\nusing namespace std;\nconst int maxn = 50010;\n\nint n, k, f[maxn * 3];\nint d, x, y, ans;\nint getfa(int x) {return (f[x] == x) ? x : f[x] = getfa(f[x]);}\ninline void un(int x, int y) {\n    int a = getfa(x);\n    int b = getfa(y);\n    if (a != b) f[b] = a;\n}\nvoid work(int d, int x, int y) {\n    if (x > n || y > n) {ans++;return;}\n    if (d == 1) {\n        if (getfa(x + n) == getfa(y) || getfa(x + 2 * n) == getfa(y)) {ans++;return;}\n        un(x, y);\n        un(x + n, y + n);\n        un(x + 2 * n, y + 2 * n);\n    }\n    if (d == 2) {\n        if (getfa(x) == getfa(y) || getfa(x + 2 * n) == getfa(y)) {ans++;return;}\n        un(x + n, y);\n        un(y + 2 * n, x);\n        un(y + n, x + 2 * n);\n    }\n}\nint main() {\n    scanf(\"%d%d\", &amp;n, &amp;k);\n    rep(i, 1, n*3) f[i] = i;\n    rep(i, 1, k) {\n        scanf(\"%d%d%d\", &amp;d, &amp;x, &amp;y);\n        work(d, x, y);\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n} \n\nDAY4（树状数组）POJ - 3468A Simple Problem with Integers（线段树/树状数组）\n一个简单的区间修改和区间求和的板子题。\n代码：\n#include&lt;iostream>\n#include&lt;cstdio>\n#include&lt;cstring>\n#include&lt;string>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1e5 + 7;\nstruct SegmentTree {\n    ll l, r;\n    ll dat, add;\n    #define l(x) tree[x].l\n    #define r(x) tree[x].r\n    #define dat(x) tree[x].dat\n    #define add(x) tree[x].add\n}tree[maxn &lt;&lt; 2];\nll a[maxn &lt;&lt; 1];\nll n, m;\ninline ll Read() {\n    ll x=0,f=1;char ch=getchar();\n    while(ch>'9'||ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\ninline void update(ll p) {dat(p) = dat(p&lt;&lt;1) + dat(p&lt;&lt;1|1);}\nvoid build(ll p, ll l, ll r) {\n    l(p) = l; r(p) = r;\n    if (l == r) {dat(p) = a[l]; return;}\n    ll mid = (l + r) >> 1;\n    build(p&lt;&lt;1, l, mid);\n    build(p&lt;&lt;1|1, mid+1, r);\n    update(p);\n}\nvoid spread(ll p) {\n    if (add(p)) {\n        add(p&lt;&lt;1) += add(p);\n        add(p&lt;&lt;1|1) += add(p);\n        dat(p&lt;&lt;1) += add(p) * (r(p&lt;&lt;1) - l(p&lt;&lt;1) + 1);\n        dat(p&lt;&lt;1|1) += add(p) * (r(p&lt;&lt;1|1) - l(p&lt;&lt;1|1) + 1);\n        add(p) = 0;\n    }\n}\nvoid change(ll p, ll l, ll r, ll d) {\n    if (l &lt;= l(p) &amp;&amp; r >= r(p)) {\n        dat(p) += d * (r(p) - l(p) + 1);\n        add(p) += d;\n        return;\n    }\n    spread(p);\n    ll mid = (l(p) + r(p)) >> 1;\n    if (l &lt;= mid) change(p&lt;&lt;1, l, r, d);\n    if (r > mid) change(p&lt;&lt;1|1, l, r, d);\n    update(p);\n}\nll  ask(int p, int l, int r) {\n    if (l &lt;= l(p) &amp;&amp; r >= r(p))    return dat(p);\n    spread(p);\n    ll mid = (l(p) + r(p)) >> 1;\n    ll res = 0;\n    if (l &lt;= mid) res += ask(p&lt;&lt;1, l, r);\n    if (r > mid) res += ask(p&lt;&lt;1|1, l, r);\n    return res;\n}\ninline void init() {\n    n = Read(); m = Read();\n    for (register int i=1;i&lt;=n;++i)    a[i] = Read();\n    build(1, 1, n);\n}\ninline void work() {\n    ll l, r, d;\n    char op; \n    while(m--)  {\n        cin >> op;\n        if (op == 'C') {\n            l = Read(); r = Read(); d = Read();\n            change(1, l, r, d);\n        }\n        if (op == 'Q') {\n            l = Read(); r = Read();\n            printf(\"%lld\\n\", ask(1, l, r));\n        }\n    }\n}\nint main() {\n    init();\n    work();\n    return 0;\n}\n\nHDU - 1166敌兵布阵（树状数组）\n单点修改区间求和的树状数组板子题。\n代码：\n#include&lt;iostream>\n#include&lt;cstdio>\n#include&lt;string>\n#include&lt;cstring>\ntypedef long long ll;\nusing namespace std;\nconst int maxn = 50010;\nint T, n, l, r;\nint a[maxn], c[maxn];\nstring od;\ninline int Read() {\n    int x=0,f=1;char ch=getchar();\n    while(ch>'9'||ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\ninline int ask(int x, int res = 0) {for (; x>=1; x-=(x&amp;-x))    res += c[x];return res;}\ninline void update(int x, int v) {for (; x&lt;=n; x+=(x&amp;-x)) c[x] += v;}\ninline int query(int l, int r) {return ask(r) - ask(l - 1);}\ninline void init() {\n    n = Read();\n    memset(c, 0, sizeof(c));\n    memset(a, 0, sizeof(a));\n    for (int i=1;i&lt;=n;++i) {\n        a[i] = Read();    \n        update(i, a[i]);\n    }\n}\nint main() {\n    T = Read();\n    for (int i=1;i&lt;=T;++i) {\n        init();\n        printf(\"Case %d:\\n\", i);\n        while(cin >> od &amp;&amp; od != \"End\") {\n            l = Read(); r = Read();\n            if (od == \"Add\") update(l, r);\n            if (od == \"Sub\") update(l, -r);\n            if (od == \"Query\") printf(\"%d\\n\", query(l, r));\n        }\n    }\n    return 0;\n} \n\nHDU - 1394Minimum Inversion Number（逆序对/树状数组）\n树状数组求逆序对数的改进版，需要在题中所给的序列生成的一系列序列中找到逆序对数最小的那一组。\n关于求一个数列的逆序对数，可以用树状数组来维护一个数字前面比自己大的数的个数。树状数组可以方便的在线求前缀和，所以说可以用树状数组来完成这道题。\n树状数组求逆序对参考博客\n代码：\n#include&lt;iostream>\n#include&lt;algorithm>\n#include&lt;cmath>\n#include&lt;cstdio>\n#include&lt;cstring>\n#include&lt;string>\n#define int ll\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 5010;\nint n, a[maxn &lt;&lt; 2], f[maxn &lt;&lt; 2];\nint tmp, ans;\ninline int lowbit(int x) {return -x&amp;x;}\nvoid update(int x, int v) {for (; x&lt;=n; x+=lowbit(x))f[x] += v;}\nint ask(int x, int res = 0) {for (; x>=1;x-=lowbit(x)) res += f[x];return res;}\nsigned main() {\n    while(scanf(\"%d\", &amp;n) != EOF) {\n        memset(a, 0, sizeof(a));\n        memset(f, 0, sizeof(f));\n        tmp = ans = 0;\n        for (int i=1;i&lt;=n;++i) {\n            scanf(\"%d\", &amp;a[i]);\n            a[i]++; \n            update(a[i], 1);\n            tmp += (i - ask(a[i]));\n        }//该过程是求一个序列的逆序对的方法\n        ans = tmp;\n        for (int i=1;i&lt;n;++i) {\n            tmp += (n - 2 * a[i] + 1);\n            ans = min(ans, tmp);\n        }//这一段是解决如何求出每一个元素后移之后的序列逆序对数\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n\nHDU - 2795Billboard（线段树）\n这道题的实现其实不太难，难点是如何建树。\n由题可知，我们可以在广告牌的高度上建树，然后对于每一个新的广告，查找最靠下的可以满足当前广告牌的位置插入，实际上就是维护了一个区间的最大值，来进行判断当前广告是否可以放到该区间中。\n代码：\n#include&lt;iostream>\n#include&lt;cmath>\n#include&lt;algorithm>\n#include&lt;cstdio>\n#include&lt;cstring>\n#include&lt;string>\nusing namespace std;\ntypedef long long ll;\nconst ll maxn = 500010;\nll n, h, w;\nll a[maxn * 4];\ninline void update(ll p) {a[p] = max(a[p &lt;&lt; 1], a[p &lt;&lt; 1 | 1]);}\nvoid build(ll p, ll l, ll r) {\n    if (l == r)    {\n        a[p] = w;\n        return;\n    }\n    ll mid = (l + r) >> 1;\n    build(p &lt;&lt; 1, l, mid);\n    build(p &lt;&lt; 1 | 1, mid + 1, r);\n    update(p);\n}\nll ask(ll x, ll l, ll r, ll p) {\n    if (l == r) {\n        a[p] -= x;\n        return l;\n    }\n    ll mid = (l + r) >> 1;\n    ll res = 0;\n    if (a[p&lt;&lt;1] >= x)    res = ask(x, l, mid, p&lt;&lt;1);\n    else     res = ask(x, mid + 1, r, p&lt;&lt;1|1);\n    update(p);\n    return res;\n}\nint main() {\n    while(scanf(\"%d%d%d\", &amp;h, &amp;w, &amp;n) != EOF) {\n        memset(a, 0, sizeof(a));\n        h = min(h,n);\n        build(1,1,h);\n        ll x = 0;\n        for (int i=1;i&lt;=n;++i) {\n            scanf(\"%d\", &amp;x);\n            if (a[1] &lt; x)    printf(\"-1\\n\");\n            else    printf(\"%d\\n\", ask(x, 1, h, 1));\n        }\n    }\n    return 0;\n}\n\nPOJ - 2777Count Color（线段树+状态压缩）\n用位运算来保存颜色的状态，加上懒惰标记，然后update维护父子节点的信息会不太一样。\n代码：\n#include&lt;cstdio>\n#include&lt;cstring>\n#include&lt;string>\n#define int ll\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 500010;\nint n, t, m, l, r, c;\nint a[maxn &lt;&lt; 2], f[maxn &lt;&lt; 2];\nchar od[5];\nvoid update(int p) {a[p] = a[p*2] | a[p*2+1];}\nvoid spread(int p) {a[p*2+1] = a[p*2] = f[p*2+1] = f[p*2] = f[p];f[p] = 0;} \nvoid change(int p, int l, int r, int x, int y, int c) {\n    if (x &lt;= l &amp;&amp; r &lt;= y) {\n        f[p] = a[p] = 1 &lt;&lt; c;\n        return;\n    }\n    int mid = (l + r) >> 1;\n    if (f[p])    spread(p);\n    if (x &lt;= mid) change(p*2, l, mid, x, y, c);\n    if (y > mid) change(p*2+1, mid + 1, r, x, y, c);\n    update(p);    \n}\nint ask(int p, int l, int r, int x, int y) {\n    if (x &lt;= l &amp;&amp; r &lt;= y)    return a[p];\n    ll mid = (l + r) >> 1;\n    if (f[p])    spread(p);\n    ll res = 0;\n    if (x &lt;= mid) res |= ask(p&lt;&lt;1, l, mid, x, y);\n    if (y > mid) res |= ask(p&lt;&lt;1|1, mid + 1, r, x, y);\n    return res;\n}\nint cnt(int x) {\n    int ans = 0;\n    while(x) ans++, x -= -x&amp;x;\n    return ans;\n}\nsigned main() {\n    scanf(\"%lld%lld%lld\", &amp;n,&amp;t,&amp;m);\n    change(1, 1, n, 1, n, 1);\n    for (int i=1;i&lt;=m;++i) {\n        scanf(\"%s%lld%lld\", od, &amp;l, &amp;r);\n        if (l > r)    l ^= r ^= l ^= l;\n        if (od[0] == 'C') {\n            scanf(\"%lld\", &amp;c);\n            change(1, 1, n, l, r, c);\n        }else printf(\"%lld\\n\", cnt(ask(1, 1, n, l, r)));\n    }\n    return 0;\n}\n\n","categories":["竞赛"],"tags":[]},{"title":"河南大学暑假集训的日常（1）","url":"/16332","content":"DAY1(STL)HDU1880魔咒词典（字符串Hash/map/）\n\n水题，两个map即可，细节在于string用cin读还是getline读，然后可以用string的erase来去掉中括号【】\n\n以上的话，是提交卡在队列里时自信打出来的。最后发现是水的是我。。。\n用两个map的话交一遍就会发现一定会MLE。。。而且HDU的MLE规则很奇怪，不要尝试参考评测机的内存大小来调数组的大小，没有用的。。以图为证：\n\n是的，我MLE了20多次，都是在尝试调数组的大小。。。。。\n正解应该是Hash+挂链法或者寻址法，但是我写的挂链法也还是MLE。。。最后选择了zy选择的vector。但是注意：这个代码也还是可以被卡掉，这个hash并没有处理字符串冲突的情况。\n代码：\n#include&lt;iostream>\n#include&lt;vector>\n#include&lt;string>\n#include&lt;cstring>\n#include&lt;algorithm>\nusing namespace std;\nconst int maxn = 100010;\nvector&lt;int> a, b; \nstring s1[maxn];\nstring s2[maxn];\nstring t1, t2;\nint cnt, n;\nint gethash(string s) {\n    int res = 0, leng = s.length();\n    for (int i=0;i&lt;leng;++i)\n        res += res * 237 + s[i];\n    return res;\n}\nint main() {\n    while(cin >> t1 &amp;&amp; t1 != \"@END@\") {\n        getchar();\n        getline(cin, t2);\n        int c1 = gethash(t1);\n        int c2 = gethash(t2);\n        a.push_back(c1);\n        b.push_back(c2);\n        s1[cnt] = t1;\n        s2[cnt++] = t2;\n    }\n    cin >> n;getchar();\n    for (int i=1;i&lt;=n;++i) {\n        getline(cin, t1);\n        int tmp = gethash(t1);\n        if (t1[0] == '[') {\n            if (find(a.begin(), a.end(), tmp) == a.end())    cout &lt;&lt; \"what?\" &lt;&lt; endl;\n            else    cout &lt;&lt; s2[find(a.begin(), a.end(), tmp) - a.begin()] &lt;&lt; endl;\n        }else {\n            if (find(b.begin(), b.end(), tmp) == b.end())    cout &lt;&lt; \"what?\" &lt;&lt; endl;\n            else {\n                string s3 = s1[find(b.begin(), b.end(), tmp) - b.begin()];\n                for (int i=1;i&lt;s3.length()-1;++i)    cout &lt;&lt; s3[i];\n                cout &lt;&lt; endl;\n            }\n        }\n    }\n    return 0;\n}\n\nHDU1276士兵队列训练问题（模拟/约瑟夫环）\n用vector完成，简单模拟，水题。\n第一遍没有注意输出空格PE了一次，第二遍A了\n\n代码（比较丑陋）：\n#include&lt;map>\n#include&lt;iostream>\n#include&lt;string>\n#include&lt;cstring>\n#include&lt;algorithm>\n#include&lt;vector>\nusing namespace std;\nvector&lt;int> a, b;\nint n, m;\nint vsize() {\n    int leng = a.size(), res = 0;\n    for (int i=1;i&lt;leng;i++) {\n        if (a[i] != -1) res++;\n    }\n    return res;\n}\nvoid work() {\n    int flag = 0, leng;\n    while(vsize() > 3) {\n        leng = a.size();\n        if (!flag) {\n            for (int i=1;i&lt;leng;++i) \n                if (i % 2 == 0) {\n                    a[i] = -1;\n                }\n        }else {\n            for (int i=1;i&lt;leng;++i) \n                if (i % 3 == 0) {\n                    a[i] = -1;\n                }\n        }\n        for (vector&lt;int>::iterator it=a.begin();it!=a.end();it++) {\n            if (*it == -1) {\n                a.erase(it);\n                it--;\n            }\n        }\n        flag = flag == 1 ? 0 : 1;\n    }\n}\nint main() {\n    cin >> n;\n    for (int i=1;i&lt;=n;++i) {\n        cin >> m;\n        a.clear();\n        b.clear();\n        a.push_back(0);\n        for (int j=1;j&lt;=m;++j)    a.push_back(j);\n        work();\n        for (vector&lt;int>::iterator it=a.begin() + 1;it!=a.end();it++) {\n            if (*it != -1)\n                b.push_back(*it);\n        }\n        for (vector&lt;int>::iterator it=b.begin();it!=b.end();it++) {\n            if (it != b.end() - 1) \n                cout &lt;&lt; *it &lt;&lt; ' ';\n            else cout &lt;&lt; *it;\n        }\n        cout &lt;&lt; endl;\n    }\n    return 0;\n}\n\n牛客 吐泡泡（栈）\n点开之后发现5月的时候写过了。。。看了一下发现记不得自己是怎么做了，估计是要老年痴呆了（确信）简单的栈应用。\n\n代码：\n#include&lt;bits/stdc++.h>\n#define rep(i, a, n) for (int i=a;i&lt;=n;++i)\n#define per(i, n, a) for (int i=n;i>=a;--i)\n#define enter putchar('\\n')\ntypedef long long ll;\nusing namespace std;\n\nstring s, ans;\nstack&lt;char> sk;\nint len;\nint main() {\n    while(cin >> s) {\n        ans = \"\";\n        len = s.length();\n        rep(i, 0, len - 1) {\n            if (sk.empty()) {\n                sk.push(s[i]);\n                continue;\n            }\n            else {\n                char temp = sk.top();\n                if (temp == s[i]) {\n                    if (temp == 'o') {\n                        sk.pop();\n                        if (sk.size() &amp;&amp; sk.top() == 'O')    sk.pop();\n                        else    sk.push('O');\n                    }\n                    else    sk.pop();\n                }else    sk.push(s[i]);\n            }\n        }\n        while(sk.size()) {\n            ans += sk.top();\n            sk.pop();\n        }\n        per(i, ans.size() - 1, 0) cout &lt;&lt; ans[i];\n        enter;\n    }\n    return 0;\n} \n\nDAY2(单调栈、单调队列、ST表)POJ - 3250Bad Hair Day（单调栈）\n由题可知将答案求每个羊可以看到多少只右边的羊转化为求每一个羊可以被多少左边的羊看到，然后在纸上模拟一下就可以发现单调栈满足这个过程。单调栈和单调队列难都是在思路的转换，一眼会想不到。\n\n代码（摘了眼镜看形状好奇怪啊。。）：\n#include&lt;iostream>\n#include&lt;stack>\nusing namespace std;\ntypedef long long ll;\nstack&lt;ll> st;\nll n, ans, tmp;\nint main() {\n    cin >> n;\n    cin >> tmp;\n    st.push(tmp);\n    for (int i=1;i&lt;n;++i) {\n        cin >> tmp;\n        while(st.size() &amp;&amp; st.top() &lt;= tmp) st.pop();\n        ans += st.size();\n        st.push(tmp);\n    }\n    cout &lt;&lt; ans;\n    return 0;\n}\n\nPOJ - 2823 Sliding Window（单调队列）\n如果我们要得到区间的最大值，那我们可以维护一个队列，在里面存一些我们遇到过的比较大的值，并且保证这个队列是递减的。那么如果我们这时拿到一个新的数据，我们只需要把这个数据放到当前队列的正确的位置然后取队首元素就能找到最大值了。\n由于该队列是单调递增的，所以只需要将新的数据和队尾的值进行比较，如果队尾的值比较小，那么直接扔掉，因为我们要得到的是区间的最大值，所以舍去一些比较小并且比较旧的值并没有什么影响。\n对于这道题最后需要注意的是处理完数据之后的队首是否在当前数据的窗口中，若不在，那么将旧数据直接舍弃即可。\n处理区间的最小值同理。\n对于队列维护的模拟可以看这个博客。\n这道题还有一些小坑。因为在POJ上，会比较慢，用deque会T掉，可以用数组模拟一个双端队列。然后常数大也会被卡掉，所以要用快读。\n\n代码：\n#include&lt;iostream>\n#include&lt;cstring>\n#include&lt;cstdio>\n#include&lt;deque>\nusing namespace std;\nconst int maxn = 1e6 +7;\nint n, k;\nint a[maxn], b1[maxn], b2[maxn], tot1, tot2, h1, h2, t1, t2;\npair&lt;int, int> q1[maxn], q2[maxn];\ninline int read() {\n    int a=0,f=1; char c=getchar();\n    while (c&lt;'0'||c>'9') {if (c=='-') f=-1; c=getchar();}\n    while (c>='0'&amp;&amp;c&lt;='9') {a=a*10+c-'0'; c=getchar();}\n    return a*f;\n}\nvoid init() {\n    ios::sync_with_stdio(false);\n    n = read();k=read();\n    for (int i=1;i&lt;=n;++i)    a[i] = read();\n    h1 = 1, h2 = 1, t1 = 1, t2 = 1;\n}\ninline void write(int x){\n    if(x>9)write(x/10);\n    putchar(x%10+'0');\n}\nvoid solve() {\n    for (int i=1;i&lt;k;++i) {\n        while(h1 &lt; t1 &amp;&amp; q1[t1-1].first &lt;= a[i])    t1--;\n        while(h2 &lt; t2 &amp;&amp; q2[t2-1].first >= a[i])    t2--;\n        q1[t1].second = i;q1[t1++].first = a[i];\n        q2[t2].second = i;q2[t2++].first = a[i];\n    }\n    for (int i=k;i&lt;=n;++i) {\n        while(h1 &lt; t1 &amp;&amp; q1[h1].second &lt;= i - k)    h1++;\n        while(h2 &lt; t2 &amp;&amp; q2[h2].second &lt;= i - k)    h2++;\n        while(h1 &lt; t1 &amp;&amp; q1[t1-1].first &lt;= a[i])    t1--;\n        while(h2 &lt; t2 &amp;&amp; q2[t2-1].first >= a[i])    t2--;\n        q1[t1].second = i;q1[t1++].first = a[i];\n        q2[t2].second = i;q2[t2++].first = a[i];\n        b1[++tot1] = q1[h1].first;\n        b2[++tot2] = q2[h2].first;\n    }\n}\nvoid print() {\n    for (int i=1;i&lt;=tot1;++i)    if(i!=tot1)    printf(\"%d \",b2[i]); else printf(\"%d\\n\",b2[i]);\n    for (int i=1;i&lt;=tot2;++i)    if(i!=tot2)    printf(\"%d \",b1[i]); else printf(\"%d\",b1[i]);\n}\nint main() {\n    init();\n    solve();\n    print();\n    return 0;\n}\n\nPOJ - 3264 Balanced Lineup（ST表/线段树/树状数组）\n这道题是学长讲的ST表的例题，本质是一个RMQ。\nST表，是利用倍增和动态规划的思想处理出的一个查询表，需要用nlogn的时间预处理，得到ST表之后，就可用O(1)的时间查询任意区间内的极值。\nST表的预处理的状态转移方程：d1[i][j]=min(d1[i-1][j],d1[i-1][j+bin[i-1]]); i表示2的i次方，j表示某个点。对于每一个点的所有有意义的2的i次方长度的区间内的极值都需要求出。\nST算法进行查询的核心是在预处理出每个端点本身开始往后的2的i次方的范围内的每一个2区间内的极值后。对于每一次查询，找到满足区间长度r - l + 1所能满足的最大的2的x次方，然后将长度分为两半，以2的x-1次方为区间长度对两个端点的左右进行查询，O（1）的复杂度，然后取这两个值中的极值即为区间的极值。\n参考博客：https://blog.csdn.net/Keep_Trying_Go/article/details/116268533https://blog.csdn.net/Hanks_o/article/details/77547380\n\n\n代码：\n#include&lt;iostream>\n#include&lt;algorithm>\n#include&lt;string>\n#include&lt;cstring>\n#define rep(i,a,b) for (int i=a;i&lt;=b;++i)\nusing namespace std;\nconst int maxn = 50010;\nint n, q; \nint a[maxn], bin[30], Log[maxn];\nint d1[30][maxn], d2[30][maxn];\nvoid init() {\n    memset(a,0,sizeof(a));\n    memset(d1,0,sizeof(d1));\n    memset(d2,0,sizeof(d2));\n    bin[0] = 1;Log[0] = -1;\n    cin >> n >> q;\n    rep(i,1,n)    cin >> a[i];\n    rep(i,1,20)    bin[i] = bin[i - 1] * 2;\n    rep(i,1,50001)    Log[i] = Log[i/2] + 1;\n    rep(i,1,n)    d1[0][i] = d2[0][i] = a[i];\n    rep(i,1,Log[n]) {\n        rep(j,1,n) {\n            if(j+bin[i]-1&lt;=n) { \n                d1[i][j]=min(d1[i-1][j],d1[i-1][j+bin[i-1]]);\n                d2[i][j]=max(d2[i-1][j],d2[i-1][j+bin[i-1]]);\n            } \n        }\n    }\n}\nvoid query(int x ,int y) {\n    int t = Log[y-x+1];\n    int a = max(d2[t][x],d2[t][y-bin[t]+1]);\n    int b = min(d1[t][x],d1[t][y-bin[t]+1]);\n    cout &lt;&lt; a - b &lt;&lt; endl;\n}\nint main() {\n    init();\n    rep(i,1,q) {\n        int a, b;\n        cin >> a >> b;\n        query(a, b);\n    }\n    return 0;\n}\n\nPOJ - 2559 Largest Rectangle in a Histogram （单调栈）\n单调栈的应用。\n对于每一个长方形来说，如果不重复计算的话，这道题的答案就是每个长方形向右画的长方形中面积最大的那一个。\n接着想，对于某个长方形，它所能画出的最大高度就是他本身，最大宽度就是他往右的连续的不低于他的长方形的宽度。对于一个高度上升的长方形序列，其中一个长方形所能达到的最大面积就是向右不低于该长方形的所有长方形的宽度和，所以，对于一个还在上升的序列，并不能知道它最右边能够到达的宽度有多少，所以将其加入栈中，如果发现了一个长方形的高度下降，那么这个长方形一定可以作为上升序列中的一些长方形的右边界。此时开始计算，直到序列恢复递增为止。\n\n代码：\n#include&lt;iostream>\n#include&lt;string>\n#include&lt;cstring>\n#include&lt;algorithm>\n#include&lt;stack>\n#define rep(i,a,b) for (int i=a;i&lt;=b;++i)\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100010;\nll n, a[maxn], w[maxn], s[maxn], tail, ans;\ninline void init() {\n    memset(w, 0, sizeof(w));\n    memset(a, 0, sizeof(a));\n    memset(s, 0, sizeof(s));\n    ans = 0, tail = 0;\n    s[n + 1] = 0;\n    rep(i,1,n)    cin >> a[i];\n}\nvoid solve() {\n    rep(i,1,n+1) {\n        if (a[i] > s[tail]) {\n            s[++tail] = a[i];\n            w[tail] = 1;\n        } else {\n            int width = 0;\n            while(a[i] &lt; s[tail]) {\n                width += w[tail];\n                ans = max(ans, (ll)width * s[tail]);\n                tail--;\n            }\n            s[++tail] = a[i], w[tail] = width + 1;\n        }\n    }\n}\nint main() {\n    while(cin >> n &amp;&amp; n != 0) {\n        init();\n        solve();    \n        cout &lt;&lt; ans &lt;&lt; endl;\n    }\n    return 0;\n}\n\n","categories":["竞赛"],"tags":[]},{"title":"数学建模入门","url":"/35840","content":"Matlab学习笔记语法小知识：\n\n同一行中间用逗号分隔，也可以不用逗号，直接用空格 分号可以用来分隔每一行的元素就是说逗号是一行中的数据，分号分割行与行之间。\n矩阵E(:)表示矩阵的所有元素，E(:,1)表示第一列，E(1,:)表示第一行。\n2:5表示从第2到第5，1:3:10表示从1到10，每次递增3。2:end表示从第二行到最后一行，\n~=是不等号\nMatlab函数的声明要单独放在一个.m文件中，不能直接放在主函数里面。函数声明格式：function [输出变量] = 函数名称(输入变量）  最后用end结束声明\n\n% 常用指令操作\nclc % 清屏\nclear all % 清除工作区的所有变量\nhold on \nhold off % 控制图像是否被刷新\n% 常用字符串函数\nchar(65) % ascii码对应的字符，A\nlength(s) % 字符串长度\nstrcmp() % 字符串比较函数\nstrcat() % 将多个字符串合并成一个\nnum2str() % 将数字转换为字符串\n% 常用数学函数\nsize() % 数组大小，第二个参数也是dim表示矩阵的维度。\nmagic() % 生成一个幻方\nabs(s) % 求s的ascii码\nfloor()    % 取整函数\nsum() % 求和函数，辅助参数dim表示求和的维度，1表示按列，2表示按行，默认dim=1\nrepmat() % 复制扩展矩阵\nsort() % 将数组或矩阵排序\nprod() % 计算矩阵每一列的乘积\neig() % 计算矩阵的特征值\ninv() % 求矩阵的逆矩阵\nrand() % 产生（0,1）之间均匀分布的伪随机数组成的数组\nrandn() % 生成标准正态分布的伪随机数（均值为0，方差为1）\nrandperm() % 将一序号随机打乱，序号必须是整数\nnormrnd(MU,SIGMA) % 生成服从正态分布的随机数\n% 常用数据输入输出函数\ndisp() % 向命令行输出字符或数字\ninput() % 从命令行读取数据\nxlsread('xls_name_string') % Excel表格读取\nsave % 用来将数据保存为.mat文件\nload % 用来加载之间生成的.mat文件\n% 常用绘图函数\nplot(x, y) % 创建2维直线图\nstem(Y) % 绘制数据序列Y的茎状图\nmeshgrid(a, b) % 生成二维网格\ncontour3(x, y, z) % 三维等值线绘图\nlegend('string1','string2') % 标注绘制的图形的名称\nxlabel() ylabel() zlabel() % 标注x,y,z轴\ntitle()    % matlab绘图标题设置\nset() % 设置图像属性\naxis() % 对坐标轴进行缩放操作\n\n% matlab里的一些基本规范\n% 数值\n% 字符串\n\n\nfloor函数详解\nrandperm函数详解\nnormrnd函数详解\nrepmat函数详解\nsize函数详解\nmagic函数详解\nsum函数详解\nprod函数详解\neig函数详解\nfind函数详解\nplot命令详解\nmeshgrid函数详解\ncontour3函数详解\nstem函数详解\nhold on 和 hold off 语句详解\nlegend函数详解\nxlabel函数详解\nset函数详解\naxis函数详解\ntitle函数详解+matlab二维画图基本操作\nxlsread函数详解\ndisp函数详解\ninput函数详解\nsave 和 load详解\n\n一、矩阵及数组操作例题：\n% 生成一个3x3和15x8的单位矩阵\neye(3, 3)\neye(15, 8)\n% 生成全1矩阵\nones(3)\nones(15, 8)\n% 全0矩阵\nzeros(3)\nzeros(15, 8)\n% 均匀分布随机矩阵（[-1, 1]之间）\n2 * rand(3, 3) - 1\n2 * rand(15, 8) - 1\n% 正态分布矩阵（均值为1，方差为4）\n1+sqrt(4)*randn(3,3)\n% 利用fix及rand函数生成[0,10]上的均匀分布的10x10的整数随机矩阵a，然后统计a中大于等于5的元素的个数。\na = fix(10*rand(10,10));\nb = [a>=5];\nc = [sum(b)];\nsum(c')\n% 在给定的矩阵中删除含有整行内容全为0的行，删除整列内容全为0的列。\na = [1 2 0 4;0 0 0 0;5 6 0 8; 9 1 0 2];\na(:,find(sum(abs(a'))==0)) = [];\na(find(sum(abs(a'))==0),:) = [] % 没看懂，该写法待确认\n\n二、绘图：\n% 在同一图形窗口画出下列两条曲线图像，并用legend标注：\nx=0 : 1 : 10;\ny1=2*x+5;\ny2=x.^2-3*x+1;\nplot(x, y1, x, y2);\nlegend('y1','y2')\n% 画出下列函数的曲面及等高线\n% z = x^2 + y^2 + sin(xy).\n[x, y] = meshgrid(0:0.25:4*pi);\nz=x.^2+y.^2+sin(x*y);\ncontour3(x, y, z);\nmeshc(x, y, z)\n\n三、简单程序设计\n% 求分段函数\nx=input('请输入x的值：');\nif x>=-3 &amp;&amp; x &lt; -1\n    y=(-x^2-4*x-3)/2;\nelseif x>=-1 &amp;&amp; x&lt;1\n    y=-x^2+1;\nelseif x>=1 &amp;&amp; x&lt;=3\n    y=(-x^2+4*x-3)/2;\nelse\n    y='error'\nend\ny\n% 分数序列求和\nm = 1;\nn = 2;\nsum = 0;\nfor k=1:15\n    f=n/m;\n    sum=sum+f;\n    t=n;\n    n=m+n;\n    m=t;\nend\nsum\n\n一些注意事项:\n\n在变量定义的时候多写注释，注明每个变量的作用。\n好的数学建模matlab的代码部分注释都很详细。\n可以将代码分成几个部分，这样更加清晰，e.g. 数据清除，导入数据，数据预处理，相关步骤等….\n在很多代码开头会遇到：clear;clc 这两条一起使用，起到“初始化”的作用，防止之前的结果对新脚本文件（后缀名是 .m）产生干扰。\n\n数学建模常见算法学习层次分析法（AHP）一、对于一个问题，先分析系统中各因素之间的关系，建立系统的递阶层次结构（三层图）。\n二、然后对于同一层次的各元素关于上一层中某一准则的重要性进行两两比较，构造判断矩阵。\n\n在准则层需要生成每个准则的权重，在方案层需要生成对于每个准则的得分，使用两两对比的方法生成判断矩阵然后就可以计算出每个准则的权重或者方案对不同准则的得分了。\n在层次分析法中我们构造的判断矩阵均是正互反矩阵(𝑎ij * 𝑎ji = 1)，若正互反矩阵满足𝑎ij  * 𝑎jk = 𝑎ik，则我们称为一致矩阵。在判断矩阵计算准则的权重或者方案对不同准则的得分之前，需要对其进行一致性检验。\n\n三、通过计算一致性指标和一致性比例来评判判断矩阵是否可以接受，计算对于该准则的相对权重。\n\n进行一致性检验的一致矩阵准则的权重的计算或者方案对不同准则的得分的计算，计算权重或者得分有多种方式：\n\n算数平均法求权重\n\n集合平均法求权重\n\n特征值法求权重\n\n\n计算出所有的方案对不同准则的得分和准则的权重之后就可以计算每个方案的加权得分了。\n\n四、计算各层元素对系统目标的合成权重，并进行排序。\nTOPSIS法（优劣解距离法）一、将原始矩阵正向化，将所有的指标转化成极大型指标。\n\n\n极大型指标\n极小型指标\n中间型指标\n区间型指标\n\n\n二、正向化矩阵标准化。\n\n消除不同指标量纲的影响，例如名次和分数两个指标导致的量纲不统一的影响。\n\n三、计算得分并归一化\n\n通过公式计算每一个评价对象对不同的评价指标离最小值的距离和到最大最小距离的和的比值来得到评价对象在该评价指标上的得分。\n\n四、带权重的TOPSIS\n\n通过层次分析法可以得到不同的指标的权值，在进行计算得分的时候乘以相应的权值。\n\n插值算法\n理解：感觉该算法就是通过已知的一些点来推测拟合出一个函数，并借此函数计算出需要插值的点所对应的值是多少\n常见插值方法：\n\n多项式插值\n分段插值\n三角插值\n\n\n一、拉格朗日插值法\n\n\n\n通过该方法，可以通过n+1个点来找到一个n+1项n次的一个多项式作为插值函数，来估计对应插值点的函数值。\n\n龙格现象：高次插值会产生龙格现象，即在两端处波动极大，产生明显的震荡。在不熟悉曲线的运动趋势的前提下，不要轻易使用高次插值\n分段线性插值\n\n分段线性插值法的一种为分段二次插值法，在几何上利用分段抛物线来代替原函数，故分段二次插值法又称为分段抛物线插值法。\n但是在分段时使用的插值方法本质还是拉格朗日插值法。\n\n二、牛顿插值法\n\n\n\n与拉格朗日插值法相比，牛顿插值法具有继承性。（牛顿插值法每次插值只和前n项的值有关，这样每次只要在原来的函数上添加新的项，就能够产生新的函数）但是牛顿插值也存在龙格现象的问题。\n\n\n拉格朗日插值法和牛顿插值法两种方法得到的多项式都不能全面的反映被插值函数的形态，比如说在一个或者全部节点上的导数值，或者高阶导数值，这两种插值法都不能满足。\n\n三、埃尔米特（Hermite）插值法\n\n埃尔米特插值法可以保证插值函数在节点处有切线（光滑）使插值函数和被插值函数的密合程度比较好。\n\n分段三次埃尔米特插值法\n\n直接使用Hermite插值得到的多项式的次数也比较高，也会存在龙格现象，因此在实际应用中，往往使用分段三次Hermite插值多项式（PCHIP）\n\n四、三次样条插值法\n\n该插值法同样是区间插值法，是可以保证二阶连续可微的插值法。\n\n这些插值法都在Matlab内部提供了封装好的实现方法，体现为内置的函数。\n","categories":["技术"],"tags":[]},{"title":"Hyperledger-Fabric入门","url":"/29920","content":"Hyperledger Fabric文档阅读介绍（自己总结的）区块链： 分布式网络，节点维护，不可篡改的账本，共识协议来验证交易，节点执行交易来维护账本的副本，账本以区块的方式存在，区块通过哈希和之前的区块相连。\n区块链的应用：加密货币：比特币、以太坊：智能合约：为分布式应用创建平台。：公共非许可区块链技术，公共网络，匿名互动。\n公共非许可区块链技术的缺点：性能较差，身份匿名。\n企业级应用的需求：身份识别，性能强，低延迟，隐私性和机密性。\nHyperledger  Fabric的自身定位：开源企业级许可分布式账本技术平台。高度*模块化**，可配置*的架构，支持**通用编程语言编写智能合约，平台是*许可的**，参与者确实*存在信任，**可插拔的共识协议，可以利用*不需要原生加密货币的共识协议**，性能较好*，**隐私和保密。\n特性的一些解释：非许可区块链：匿名，信任通过工作量证明进行，采用挖矿来抵消工作量证明的成本。许可区块链:**使用共识协议来进行信任，不需要昂贵的挖掘。**智能合约：“链码”，受信任的分布式应用程序。从区块链中获得信任，在节点中达成共识。共识协议：验证，排序交易，传播到所有节点，各节点按顺序执行交易。一种新方法消除了非确定性，标准编程语言。隐私和保密性：公共非许可区块链网络中，基于Pow的拜占庭容错共识牺牲了合约和数据的保密性。加密数据：可能被破解，零知识证明：使用其他共识，将机密信息限制于授权节点中。可插拔共识：模块化的共识性能和可扩展性：\n介绍什么是区块链？：一个分布式账本，记录网络上所有的交易。去中心化，协作维护。信息仅能以附加的方式记录到区块链上，并使用加密技术保证一旦将交易添加到账本就无法修改。简化了信息的溯源。区块链有时被描述为 证明系统 。\n智能合约：为了支持以同样的方式更新信息，并实现一整套账本功能（交易，查询等），区块链使用 智能合约 来提供对账本的受控访问。智能合约不仅是在网络中封装和简化信息的关键机制，它还可以被编写成自动执行参与者的特定交易的合约。\n共识：保持账本在整个网络中同步的过程称为 共识 。该过程确保账本仅在交易被相应参与者批准时更新，并且当账本更新时，它们以相同的顺序更新相同的交易。\n区块链的不同：一套在网络上建立身份，执行交易和存储数据的标准方法。资产来源可以通过查看交易列表来确定，此列表一旦写入，无法更改，因此可信任。\nHyperledger Fabric 与其他区块链系统不同的地方是 私有 和 许可 。与允许未知身份参与网络的开放式非许可系统（需要诸如“工作量证明”之类的协议来验证交易并保护网络）不同，Hyperledger Fabric 网络的成员需要从可信赖的 成员服务提供者（MSP） 注册。\nHyperledger Fabric 还提供创建 通道 的功能，允许一组参与者创建各自的交易账本。对于某些网络而言，这是一个特别重要的选择。这些网络中，一些参与者可能是竞争对手，并且不希望他们做出的每笔交易都被每个参与者知晓，例如，他们只向某些参与者提供的特殊价格，而其他人不是。如果两个参与者组成一个通道，那么只有这两个参与者拥有该通道的账本副本，而其他参与者没有。\n智能合约：Hyperledger Fabric 智能合约用 链码 编写，当该应用程序需要与账本交互时，由区块链外部的应用程序调用。在大多数情况下，链码只与账本的数据库、世界状态（例如，查询）交互，而不与交易日志交互。\nHyperledger Fabric 支持私有网络（使用通道）是很重要的，因为网络是相对开放的。\n共识：交易必须按照发生的顺序写入账本，即使它们可能位于网络中不同的参与者集合之中。为此，必须建立交易的顺序，且必须采用一种方法来拒绝错误（或恶意）插入到账本中的非法交易。\n这是一个彻底的计算机科学研究领域，且有很多方法可以实现它，每个方法都有不同的权衡。例如，PBFT（实用拜占庭容错算法）可以为文件副本提供一种机制，使其能够保持各个副本的一致性，即使在发生损坏的情况下也是如此。或者，在比特币中，通过称为挖矿的过程进行排序，其中竞争计算机竞相解决加密难题，该难题定义所有过程随后构建的顺序。\nHyperledger Fabric 被设计为允许网络启动者选择最能代表参与者间存在的关系的共识机制。与隐私一样，有一系列需求；从他们的关系高度结构化的网络，到更加点对点的网络。\n参考资料：\n项目文档[1]\nHyperledger Fabric平台搭建笔记centos7.9系统的安装和基础配置\n记得选择语言，汉语，这是在安装界面可以看到的。ps：选错语言的话酒删了重装吧。\n记得选择磁盘位置\n记得连接网络，很重要！！！ps：如果在有图形的安装界面不进行勾选的话 ，之后再更改配置会十分的困难。\n记得勾选基本的安装包。ps：如果不勾选的话一些基本的yum或者tar指令都无法使用。但是也不要选择太多的包，不然有可能会和自己安装的服务产生冲突。\n然后进行安装即可。ps：这样进行的安装是没有图形界面的。\n\n如何更换字体和字号：\n\n进入/lib/kbd/consolefonts，选择合适的字体。\n输入setfont指令，后面跟上字体的名称。\n输入echo &#39;setfont latarcyrheb-sun32&#39; &gt;&gt; /etc/profile指令将字体设置设为开机启动。\n\nwget的安装：\n\n刚开始安装好的centos系统是没有wget的，需要用yum安装。\nyum -y install wget\n\nGo语言安装\nGo语言安装\n从官网下载最新的linux-amd64.tar.gz压缩包（这里是go1.15.6.linux-amd64.tar.gz）\nwget https://golang.google.cn/dl/go1.15.6.linux-amd64.tar.gz\n\n将其解压到/usr/local目录下：\nsudo tar -C /usr/local -zxf [压缩包名]\n\n\n配置环境变量，在/etc/profile文件的末尾加入（在加入之前创建/home/gopath目录）\nexport GOPATH=/home/gopath\nexport PATH=$PATH:/usr/local/go/bin\n\n\n配置中国的代理\ngo env -w GO111MODULE=on\ngo env -w GOPROXY=https://goproxy.cn,direct\n\n\n查看是否配置成功\ngo env\n\n\n\nmwget安装wget太慢使用mwget\nwget http://jaist.dl.sourceforge.net/project/kmphpfm/mwget/0.1/mwget_0.1.0.orig.tar.bz2\nyum install bzip2 gcc-c++ openssl-devel intltool -y\nbzip2 -d mwget_0.1.0.orig.tar.bz2\ntar -xvf mwget_0.1.0.orig.tar \ncd mwget_0.1.0.orig\n./configure \nmake\nmake install　　echo \"至此，安装完成\"\n% 断点续传\nwget -c 要下载的文件，实现断点续传。\n\n最后的配置工作生成身份材料\n\n进入BasicNetwork-2.0/artifacts/channel目录，执行\n./create-artifacts.sh\n\n\n进入BasicNetwork-2.0/artifacts目录执行\n./docker-compose up -d\n\n\n进入BasicNetwork-2.0\n./createChannel.sh\n\n\n\n智能合约部署\n\n进入BasicNetwork-2.0/artifacts/src/github.com/fabcar/go/目录下，执行（为智能合约安装依赖）\n\nGO111MODULE=on go mod vendor\n\n\n进入BasicNetwork-2.0/，执行智能合约的部署和测试在执行deployChaincode.sh之前，按以下命令修改文件夹的权限\n\nsudo chmod 777 /home/gopath/*\n\n\n开始部署\n\n./deployChaincode.sh\n\n部署explorer\n\n启动Explorer, 进入ContainerisingBlockchainExplorer目录下\ndocker-compose up -d\n\n\n\n服务全部启动成功，可以在windows上查看相关的服务。\n注意：hyperledge Fabric搭建完成后将虚拟机挂起后再重新开启并不能恢复所有的服务，需要重新开启一遍。\n平台使用查看可视化的区块链信息，访问：\n[ip地址]:8080\n\n查看产的最新状态，访问：\n[ip地址]:5984/_utils\n\n常用操作超级账本的下载地址：\nwget -c https://github.com/hyperledger/fabric/releases/download/v2.2.1/hyperledger-fabric-linux-amd64-2.2.1.tar.gz\n\n超级账本的解压缩：\nsudo tar -C ./ -zxf hyperledger-fabric-linux-amd64-2.2.1.tar.gz\n\n超级账本的bin目录内的东西放到/usr/local/bin下\nsudo mv ./bin/* /usr/local/bin\n\n把BasicNetwork-2.0/artifacts/channel下的crypto-config拷贝到ContainerisingBlockExplorer下\nsudo mv BasicNetwork-2.0/artifacts/channel/crypto-config ContainerisingBlockchainExplorer\n\n在ContainerisingBlockchainExplorer下创建data和walletstore文件夹\nsudo mkdir data\nsudo mkdir walletstore\n\n查看Centos的ip（看en33那个ip）\nip add\n\n启动docker服务\nsystemctl restart docker.service\n\n关闭所有运行着的docker容器\ndocker rm -f $(docker ps -a -q)\n\ntips:\n注意go的版本\n\n参考资料：\n实验平台在服务器上的基于脚本的自动化部署[1]\n区块链实验平台部署[2]\n","categories":["技术"],"tags":[]},{"title":"大学物理复习笔记","url":"/4612","content":"第16章第1-3节：q = ne    电荷是量子化的    e = 1.62×10 ^ -19 C密立根油滴实验：电荷的量子性。mC        uC        nC        pC10^-3    10^-6    10^-9    10^-12质子的质量：1.6×10^-27电子的质量：9×10^-31\n极化：电中性的物体中，正负电荷的中心不重合的现象。\n库伦定律：\nK的值：9×10^9 N·㎡/C^2\n同号相斥，异号相吸\n场是一种物质，无静止质量\n第4节：电场强度：单位： N/C  or   V/m   是电场中某一点的一个性质\n    q是场源电荷    \n两条电场线不会相交，电场线不闭合\n电偶极子：电偶极矩：p ⃑ = ql ⃑   方向从负电荷指向正电荷\n薄金属球壳中电场线的分布\n第5节：“无限大”带电平面所激发的电场\nσ:平面上的电荷面密度。“无限大”带电平面所激发的电场强度与离平面的距离无关，即在平面两侧形成一均匀场.\n带有等量异号的平行金属板所产生的电场\nσ:平面上的电荷面密度\n第6节：导体处于静电平衡时，内部电场为0。静电荷分布在导体表面，尖端电荷密度最高。导体内部没有电场线，电场线垂直与导体表面尖端放电现象。\n当腔内无导体时：空腔导体不接地的时候外面的电场不会影响腔内当腔内有导体时：空腔导体接地时外面的电场不会影响腔内\n在空腔中的导体位置进行移动的话，对腔内和腔外的电场分布没有影响。\n第7节：电通量：通过电场中某一给定平面的电场线的总条数叫做通过该面的电通量（垂直穿过或者斜着穿过对电通量的大小相同）电通量计算公式：\n\n\n\n\n简单来说，就是某块平面的电场强度乘以这块平面的面积。几何意义：通过闭合曲面的电场线的净条数。\n高斯定理：\n\n\n静电场的高斯定理(Gauss’s law) 的表述:在静电场内,任一闭合面的电通量等于这闭合面所包围的电量的代数和(净电荷)除以ε0 .该定理将一任意闭合曲面上的电场和闭合曲面内所包围的净电荷联系起来。静电场是有源场。高斯定理求出来的是电通量，电通量乘以面积得到的是电场强度。\n高斯定理在求解场强方面的应用：\n\n均匀带电球面的电场分布，设球面半径为R，球面上所带总电量为q。\n\n电荷均匀分布在一条长直细线上。线上单位长度所带电荷恒定为λ。求距离细线r处电场的大小，假设此处与线的两端相距很远。\n\n求无限大均匀带电平面的电场分布。已知带电平面电荷面密度为σ。\n\n\n第17章第1节：保守力：力所做的功和始末位置有关，和路径无关。静电场环路定理：静电场强沿任意闭合路径的线积分为零。反映了静电场是保守力场（无旋场）。\n凡保守力都有与其相关的势能，静电场是有势场。\n势能与做功的关系\n电势能只与物体的位置有关，与路径无关。\n电场力推出的电势能的公式。\n第2节：\n当取试验电荷为单位正电荷时，V_a和U_a等值，这表示静电场中某点的电势在数值上等于单位正电荷放在该点处时的电势能，也等于单位正电荷从该点经过任意路径到电势零点时电场力所做的功。\n求均匀带电球面的电势分布。设球面半径为R，带电量为Q：\n电势分布：\n\n\n  一个带电的导体球外的电场和其上所带电荷都集中在球心时形成的点电荷产生的电场相同。\n\n\n\n\n点电荷的电势：\n点电荷的电势能：\n注意：电场是矢量，电势是标量电场为零的地方电势可以不为零；电势为零的地方电场也可以不是零。\n第3-4节：等势面：将电势相等的场点连成连续的曲面——等势面相邻等势面的电势差为常量，可以得到一系列的等势面\n电荷沿等势面移动，电场力不做功。\n电势能只与物体的位置有关，与路径无关。\n静电平衡下的导体内部和导体表面处处电势相等，整个导体是个等势体，导体表面成为等势面。\n第5节：电容器：一种储存电能的原件，由电介质隔开的两块任意形状导体组合而成。两导体称为电容器的极板。\n定义式：单位：F(法拉)\n\nC 是描述电容器储电本领的物理量\n C 取决于电容器两板的形状、大小、相对位置及中间电介质的种类和分布情况；\n\n物理意义：导体每升高单位电势所需的电量。\n组成：用真空或绝缘体分开的两个导体。\n\n平行板电容器的推导式。\n球形电容器的推导式。\n圆柱形电容器的推导式。当极板间距d&lt;&lt; RA时，圆柱形电容器类似于平行板电容器。\n\n电容的串并联：\n并联：\n串联：\n第6节：相对介电常数：相对介电常数是一个量纲为一的数，即有介质时的电容和没有介质时的电容比值。\n电介质的介电常数与真空介电常数的比值。电容器存储的电势能\n能量密度：单位体积的电势能该能量密度的表达式对任意电场都普遍成立。只要有电场的地方就有能量。\n第18章：第1-3节：电流：单位时间通过垂直于电流方向的某一面积的净电量。载流子：自由电子、离子、空穴（正的载流子叫作空穴）\n电池的电动势：\n普通电池尺寸不同，电池越大，它储存的化学物质的量就越多，相应储存的化学能就越多，但它们都提供相同的电动势（1.5V）大小电池的另外一个区别就是大电池通常能更快的抽运电荷，也就是说大电池能提供更大的电流。\n电流可表示为：单位体积内传导电子的数量：n，在体积A vD Δt内的电子数为N = nA vD Δt，电量为： ΔQ=Ne= neA vD Δt，\n第4节：欧姆定律：\n电阻定义： 单位：欧姆（Ω）1 Ω=1V/A电阻率：\n电阻率和温度的关系：\n路端电压（V）：\n第5节:基尔霍夫节点电流定律：流入一个节点的所有支路的电流之和等于流出这个节点的所有支路的电流之和。任何一个电的连接点即为节点。\n\n\n基尔霍夫回路电压定律:适用于电路中起始和终止于同一点的任何回路。电势改变的代数和为零。\n\n\n第6节：串联与并联电路：串联电阻器:\n\n\n串联电容器:\n\n\n并联电阻器:\n\n\n并联电容器：\n\n\n第8-11节：电路中的功率与能量：功率的单位：J/s=A·V=W\n在电阻上的能量可表示为:    \n\n\n\n\n电流表和电压表\nRC电路：同时包含电阻器和电容器的电路。\n第19章：第1-2节：磁感应强度B：单位 (SI)： T(特斯拉) \n\n\n第3节：垂直于匀强磁场运动的带电粒子：粒子做匀速圆周运动\n\n\n速度选择器:\n\n\n质谱仪：\n\n\n回旋加速器：\n\n\n\n\n第4-5节：粒子作螺旋线向前运动，轨迹是螺旋线：\n霍耳效应：\n\n\n第6节：\n注意对无线长载流直导线的B的求法。其中μ0 = 4π\n第7节：\n第8节：\n\n\n第9节：一、恒定磁场的高斯定理：\n\n二、安培环路定理：\n","categories":["文化课"],"tags":[]},{"title":"Web复习笔记","url":"/48416","content":"HTML标题类元素：h1，h2，h3，h4，h5，h6p元素：段落文字br元素：段内换行&amp;nbsp：空格pre元素：预留格式hr元素：水平标记线\ndiv 元素属性：idnameheightwidthpadding    内边距margin    外边距borderdiv是块级元素，独占一行，用于页面的分区（相当于容器） \nspan 元素属性：span是行级标签，宽度会根据内容变化，一行内可以并列多个行级标签。\nimg 元素属性：src    图像源文件alt    提示文字widthheightborder    表框\na 元素的常用属性：id    超链接的唯一标识name    给超链接命名href    链接目标的url，可以是一个a标签的name或者id来完成页内跳转格式#namehref = “mailto: …”    电子邮箱target    指定链接的目标窗口，取值有_self, _blank, _parent, _top等title    给链接提示文字rel    规定当前文档与目标文档之间的关系\n列表元素：ul    无序列表ol    有序列表dl    定义列表\n表格常用元素：table    定义表格caption    表格标题th    表格表头tr    行td    表格单元thead    页眉tfoot    页脚colgroup    列的组\ntable 的常用属性：bgcolor    背景色border    边框宽度cellspacing    单元格之间的大小cellpadding    单元格边框和内容之间的大小width    表格宽度heigth    表格高度\ntr 的常用属性：widthheighalign    行的对齐方式（水平）left, right, centervalign    行的对齐方式（垂直）left, right, centerbgcolor    行的底色bordercolor    边框颜色\ntd 的常用属性：widthheighcolspan    向右通栏的栏数rowspan    向下通栏的栏数alignvalignbgcolorbordercolor\naudio 和 video 的常用属性：src    音频或者视频的路径width    video独有height    video独有autoplay    文件是否自动播放controls    文件是否显示控制面板loop    文件循环播放的次数poster    video独有，如果视频播放失败，则展示一副替代的图片preload    是否预加载\n表单元素：form    供用户输入的表单input    定义输入域textarea    定义文本域label    控制的标签select    选择列表option    下拉列表中的选项button    定义一个按钮\nCSS外部样式表内部样式表内嵌样式\n外部样式表的引入：在head区内使用link来引入外部的样式表。\n内部样式表的使用：在head区内使用style type = “text/css” 来进行样式的定义。\n内嵌样式的使用：在body内元素里加入style属性，style属性的内容就是CSS的内嵌样式\n选择器：*    通用选择器.    类选择器#    id选择器E    标签选择器E F    后代选择器    选择E元素的所有后代F元素E &gt; F    子代选择器    选择E元素下所有的子（第一代）元素FE + F    相邻兄弟选择器    选择紧接在E元素后的F元素E ~ F    通用兄弟选择器    选择E元素后面的所有兄弟元素E, F    群组选择器    E和F都被选择:link    链接伪类选择器    定义了超链接的元素    未被访问过的:visited    链接伪类选择器    定义了超链接元素    已被访问过:active    用户行为伪类选择器        元素被激活（鼠标点击不动时超链接的状态）:hover    用户行为伪类选择器        鼠标悬停在元素上:focus    用户行为伪类选择器        获得焦点\n:first-child    匹配父元素的第一个元素:nth-child(n)    匹配父元素的第n个子元素:first-of-type    匹配父元素第一个类型为E的元素E[att]    选择具有属性att的E元素E[att=val]    选择具有属性att并且属性值为val的E元素E[att | = val]    选择属性值是有一个具有val或者以val-开始的属性值。E[att $ = val]    选择具有属性att并且属性值后缀为val的E元素E[att ^ = val]    选择具有属性att并且属性值为以val开头的字符串的E元素\nborder：border-width    边框的宽度border-colorborder-style    设置边框的样式：none(无边框),hidden(隐藏),soild(实线),double(双线框)border-radius    边框圆角提供两个参数，参数之间用/来分割\nbackground:background-color    设置背景颜色background-image    设置背景图像background-position    设置背景图像的起始位置:background-repeat    背景图像是否重复\ntext:text-align    设置文本对齐方式：left, right, centervertical-align    设置文本垂直对齐方式text-indent    设置首行缩进line-height    设置行高text-shadow    产生阴影：text-shadow: color（阴影颜色） x-offset（X轴位移） y-offset（Y轴位移） blur-radius（阴影模糊半径）\n盒子模型：白色边框和内容会显示出来，剩下的灰色的部分都是空白。\npadding    元素边框和内容之间的距离，padding-top等四个margin:    元素周围的空间的距离，margin-top等四个box-shadow    定义元素的盒子阴影\n浮动和定位：float:    将元素进行浮动,脱离文档流    属性有：none, left, rightposition:    定位是指将某个元素放在某个位置上    属性有：static(静态定位，默认值，top等属性无效), relative(相对位置，相对正常的位置), absolute(绝对定位，相对于 static 定位以外的第一个父元素进行定位), fixed(固定定位，相对于window固定)\nJS数据类型NumberString    用单引号和双引号包围BooleanObjectUndefined    未被赋值之前的值Null    没有任何值JS变量区分大小写\nJS内置对象Object    对象String    字符串Date    时间对象Array    数组对象\n如何去创建一个自定义的对象？\n1.通过对象字面量的方式创建对象：var obj = {}2.通过new object的方式创建对象:var obj = new Object()//创建一个空对象var arr = new Array()/创建一个空数组对象3.通过构造函数的形式创建对象：function Person(){};或者：var Person=function(){};4.通过Object.create()创建\nArray常用方法：join()    将数组中的元素通过一个分隔符拼接为一个字符串，默认的分隔符是逗号pop()push()reverse()    翻转\nDate常用方法：getDate()    返回月份的第几天getDay()    返回星期几，0是周日getMonth()    返回月份值，0表示1月getFullYear()    返回四位数的年份getHours()    返回小时getMinutes()getSeconds()getMilliseconds()    返回毫秒值getTime()    返回1970年1月1日至今的毫秒总数getTimezoneOffset()    \nsetDate()    传递参数为月份的第几天setMonth()setFullYear()setHours()setMinutes()setSeconds()setMilliseconds()setTime()\nMath常用方法：E    数学常量e的值LN2    2的自然对数值PI    圆周率的值SQRT2    2的平方根rand()    返回0~1之间的随机数ceil()    对参数向上取整floor()    对参数向下取整\nJS内置事件：鼠标事件：onclick    鼠标单击（在当前区域按下并且在当前区域内抬起）onmouseover    鼠标滑入onmouseout    鼠标滑出onmousedown    鼠标按下（在当前区域内按下）onmouseup        鼠标按下并释放（在当前区域内抬起即可）\n键盘事件：onkeypress    某个键盘上的按键按下并释放onkeydown    某个按键被按下onkeyup\n网页相关事件：onload    页面加载时onunload    页面关闭或者重载时onerror    脚本出现错误时onresize    窗口大小发生改变时onscroll    网页滚动条发生变化时onmove    网页窗口移动时\n表单相关事件：onblur    失去键盘焦点时onfocus    获得键盘焦点时onreset    表单重置时onsubmit    表单提交时\nDOM是一个树形结构，当一个元素被触发时，路径所经过的结点都会收到该事件，这个传播过程的顺序可称为DOM事件流。\n事件动态绑定：JS所有事物都是对象，如果获得对象使用：document.getElemenByID(“ID”)\n事件监听器：addElementListener(event, function, useCapture)参数event表示监听的事件，不加on，比如click，touchstart等。函数可以是外部函数或者匿名函数。useCapture选择true表示捕获，false表示冒泡。\nDOM\n\nDOM是一个树\nDOM方法访问元素节点：getElementById(“”)getElementByName(“”)    通过name属性值来查找getElementByTagName(“”)    通过标签名来查找，返回一个对象集合，返回的顺序是它们在文档中的顺序getElementByClassName(“”)    通过样式名来查找\n创建，插入节点：createElement()    创建元素节点createTextNode()    创建文本节点createAttribute()    创建属性节点appendChild()    把新的子节点添加到指定节点insertBefore()    在指定的节点前面插入新的子节点\n替换，删除节点：removeChild()    删除子节点replaceChild()    替换子节点\n获取，设置属性节点：getAttribute()    获取元素节点的属性setAttribute()    可以新增一个属性或者修改原来的属性节点    \nDOM属性innerHTML    innerHTML可与获取或者修改子节点的HTML结构，可以代替createElement()innerText    innerText可以获取或者修改节点的文本，nodeValue    规定了节点的值，元素的nodeValue是undefined或者Null；文本节点的nodeValue是文本本身；属性节点的nodeValue是属性值。nodeType    返回节点的类型\nDOM操作样式style属性    修改样式使用style.属性名class属性    通过className属性读取或者设置类样式\nBOM\n\nBOM和DOM的关系：DOM中的document对象也是window的子对象使用window对象时可以省略window，例如window.alert()可以略写成alert()。\nwindow对象常用方法prompt()    显示可以输入的对话框confirm()    显示一段消息，以及确认和取消按钮的对话框open()    打开某一个窗口close()    关闭浏览器窗口setInterval()    每隔指定的时间执行代码。clearInterval()    取消setInterval()的设置。setTimeout()    在指定的延迟时间之后来执行代码。clearTimeout()    取消setTimeout()的设置\n错题小记以下句子为正确易错的句子：\n\n静态网页都会显示固定的信息\n\nWEB 就是我们说网页，它是一系列技术的复合总称（包括网站的前台布局、后台程序、美工、数据库开发等），我们称它为网页，HTTP (英文Hypertext transfer protocol的缩写) 中文译为超文本传输协议，DNS （英文Domain Name System的缩写）是域名解析系统。这三个都是网页术语。\n\nWeb标准是由W3C与其他标准化组织共同制定的，不是各大厂商联合制定的。\n\nXHTML是更严谨纯净的HTML版本\n\nHTTP和HTTPS的差异：简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全。\n\nJavaScript可以做很多事情，但最主流的应用是在Web上创建网页特效或验证信息。\n\n标签就是放在“&lt; &gt;”标签符中表示某个功能的编码命令。\n\nHTML5扩展名：.html和.htm\n\n可以调整图像垂直边距的属性是：vspace\n\nHTML5的优势主要体现在兼容、合理、易用三个方面。\n\ncite标签可以创建一个引用，用于对文档引用参考文献的说明，一旦在文档中使用了该标签，被标注的文档内容将以斜体的样式展示在页面中，以区别于段落中的其他字符。\n\n层叠性是指多种CSS样式的叠加。而不是子标签会继承父标签的某些样式。\n\nCSS注释只有一种写法：/* 注释语句 */\n\n如果使用RGB代码的百分比颜色值，取值为0时也不能省略百分号，必须写为0%。\n\n并不是所有的CSS属性都可以继承。下面的属性就不具有继承性：边框属性，如border、border-top、border-right、border-bottom等外边距属性，如margin、margin-top、margin-bottom、margin-left等内边距属性，如padding、padding-top、padding-right、padding-bottom等背景属性，如background、background-image、background-repeat等定位属性，如position、top、right、bottom、left、z-index 等布局属性，如clear、float、clip、display、overflow等元素宽高属性，如width、height\n\nCSS3最突出的优势主要体现在节约成本和提高性能两方面。\n\n临近兄弟选择器使用加号“+”来链接前后两个选择器。\n\n子元素择器主要用来选择某个元素的第一级子元素。\n\nE[att$=value] 属性选择器是指选择名称为E的标签，且该标签定义了att属性，att属性值包含后缀为value的子字符串。\n\n：not选择器：如果对某个结构标签使用样式，但是想排除这个结构元素下面的子结构元素，让子结构元素不使用这个样式，可以使用:not选择器。\n\nRGBA模式用于设置背景与图片的不透明度。\n\npadding属性不允许使用负值。\n\n无序列表是网页中最常用的列表，之所以称为“无序列表”，是因为其各个列表项之间没有顺序级别之分，通常是并列的，并不存在主导从属的关系。\n\n当不设置list-style-position属性时，列表项目符号位于列表文本以外（默认值）。\n\n在HTML语言中，&lt;th&gt;标签用于设置表格的表头。\n\n在&lt;textarea&gt;表单控件中，cols用来定义多行文本输入框每行中的字符数\n\nautocomplete属性用于指定表单是否有自动完成功能，所谓“自动完成”是指将表单控件输入的内容记录下来，当再次输入时，会将输入的历史记录显示在一个下拉列表里，以实现自动完成输入。\n\n“overflow:visible;”：内容不会被修剪，会呈现在元素框之外（默认值）。\n\nz-index属性取值可为正整数、负整数和0\n\n在网页中，常用的命名方式有“驼峰式命名”和“帕斯卡命名”两种。 \n\n在HTML5中嵌入的视频格式主要包括ogg、mpeg4、webm\n\ntransition-duration属性用于定义完成过渡效果需要花费的时间。\nanimation-timing-function用来规定动画的速度曲线。\nanimation-duration属性用于定义整个动画效果完成所需要的时间。\nanimation-name属性用于定义要应用的动画名称。transition-delay的属性值可以为正整数、负整数和0。当设置为负数时，过渡动作会从该时间点开始，之前的动作被截断；设置为正数时，过渡动作会延迟触发。\n\n在CSS3中，transform属性可以实现网页中元素的变形效果。CSS3变形效果是一系列效果的集合，例如平移、缩放、倾斜和旋转。使用transform属性实现的变形效果，无需加载额外文件，可以极大提高网页开发者的工作效率和页面的执行速度。transform属性的基本语法如下：transform：none|transform-functions;在上面的语法格式中，transform属性的默认值为none，适用于行内元素和块元素，表示元素不进行变形。transform-function用于设置变形，可以是一个或多个变形样式，主要包括translate ()、scale()、skew()和rotate()等，具体说明如下： translate()：移动元素对象，即基于X和Y坐标重新定位元素。 scale()：缩放元素对象，可以使任意元素对象尺寸发生变化，取值包括正数、负数和小数。 skew()：倾斜元素对象，取值为一个度数值。 rotate()：旋转元素对象，取值为一个度数值。\n\nanimation属性是一个简写属性，用于在一个属性中设置animation-name、animation-duration、animation-timing-function、animation-delay、animation-iteration-count和animation-direction六个动画属性。其基本语法格式如下：animation: animation-name animation-duration animation-timing-function animation-delay animation-iteration-count animation-direction;在上述语法中，使用animation属性时必须指定animation-name和animation-duration属性，否则动画效果将不会播放。\n\n\n","categories":["文化课"],"tags":[]},{"title":"MySql数据库入门","url":"/51347","content":"MySql数据库SQL语言学习Create命令#创建一个数据库\ncreate database [database_name]; \n\n#创建一个表\ncreate table [table_name] (\n     [  ]\n [， [ ] ] …\n [， ] \n); \n\n#创建一个视图\ncreate view   [(  [，]…)]\nas\nselect [查询内容]\n[WITH  CHECK  OPTION]；\n/*\n子查询不允许含有 order by 和 distinct 语句。\n视图只是一个表结构，不储存数据。\n使用视图和使用表的语法基本相同。\nWITH CHECK OPTION 语句使得插入操作只能插入满足视图的限制条件的元组。\n*/\n\n#创建登录用户 \ncreate user [user_name] identified by [user_password]\n#创建一个普通用户\n\n#创建数据库角色\ncreate role 'R1';\n\n\nGrant 命令#授予某个用户权限\nGrant [,]...\n[on  ] #对象可以是一个表或者是一个视图，或者是一个数据库\nto [,]\nwith grant option.\n\n#with grant option子句表示该权限可以进行传播，否则不能。\n#grant权限时可以用all表示所有的权限，或者也可以是select等具体的权限。\n#在进行授权的时候可以具体到某一个列比如说: Grant update(cname) on ...\n#to的后面也可是一个角色。\n\n#将某个角色授予某个用户\nGrant 'role_name' to [user_name];\n#这样可以批量修改一类用户的权限。\n\nRevoke命令#收回某个用户的权限\nRevoke [,]...\n[on]\nFrom [,]...\n\n#Revoke权限时可以用all表示收回所有的权限，或者也可以是select等具体的权限。\n#From的后面也可是一个角色。\n\nAlter命令#Alter命令是在建好表后修改表结构时使用的语句。\nalter table [table_name] \nadd [column_name] [数据类型] [完整性约束] \n#在表中添加一个新列\nalter table [table_name] \nadd foreign key([column_name]) references [table_name]([column_name])\n#在表中添加一外键\nalter table [table_name] \nmodify column [column_name]  [完整性约束]；\n#修改表中的一列\nalter table [table_name] drop column [column_name]\n#删除表中的一列\nalter table [table_name] drop primary key;\n#删除表的主键\nalter table [table_name] drop foreign key [key_name];\n#删除表的一个外键\n\nDrop命令#Drop命令是删除表或者数据库结构时使用的语句。\ndrop database [database_name]; # 删除一个数据库\ndrop table [table_name]; # 删除一个数据库中的表\n#注意：如果有外键，不能删除表，应该先删除外键或者先删除外键连接的表。\n\n#删除登录用户\ndrop user [user_name]\n\n\nInsert命令#插入一条元组\ninsert into [table_name]([column_name1], [column_name2] ...)\nvalues([column_name1_value], [column_name2_value] ...);\n#如果table_name后面属性列为空，则默认为定义表时的属性和顺序。\n#在table_name后面的属性可以自定义顺序。\n#插入的属性值可以是default, null或者具体的值。\n\n#插入子查询的结果\ninsert into [table_name]([column_name1], [column_name2] ...)\nselect ...\nfrom ...\nwhere ...\n\n#插入多条元组\ninsert into [table_name]([column_name1], [column_name2] ...)\nvalues([column_name1_value], [column_name2_value] ...),\n([column_name1_value], [column_name2_value] ...),\n([column_name1_value], [column_name2_value] ...),\n... ;\n\nUpdate命令#带子查询的修改语句（修改满足条件的元组）\nupdate [table_name] set [column_name1] = [column_name1_value]，[column_name2] = [column_name2_value]，\nwhere [column_name] = [column_name_value]\n#在修改值时注意实体完整性和参照完整性。\n#主码不允许修改，用户定义的完整性，NOT NULL约束，UNIQUE约束，值域约束\n\nSelect命令#一个查询语句的基本结构\nselect [all/distinct]  \n, ,  ... \nfrom , , ...\nwhere \ngroup by     having \norder by  [asc/desc]    limit (num)\n\n/*选择表中的若干列*/\n#如果选中所有的属性列那么用*来表示\n#DISTINCT关键词消除取值重复的行，如果没有指定，则缺省为ALL \n#如果要将属性列更名的话在需要更名的列后面加上 as 新名字\n#在查询语句中还可以自定义表名，方法为 from [table_name] as [new_name]\n#在定义别名的时候可以省略 as ，但是不建议。\n#目标列表达式可以为：\n/*\n算术表达式    2016 - Sage\n字符串常量    '出生年份：'\n函数    year(curdate()) //表示当前的年份\n列别名 sno as 学号\n*/\n\n/*\n常用的查询条件:\n比较运算符：=，>，=，<=，!=，<>，!>，!<；\n确定范围：\n    BETWEEN  AND ，\n    NOT BETWEEN  AND \n确定集合:\n    IN(...)，\n    NOT IN(...)\n字符匹配：\n    LIKE ''，\n    NOT LIKE ''\n通配符：\n    % 任意长度的字符\n    _ 一个长度的字符\n    / 将后面紧跟的一个符号转义成正常符号\n空值：\n    IS NULL，\n    IS NOT NULL\n多重条件（逻辑运算）:\n    AND，OR，NOT    \n    可以用括号改变优先级\n*/\n\n/*ORDER BY子句*/\n#可以按照一个或者多个属性进行排序\n#升序：ASC；降序：DESC；缺省值为升序\n#当排序列含空值时\n#ASC：排序列为空值的元组最后显示\n#DESC：排序列为空值的元组最先显示 \n#e.g.    ORDER BY Grade DESC；\n#e.g.    ORDER BY Sdept，Sage DESC； \n#limit后面跟的数字为输出表中的前几行。\n\n/*自然连接*/\nSELECT  Student.*，SC.*\nFROM    Student，SC\nWHERE   Student.Sno = SC.Sno；\n#将student和sc表将sno相同的元组自然连接然后输出\n\n/*聚集函数*/\n#聚集函数：\n/*\n计数\n    COUNT（[ DISTINCT | ALL ] *）\n    COUNT（[ DISTINCT | ALL ] ）//这两个值在all条件下是相等的\n计算总和\n    SUM（[ DISTINCT | ALL ] ）    \n计算平均值\n    AVG（[ DISTINCT | ALL ] ）\n最大最小值\n    MAX（[ DISTINCT | ALL ] ）\n    MIN（[ DISTINCT | ALL ] ）\n*/\n\n/*GROUP BY子句*/\n#细化聚集函数的作用对象\n/*\n 未对查询结果分组，聚集函数将作用于整个查询结果\n 对查询结果分组后，聚集函数将分别作用于每个组 \n 作用对象是查询的中间结果表\n 按指定的一列或多列值分组，值相等的为一组\n*/\n\n/*Having子句*/\n#Having短语作用于组，从中选择满足条件的组\n#Where子句作用于基表或者视图，从中选择满足条件的元组\n\n/*ORDER BY子句*/\n#将结果进行排序之后再输出\n/*\nASC 升序（小的在前面）\nDESC 降序（大的在前面）\n缺省为升序\norder by 后面可以跟多个列名，按照顺序进行排序。\n*/\n#当排序存在空值时\n/*\nASC 空值的元组最后显示\nDESC 空值的元组最先显示\n*/\n\n/*limit子句*/\n#只输出排序结果中的前num个元组。\n#limit 3 的意思是输出前三行，limit 1,3 的意思是输出2道4行\n#表中的元组的序号是从0开始的\n\n/*Percent子句（！该知识点没有细讲，考试不考）*/\n/*\nselect top  percent ...\nfrom ...\nwhere ...\n表示输出前半分之n的数据，如果结果不够一条的话会向上取整为一条。\n*/\n\n/*into子句（！该知识点没有细讲，考试不考）*/\n/*\nselect * into [table_name] \nfrom ...\nwhere ...\n表示将查询结果保存到table_name的表中。\n*/\n\nSelect查询进阶/*连接查询*/\n#将两个表进行自然连接\nselect *\nfrom A, b\nwhere A.a = B.a;\n#将三个表进行自然连接\nselect *\nfrom A, B, C\nwhere A.a = B.a and A.a = C.a;\n#将一个表进行自身连接\nselect A.a, A.pa, B.pa\nfrom table1 as A, table1 as B\nwhere A.pa = B.a;\n/*\n[例35]查询每一门课的间接先修课（即先修课的先修课），输出：课程号、先修课的课程号、先修课的先修课的课程号。\n*/\n/*\nSELECT  FIRST.Cno, FIRST.Cpno, SECOND.Cpno\nFROM  Course As FIRST，Course As SECOND\nWHERE FIRST.Cpno = SECOND.Cno；\n*/\n#两个表用inner join来写自然连接\nselect *\nfrom A inner join B on (A.a = A.b)\nwhere ...\n#两个表用left outer join来写左外连接\nselect *\nfrom A left outer join B on(A.a = B.a)\nwhere ...\n#两个表用right outer join来写右外连接\nselect *\nfrom A right outer join B on(A.a = B.a)\nwhere ...\n#嵌套查询\n/*将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询*/\n#不相关子查询\nselect *\nfrom A \nwhere a in (\n    select a\n    from B\n    where ...\n);\n#相关子查询\nselect *\nfrom A \nwhere a in (\n    select a\n    from B\n    where A.b = B.b and ... \n);\n/*可以进行多层嵌套，当可以确定内层返回为单值的话，in可以用=或者等代替。*/\n#带有ANY和ALL谓词的子查询\nselect *\nfrom A\nwhere a >= ANY(\n    select a\n    from B\n    where ...\n);\n/*ANY表示查询结果中的某个值，ALL表示查询结果中的所有值*/\n#带有EXISTS谓词的子查询\n/*存在谓词谓词的查询不返回任何数据，只产生逻辑真值或者逻辑假值，若内层查询为空则返回假，若内层查询为非空则返回为真。\nEXISTS内层只要有结果，外层对应的记录就输出。\nNOT EXISTS内层只要没有结果，外层就被输出。\n*/\nselect *\nfrom A\nwhere exists (\n    select *\n    from B\n    where ...\n)\n#集合查询：交并差查询\n#Union, Intersect, Except。\n/**/\n\nDelete命令#带查询的删除（删除满足条件的元组）\ndelete \nfrom [table_name]\nwhere ...\n#where中的语句格式和select的where一样。\n\n其他常用命令show databases;\nselect database();\nuse [database_name];\nDESC [table_name];#查看该表的结构\nselect user();#查看当前用户\nselect * from mysql.user #查看所有用户\n#用户授权\n\n数据类型int\nsmallint\nchar([num])\nvarchar([num])#变长字符串\ndate\nenum(a, b, ...) #枚举类型，值只能是枚举集合中的一个元素\n\n常用约束条件default [val] # 默认值\nunique # 唯一性约束\nnot null # 非空值约束\nprimary key([column_name],...) # 主码约束\nforeign key([column_name]) references [table_name]([column_name]) # 外键约束\nchekc([条件])    # 用户定义\nauto_increment # 序号自动加一\nconstraint [constraint_name]  # 为后面的限制条件起一个名字\non delete \n    no action\n    cascade\n    set null\n#在外键被参照的元组的属性进行删除时进行参照的元组的属性值的变化情况\non update \n    no action\n    cascade \n    set null\n#针对外键被参照的元组的属性进行更新值时进行参照的元组的属性值的变化情况\n\n常用列函数Count()    #统计某一列的元组数量，某一列的Count运算结果和Count(*)的结果是相等的。\nSum()    \nAvg()\nMax()\nMin()\n\n数据库考试复习笔记知识点：三类经典的数据模型是：1.层次模型，2.网状模型和3.关系模型。\n数据库的保护措施有1.安全性控制，2.完整性控制，3.并发控制和4.数据库恢复等。\n事务的四个性质是：1.原子性，2.一致性，3.隔离性，4.持久性。\n并发控制的主要方法是封锁，封锁有两种类型：即1.排它锁（X锁，写锁），2.共享锁（S锁，读锁）。\n故障恢复的基本手段有：1.数据转储，2.登记日志文件。\n数据库设计的步骤有：1.需求分析，2.概念结构设计，3.逻辑结构设计，4.物理设计，5.数据库实施，6.数据库的运行和维护。\n并发控制带来的三种数据不一致是：1.丢失数据，2.不可重复读，3.读脏数据。\n数据模型的三要素：1.数据结构，2.数据操作和3.数据完整性。数据结构是对数据系统的静态特性的描述，数据操作是对数据库系统的动态特性的描述。\n数据库系统的故障：1.系统故障，2.事务故障，3.介质故障，4.计算机病毒。\n当局部E-R图合成为全局E-R图时，可能出现冲突：1.属性冲突，2.结构冲突，3.命名冲突。\n传统的关系运算：1.交，2.并，3.差，4.笛卡尔积。\n专门的关系运算：1.选择，2.投影，3.连接，4.除。\n基本运算是：1、并，2、差，3、选择，4、投影，5、乘积（笛卡尔积）\n数据库的完整性是指：1.正确性，2.相容性 ， 3.有效性。\n一个关系模式的定义主要包括：1、关系名，2、属性名、3、属性类型、4、属性长度、5、关键字。\n关系数据库中基于数学上两类运算是1、关系代数、2、关系演算。\n数据库是长期存储在计算机内，有1.组织的，2.可共享的数据集合。\n数据库管理系统的主要功能有1.数据定义功能，2.数据库的组织存储和管理，3.数据操纵功能，4.数据库的运行管理和5.数据库的建立及维护等。\nSQL语言具有1、数据定义、2、数据操纵、3、数据控制的作用。\nSQL语言具有两种使用方式，分别为1、交互式SQL和2、嵌入式SQL。\n参照完整性是指在基本表中，外码可以是1、空值或者2、另一个关系主码的有效值。\n数据冗余可能导致的问题有：1、浪费存储空间及修改麻烦，2.潜在的数据不一致性。\n安全性控制的一般方法有：1、用户标识鉴定、2、存取控制、3、审计、4、数据加密。\n存取权限包括两方面的内容：1、要存取的数据对象，2、对数据对象进行操作的类型。\nDBMS存取控制极值主要包括两部分：1、自主存取控制，2、强制存取控制。\n在关系数据库规范化理论中，在执行分解时，必须遵守规范化原则：1、保持原有的依赖关系，和2、无损连接性。\n易错点：数据库在磁盘上的基本组织形式是文件。\n数据库的概念模型独立于具体的机器和DBMS。\n数据库是存储在计算机内有结构的数据的集合。\n在数据库中，产生数据不一致的根本原因是：数据冗余。\n数据库系统的最大特点是：数据的三级模式和二级映像。\n实体与之对应的数据库术语为记录。\n层次模型不能直接表示多对多的关系。\n数据库奠基人E.F从1970年起发表过多篇论文，主要论述的是关系数据模型。\n关系运算中花费时间可能最长的运算是：除\nSQL语言是非过程化语言。\nSQL是结构化查询语言。\n在SQL sever 中删除触发器用 DROP。\n关系规范化理论是设计逻辑结构的指南和工具。\n对于非规范化的模式，经过使属性域变为简单域转变为1NF，将1NF经过消除非主属性对主关键字的部分依赖转变为2NF，将2NF经过消除非主属性对主关键字的传递依赖转变为3NF。 \n数据流程图（DFD）是用于描述结构化方法中需求分析阶段的工具。\n在数据库设计中，把数据需求携程文档，他是各类数据描述的集合，包括数据项，数据结构，数据流，数据存储和数据加工过程等的表述，通常称为数据字典。\n若数据库中质保函成功事务提交的结果，则此数据库就称为处于一致状态。\n数据库恢复是将数据库从错误状态恢复到某一已知正确的状态的功能。\n数据库系统是利用存储在外村上其他地方的冗余数据来重建被破坏的数据库，他主要有两种：1.后援副本，2、日志文件。\n死锁不是并发操作带来的数据不一致性的问题。\n事务是用户定义的一个数据库操作序列。\n简答：试述视图的作用？ \n\n视图能够简化用户的操作。（1 分） \n\n视图使用户能以多种角度看待同一数据。（1 分） \n\n视图对重构数据库提供了一定程度的逻辑独立性。（1 分） \n\n视图能够对机密数据提供安全保护。（1 分） \n\n\n登记日志文件时必须遵循什么原则？登记日志文件时必须遵循两条原则： \n\n登记的次序严格按并发事务执行的时间次序。（1 分） \n\n必须先写日志文件，后写数据库。（2 分） \n\n\n简述系统故障时的数据库恢复策略：\n\n正像扫描日志文件，找出在故障发生前已经提交的事务，将其事务标识记入 REDO队列。同时找出故障发生时尚未完成的事务，将其事务标识记入 UNDO队列。\n对 UNDO队列中的各个事务进行撤销处理。\n对REDO队列中的各个事务进行重做处理。(错一个扣1.5分，全错不得分)\n\n简述等值连接与自然连接的区别和联系：\n连接运算符是“=”的连接运算称为等值连接。它是从关系 R 与 S 的广 义笛卡尔积中选取 A，B 属性值相等的那些元组。自然连接是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是相同的属性组，并且在结果中把重复的属性列去掉。                                           \n说明视图与基本表的区别和联系？ \n视图是从一个或几个基本表导出的表，它与基本表不同，是一个虚表，数据库中只存放视图的定义，而不存放视图对应的数据，这些数据存放在原来的基本表中，当基本表中的数据发生变化，从视图中查询出的数据也就随之改变。视图一经定义就可以像基本表一样被查询、删除，也可以在一个视图之上再定义新的视图，但是对视图的更新操作有限制\n简述事务的特性。 \n事务具有四个特性，即 ACID 特性：\n\n原子性：事务中包括的所有操作要么都做，要么都不做。 \n\n一致性：事务必须使数据库从一个一致性状态变到另一个一致性状态。 \n\n隔离性：一个事务内部的操作及使用的数据对并发的其他事务是隔离的。 \n\n持续性：事务一旦提交，对数据库的改变是永久的。 \n\n\n试述数据、数据库、数据库管理系统、数据库系统的概念。 \n数据：描述事物的符号记录。（1 分）数据库：长期存储在计算机内的、有组织的、可共享的数据集合。（1 分）数据库管理系统：是位于用户与操作系统之间的具有数据定义、数据操纵、数据库的运行管理、数据库的建立和维护功能的一层数据管理软件。（1 分）数据库系统：在计算机系统中引入数据库后的系统，一般由数据库、数据库管理系统(及其开发工具)、应用系统、数据库管理员和用户构成。\n","categories":["技术"],"tags":["数据库"]},{"title":"刷题柱","url":"/58203","content":"kuangbin刷题柱Dungeon Master（5.23）bfs，细节在于搜索到点之后入队时就进行标记已经搜索到了。不然会反复入队导致超时。\nFind The Multiple（5.25）一个技巧，在dfs中如果不想让递归回到上一层之后继续执行的话，不要把dfs的返回类型设为void，而是设为bool，让多层的dfs返回到上一层就遇到一个if，就保证找到答案之后就会返回，不会寻找到多个值。常常用于有spj的搜索题。\nPrime Path（8.1）水题，素数筛 + bfs。\nShuffle’m Up（8.2）水题，字符串模拟。注意：字符串为空的时候不要进行下标赋值，会出现问题，用s.push_back向空字符串中放置字符，否则会出现下标可以访问字符但是整体字符串为空的情况发生。\nPots（8.2）BFS，寻找最小变换次数即最小步数。比较特殊的是这个需要保存操作的步骤，可以用一个三维vector来保存每一次操作的动作编号，然后在到达状态之后依次输出即可。\nFire Game（8.3）离谱的是FZU挂掉了，没办法评测，样例都过了， 复习了一下如何求联通块的个数和双起点BFS。经验：下次做题前看一下uoj在那个网站提交的标志是不是红色。。。\n分类刷题柱队列蚯蚓（5.4）https://ac.nowcoder.com/acm/problem/16430\n这道题的解法是维护三个单调队列，由题可知蚯蚓切完的性质仍然满足蚯蚓的长度是依次递减的，由于是按照比例切的，那么切的是相同比例的蚯蚓放到一个队列中，由于靠前切的蚯蚓一定切出来的也是比之后切出来的蚯蚓长，所以当前的最长的蚯蚓只需从这三个队列中找到队头即可。\nCow Line（5.5）https://ac.nowcoder.com/acm/problem/24876\n这道题就是一个简单的双端队列的模拟，题中数据的范围是模拟可以接受的，看出来题考的数据结构是双端队列就行了，维护两边的进队和出队即可。\nTeam Queuehttps://ac.nowcoder.com/acm/problem/50966\n又是一道模拟题，团队队列只需用团队编号作为大队伍的标志，然后再委会每一个团队队列的内部次序即可。用一个queue和一个queue数组和一个map即可，细节还行，难度适中。出现的问题是数组越界了。最后发现标志该团队是否入大队列的bool数组并不是必要的。可以用检查该团队队列是否为空来代替。\n长跑（5.6）https://ac.nowcoder.com/acm/problem/14570\n是道队列bfs，从起点开始搜索，如果当前节点加上maxn可以到达并且钱够的商店就入队，然后如果碰到终点就退出。就是一道朴素的bfs，但是如果看不出来的还是有点迷惑的。\n道路铺设（5.8）https://ac.nowcoder.com/acm/problem/21222\n再次做到NOIP2018提高组的题，感慨万千。隐约记得在考场上发现是前两天做过的原题的兴奋的心情了。当时的我先发现是差分，处理出差分数组之后经过观察是差分数组为正值的所有值的和即为答案，当时并没有经过严谨的证明，隐约感觉正值和负值之间一定会相互抵消。今天重新写到，当时的感觉重新涌上心头。\n其实就是一道水题，并不是优先队列，差分之后将正值加到一块即可。可以进行一个简单的证明，一个数列的差分数组的所有元素的和一定为0，那么想要将这个差分数组的正数变为0，那么每一个正数都要和负数相对应结合。其中一个问题是如果确定进行变化的一对差分中间没有0，其实这也好证明，因为每一个正数会找到最近的一个负数进行中和，那么可以保证在对更远的负数进行中和的时候，比较最近的负数已经进行了中和，级这个比较大的数通过和附近的数进行中和，已经和周围的数的大小基本相同，所以不会出现跨过一个比较小的数然后进行更行的情况发生。第二个问题是，会不会出现前面的正数不能将一个比较大的负数使用完就直接跳到后面的正数了，显然也是不会的，因为这个数列是一个正整数列。\n栈好串（5.7）https://ac.nowcoder.com/acm/problem/21874\n一个栈的水题。\n吐泡泡https://ac.nowcoder.com/acm/problem/15029\n一个栈的应用，水题。\n表达式计算4（5.8）https://ac.nowcoder.com/acm/problem/50999\n栈的经典应用，表达式求值。这是一个中缀表达式求值。维护两个栈，一个栈存数字，一个栈存符号，数字进栈没有什么要求，如果有一个符号要进栈的话，先把比该符号优先级高的在符号栈中的符号都先弹出栈，符号两边的数字进行运算。这样就保证了每一个运算都是优先级高的先运算。模拟的过程会比较繁琐，而且注意栈如果为空的话调用栈的.top()会报错，所以把原来的表达式的最外层加一对括号来保护。\n括号画家https://ac.nowcoder.com/acm/problem/50998\n括号匹配，寻找最长合法括号匹配串。由于如果出现不合法的情况，那么之前的合法的长度就不能加到后面的括号序列上了。所以只需维护一个括号匹配栈即可，如果出现了不合法的情况就将最长串和目前的最长串进行一个更新即可，最后答案中的长度就是最长的合法括号字串的长度。\n并查集奶酪（5.8）https://ac.nowcoder.com/acm/problem/16417\n经典并查集例题，怎么写都能过的无极数据友好的题，只用将两两洞进行测距然后看距离满足，如果满足就直接将两个洞用并查集连在一起。然后看离地下比较近的洞和离上面比较近的洞是否联通即可。这道题应该也可以用其他测联通的方法写出来。\n关押罪犯https://ac.nowcoder.com/acm/problem/16591\n并查集的经典应用，一个非常好的思路是：我们将并查集的f数组进行拓展一下来表示更多的状态，来简化一些比较困难的逻辑表示。我们将f数组拓展一倍，i表示一个监狱i+n表示另一个监狱。我们对于每一对罪犯，都默认将他们装到不同的两个监狱中即a和b+n，a+n和b，然后检查他们在相同的监狱中是否出现冲突。这个做法其实是将一个状态拆成了比较好表示的两个状态。将逻辑上很复杂才能检测的问题变成一些很简单能判断的问题。这种方法叫做建立虚点。\n虚点的建立可以拓展表示一个点的多个状态。\n食物链（5.9）https://ac.nowcoder.com/acm/problem/16884\n这题本质上应该是然用带权的并查集来写，但是有一种比较好写的方法是开虚点。用三倍的n的数组来表示每一个点的三个不同性质，对不同性质之间进行操作，这样就减小了处理复杂问题的难度。\n棋盘问题（5.15）http://poj.org/problem?id=1321\n一道经典的搜索题，用dfs进行搜索，一个控制层数，一个控制放了几个棋子。注意dfs中需要将每一层的情况都列出来。\n刷题打卡墙5.8： 5道。挺麻的，又开始觉得自己是个fw了\n5.15：1道题，被张宇说的网络流刺激到了，又滚来刷题了。\n5.23：1道题，kuangbin的题单质量就是高，把之前的一道题改对了，还是浮躁，张文军教练的话，很有道理。\n\n5.24：1道题，今天晚上有cf的#722的div2的比赛。但是进晚了怕掉分没打，写了一下t1，水体一道。\n5.25：1道题，kuangbin的搜索专题。\n","categories":["竞赛"],"tags":[]},{"title":"观影小记","url":"/56512","content":"2021/4/15《卡尔·拉格斐：孤独的时尚大师》\n摘录：\n博物馆成了一个地方的商店，商店成为了一个地方的博物馆。\n“我只是想拒绝平庸而已。”\n感想：\n法国的文艺记录片，镜头很有冲击力，剪辑感觉很有想法，但是看完这个纪录片之后，并没增加我对卡尔·拉格斐的理解或者认识...像是一个宣传片，又像是一个没有主题和内容的谈话节目。\n关于卡尔·拉格斐：\n卡尔·拉格斐（1933年9月10日-2019年2月19日，Karl Lagerfeld），出生于德国汉堡市，德国著名服装设计师。人们称他为“时装界的凯撒大帝”或是“老佛爷”。\n说起卡尔·拉格斐，脑海里的第一反映永远是Chanel的艺术总监招牌式的表情，佩戴着墨镜，手拿抓扇、脑后拖着辫子，就是这永恒的墨镜白发长辫的人却占领时尚圈制高点。\n他永远像“吃饱人参”一样精力旺盛，精通德、英、法、意文，妙语连珠，他情迷传统，又憧憬未来，被传媒封为“当代文艺复兴的代表”。\n\n《绣春刀》\n感想：\n适合一个人啃着鸭脖，喝着啤酒和可乐一个人看的电影。本质上和喝着啤酒和可乐看的足球比赛是一个性质，只不过说足球比赛可能更平淡一些，这个电影的节奏会更快那么一丢丢。\n\n《忠犬八公的故事》\n我发现一个规律，好的经典电影都喜欢以讲回忆或者故事的方式来推动剧情。比如说《泰坦尼克号》或者《阿甘正传》等等。\n我觉得以回忆的方式来处理故事之间的人物关系是一个很巧妙的方法，时过境迁，回到现实之后经历过回忆中的故事的主人公留给人们更多的想象了。\n感想：\n这部电影是一个好的故事，很完整，很动人。\n仔细想想还能想出一些故事之外的道理。\n\n","categories":["生活"],"tags":[]},{"title":"竞赛算法复习笔记","url":"/50622","content":"树与图邻接表用head数组为表头，使用ver和edge数组分别存储边的终点和权值，用next数组模拟链表指针。\n在一个图中添加一个从x到y边的权值为z的有向边：\nint head[maxn &lt;&lt; 2], ver[maxn], edge[maxn], next[maxn &lt;&lt; 2];\nint tot;//tot表示边的编号 \ninline void adde(int x, int y, int z) {\n    ver[++tot] = y;    next[tot] = head[x]; //这句话表示原来x指向的所有边都挂到tot这条新的边的后面。 \n    head[x] = tot;    edge[tot] = z;//这句话表示在x原来指向的tot边的前面插入了新来的这个边。 \n}\n\n图从x访问所有x相连的点。\nvoid serch() {\n    for (int i = head[x]; i; i = next[i]) {\n        //从x的最后输入的那条边开始，便利所有x为出发点的边。next数组是为指出x出发的每一条边之间的关系。\n    }\n}\n\n图从x的一个深度优先遍历。\nbool v[maxn];\nvoid dfs(int x) {\n    v[x] = 1;\n    for (int i=head[x]; i; i = next[i]) {\n        int y = ver[i];\n        if (v[y])    continue;\n        dfs(y);\n    }\n}\n//这个搜索的时间复杂度是O(n+m)。\n\n树的dfs序。\nvoid int(x) {\n    a[++m] = x;\n    v[x] = 1;\n    for (int i = head[x]; i; i = next[i]) {\n        int y = ver[i];\n        if(v[y])    continue;\n        dfs(y);\n    }\n    a[++m] = x;\n}\n\n树的深度。\nint d[maxn];\nvoid dfs(int x) {\n    v[x] = 1;\n    for(int i = head[x]; i; i = next[i]) {\n        int y = ver[i];\n        if(v[y])    continue;\n        d[y] = d[x] + 1;\n        dfs(y);\n    }\n}\n//d[i]中储存的是编号为i的节点从根节点往下的深度。\n\n树的重心。\n定义：设max_part(x)表示再删除节点x后产生的子树中，最大的一颗的大小。是max_part函数取到最小值的节点p就成为整棵树的重心。下面的代码我们可以统计出size数组，并且找到这棵树的重心。\nint size[maxn];\nvoid dfs(int x) {\n    v[x] = 1; size[x] = 1;\n    int max_part = 0;//删掉子树x之后分成的若干个子树中最大的那个的大小 \n    for (int i=head[x];i;i=next[i]) {\n        int y = ver[i];\n        if (v[y])    continue;\n        dfs(y);\n        size[x] += size[y];//从子节点向上更新 \n        max_part = max(max_part, size[y]);//x的子节点中最大的那个节点的size \n    }\n    max_part = max(max_part, n - size[x]);//现在max_part中储存的是删掉x之后形成的若干个子树中最大的那个大小 \n    if (max_part &lt; ans) {\n        ans = max_part;\n        pos = x;//pos中储存的就是这个树的重心的节点号。\n    } \n} \n\n图的连通块的划分\nint cnt;\nvoid dfs(int x) {\n    v[x] = cnt;\n    for (int i=head[x];i;i=next[i]) {\n        int y = ver[i];\n        if (v[y])    continue;\n        dfs(y);\n    }\n}\nfor (int i=1;i&lt;=n;++i) {\n    if(v[i]) continue;\n    cnt++;\n    dfs(i);\n}//cnt值相同的节点在同一个连通块中，cnt值表示连通块的个数。\n\n图的广度优先遍历按照层级进行遍历。\nvoid bfs() {\n    memset(d, 0, sizeof(d));//d中存储的是每一个节点的深度。\n    queue&lt;int> q;\n    q.push(1);d[1] = 1;\n    while(q.size()) {\n        int x = q.front();    q.pop();\n        for (int i=head[x];i;i=next[i]) {\n            int y = ver[i];\n            if (d[y]) continue;\n            d[y] = d[x] + 1;\n            q.push(y);\n        } \n    }\n}\n\n拓扑排序这个算法可以判断是否存在环：如果cnt和n不相等的话，那么存在环，因为环中的每一个点的入度都不可能为0。\nint deg[maxn];\nvoid add(int x, int y, int z) {\n    ver[++tot] = y;    next[tot] = head[x];\n    head[x] = tot;    edge[tot] = z;\n    deg[y]++;\n}\nvoid topsort() {\n    queue&lt;int> q;\n    for (int i=1;i&lt;=n;++i)\n        if (deg[i] == 0)    q.push(i);//如果点的入度为0那么将这个点入队。\n    while(q.size()) {\n        int x = q.front();     q.pop();\n        a[++cnt] = x;//将入度为0的那个点输出。\n        for (int i=head[x];i;i=next[i]) {\n            int y = ver[i];\n            if (--deg[y] == 0)    q.push(y);\n        }\n    }\n}\nint main() {\n    cin >> n >> m;\n    for (int i=1;i&lt;=m;++i) {\n        int x, y;\n        cin >> x >> y;\n        adde(x, y, 0);\n    }\n    topsort();\n    for (int i=1;i&lt;=cnt;++i) {\n        cout &lt;&lt; a[i] &lt;&lt; ' ';\n    }\n}\n\n","categories":["竞赛"],"tags":["搜索"]},{"title":"郑州轻工工业20级新生赛","url":"/29692","content":"今天是3月14号。\n分数：10道题，A了6道题。\n\n\n今天的题还算比较友好，因为是郑州轻工工业的新生选拔赛，所以题目都比较基础。算是第一次比较正式的完整的参加了一次ACM赛制。感受还是很深的。\n首先我这一次的比赛开题顺序是有问题的…. 可以看到榜的记录上我第一道AC是在30分钟左右的时候。本来我对于这套题的认识出现了一点偏差，我本来以为这是一套巨难无比的刷我们威风的一套题。所以拿到题之后，看了前3道题之后觉得整体难度挺高的。就误认为a题就是签到题了。（因为其实a题的思路真的挺直接的。）于是我上来就直接开始莽a题了。但是结果其实很悲惨，由于我菜的一批的代码能力。让我没有很顺利的A掉a题。当我第一遍调完a题之后，时间已经来到了30分钟。心情十分郁闷的我看了眼榜单，发现好像签到题在后面，看完题就知道这场名次一定不太好了。于是赶紧过掉了几道签到题。当我跟随榜单的脚步把几道比较简单的题A掉之后。我的名次就逐渐跟上了第一部队。由于这场比赛允许使用纸质资料，所以这场比赛也不完全是由我独立完成的，一道二位前缀和的题我看了书中的代码。所以这也反映出我的知识点掌握能力还处于看到想到思路但是没法很好实现或者实现细节掌握并不是十分熟练的阶段。这是一个现阶段很大的问题。\n列一下这次比赛出现问题的知识点：\n\n博弈论\n二位前缀和（不熟练）\n\n（这是一个赛后总结帖，补题不在这个帖子上）\n列一下这次比赛出现的比赛技巧的问题：\n\n没有使用好acm排名榜单的作用。（跟着大佬做题，大佬开题跟着做就行了）\n\n没有完全理解acm排名的规则（先过水题，这样总时间会少一点。而不是上来无脑肝大题）\n\n\n写一下最近这段时间的计划：\n要开始拾起来之前的算法了，可以看到高中剩下来的老本基本上已经快吃完了，高中是竞赛队员的优势已经不是十分明显了。要考虑如何利用高中时的一些学习思路或者学习习惯来制造现阶段的继续领先了，可以看到20级中有一些学习势头很猛的学生，想要保持持续的领先需要开始真正的努力了。\n高中的经验告诉我，可以按照算法竞赛的知识树的顺序进行学习，而且由于大部分的知识其实已经学习过一遍，所以记忆中是有对这些知识点难易程度的排序的。可以知道哪样的学习安排更加适合我。\n同时，高中的经验告诉我，要有学长或者自己组专项题组进行专门的强化训练，由于高中阶段的算法竞赛是进行停课集训，所以刷题是在大段的时间中进行的，那样的刷题是连续的，对于知识点的理解也有利于加强。但是在大学首先没有了打断整块的时间进行算法训练，而且也没有了聚在一起的机房的队友可以有一个很好的氛围来督促自己学习算法。集中学习的要素由高中的集中起来，变成了大学的分散来到每一天的零碎时间中。这是对时间安排的更进一步的要求。\n我想起来了我在高三时在当时机房一个已经去西安电子科技大学的很厉害的学长，他的id我记得是cdcq。他在高中阶段算法竞赛十分的优秀，拿到了NOI的全国赛铜牌，在高三时放下了竞赛，拾起了文化课。最终去到了西安电子科技大学。在他入学后依然保持着博客的更新，但是我当时十分好奇，在高中阶段十分厉害，常常做并且出省选题的他为什么突然开始写起了基础题，开始写最最基本的板子。在当时的我认为那些板子是我都能看懂的题，这和我对他经常写一些十分复杂的题的印象产生了极大的差异，而且这样的博文持续了很长一段时间，我当时心里想：太可惜了，这么强的一个选手，竟然废掉了。直到现在，我才真正的明白，这是一种什么样的感受。算法竞赛，作为一种竞赛，需要保持长久持续的训练。一旦有一段时间的训练空白期，那将是致命的。他将会毁掉一个职业选手，他可能还存在着操作的意识，但是由于长时间的没有训练，他将不能完成最基本的东西。我觉得职业的体育选手或者电子竞技选手可以是相通的道理。https://www.cnblogs.com/cdcq/这是他的博客，有空我再看看，想一下如何度过这个时期。这将关系我如何更好的走下去。\n这其实也在提醒我，把自己当成一个普通的大一竞赛学生，不要有特殊的心理。这种心理会导致眼高手低。会导致不能很好的进步。这是一个很大的阻碍。不要再有优越的心理了，新生的水平其实也已经达到一个水平了，不要到最后自己泯然众人矣。静下心来学习东西吧。\n克服自己的心理障碍，现在总有一种感觉，觉得好像学这些已经学习过的东西没有什么意思。但是这部分东西已经忘记，复杂的东西由于这不牢的基础导致并写不了。这是一个恶性循环，而解决这个循环的方法就是沉下来开始学习东西，把那些已经学过的东西再复习一遍，以至于可以熟练掌握。而不是在眼高手低的飘。\n这就是这场比赛的总结，所思所想。希望的最后结果要不负我最初的选择吧。\n","categories":["竞赛"],"tags":["赛后总结"]},{"title":"20级训练赛(一)补题","url":"/36993","content":"A [NOIP1999 普及组] 导弹拦截题目描述某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。\n输入导弹依次飞来的高度（雷达给出的高度数据是≤50000的正整数），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。\n输入格式11行，若干个整数（个数≤100000）\n输出格式22行，每行一个整数，第一个数字表示这套系统最多能拦截多少导弹，第二个数字表示如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。\n输入输出样例输入 #1\n389 207 155 300 299 170 158 65\n\n输出 #1\n6\n2\n\n说明/提示为了让大家更好地测试n方算法，本题开启spj，n方100分，nlogn200分\n每点两问，按问给分\n思路","categories":["竞赛"],"tags":["赛后总结","DP"]},{"title":"2021牛客寒假算法基础集训营3","url":"/50724","content":"J 加法和乘法链接：https://ac.nowcoder.com/acm/contest/9983/J来源：牛客网\n题目描述有一天牛牛和牛妹在做游戏，规则如下： 桌面上摆着n张纸牌，每张纸牌上写着一个正整数，由牛牛先手轮流执行以下操作： 1.如果桌面上只剩一张纸牌，游戏结束，这张纸牌上的数字如果是奇数则牛牛胜利，反之牛妹胜利。 2.当前行动玩家选择两张纸牌，设上面的数字分别为X,Y，接下来玩家从加法和乘法中选择一个并应用到这两个数字上，得到结果为Z，接下来将选择的两张纸牌丢弃，并拿一张新的纸牌放到桌面上，在上面写上Z。 假设双方均以最优策略行动，最后谁会赢？\n输入描述:第一行一个正整数n，代表开始的纸牌数。\n第二行n个空格分隔的正整数ai代表开始纸牌上的数字。\n1≤n≤10^6\n1≤ai≤10^9\n\n输出描述:如果牛牛能赢，输出NiuNiu，否则输出NiuMei。\n\n示例1:输入\n3\n233 2333 23333\n\n输出\nNiuMei\n\n示例2:输入\n4\n1 1 1 1\n\n输出\nNiuNiu\n\n思路这道题只要在纸上进行演算一下即可，我们将两张牌的情况都列出来，可以发现，如果两张牌都是偶数的话，无论是加法还是乘法得到的都是偶数。剩下的两种情况下，加法和乘法可以一个得到偶数一个得到奇数。由此我们可以推出如果最后一次是牛妹进行操作的话，那么牛妹必胜，如果是牛牛的话，只要在最后一次不遇上两个偶数的情况就行。那么牛牛每一次的操作就是为了消除偶数，牛妹的操作就是为了造偶数。这就是两人的最优策略。\n那么，游戏的过程就变成了牛牛消一个偶数，牛妹产生一个偶数，直到最后一次判断是否有两个偶数即可。\n代码：#include&lt;bits/stdc++.h> \nusing namespace std;\nlong long n, a, cnt;\nint main() {\n    cin >> n;\n    for (int i=1;i&lt;=n;++i) {\n        cin >> a;\n        if (a % 2 == 0) cnt ++;\n    }\n    if (n == 1)    cout &lt;&lt; (cnt == 0 ? \"NiuNiu\" : \"NiuMei\"); \n    else {\n        if (cnt > 1 || n % 2 == 1)\n            cout &lt;&lt; \"NiuMei\";\n        else cout &lt;&lt; \"NiuNiu\";\n    }\n    return 0;\n}\n\n","categories":["竞赛"],"tags":["赛后总结"]},{"title":"Linux系统操作入门","url":"/11830","content":"其他图形模式与文字模式的切换方式Linux预设提供了六个命令窗口终端机让我们来登录。\n默认我们登录的就是第一个窗口，也就是tty1，这个六个窗口分别为tty1,tty2 … tty6，你可以按下Ctrl + Alt + F1 ~ F6 来切换它们。\n如果你安装了图形界面，默认情况下是进入图形界面的，此时你就可以按Ctrl + Alt + F1 ~ F6来进入其中一个命令窗口界面。\n当你进入命令窗口界面后再返回图形界面只要按下Ctrl + Alt + F7 就回来了。\nLinux 关机在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。\n正确的关机流程为：sync &gt; shutdown &gt; reboot &gt; halt\n关机指令为：shutdown ，你可以man shutdown 来看一下帮助文档。\n例如你可以运行如下命令关机：\nsync 将数据由内存同步到硬盘中。\n\nshutdown 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：\n\nshutdown –h 10 ‘This server will shutdown after 10 mins’ 这个命令告诉大家，计算机将在10分钟后关机，并且会显示在登陆用户的当前屏幕中。\n\nshutdown –h now 立马关机\n\nshutdown –h 20:25 系统会在今天20:25关机\n\nshutdown –h +10 十分钟后关机\n\nshutdown –r now 系统立马重启\n\nshutdown –r +10 系统十分钟后重启\n\nreboot 就是重启，等同于 shutdown –r now\n\nhalt 关闭系统，等同于shutdown –h now 和 poweroff\n\n最后总结一下，不管是重启系统还是关闭系统，首先要运行 sync 命令，把内存中的数据写到磁盘中。\n关机的命令有 shutdown –h now halt poweroff 和 init 0 , 重启系统的命令有 shutdown –r now reboot init 6。\n处理目录的常用命令接下来我们就来看几个常见的处理目录的命令吧：\n\nls（英文全拼：list files）: 列出目录及文件名\ncd（英文全拼：change directory）：切换目录\npwd（英文全拼：print work directory）：显示目前的目录\nmkdir（英文全拼：make directory）：创建一个新的目录\nrmdir（英文全拼：remove directory）：删除一个空的目录\ncp（英文全拼：copy file）: 复制文件或目录\nrm（英文全拼：remove）: 删除文件或目录\nmv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称\n\n你可以使用 man [命令] 来查看各个命令的使用文档，如 ：man cp。\nls (列出目录)在Linux系统当中， ls 命令可能是最常被运行的。\n语法：\n[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称\n[root@www ~]# ls [--color=&#123;never,auto,always&#125;] 目录名称\n[root@www ~]# ls [--full-time] 目录名称\n\n选项与参数：\n\n-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)\n-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)\n-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)\n\n将家目录下的所有文件列出来(含属性与隐藏档)\n[root@www ~]# ls -al ~\n\ncd (切换目录)cd是Change Directory的缩写，这是用来变换工作目录的命令。\n语法：\n cd [相对路径或绝对路径]\n#使用 mkdir 命令创建 runoob 目录\n[root@www ~]# mkdir runoob\n\n#使用绝对路径切换到 runoob 目录\n[root@www ~]# cd /root/runoob/\n\n#使用相对路径切换到 runoob 目录\n[root@www ~]# cd ./runoob/\n\n# 表示回到自己的家目录，亦即是 /root 这个目录\n[root@www runoob]# cd ~\n\n# 表示去到目前的上一级目录，亦即是 /root 的上一级目录的意思；\n[root@www ~]# cd ..\n\npwd (显示目前所在的目录)pwd 是 Print Working Directory 的缩写，也就是显示目前所在目录的命令。\n[root@www ~]# pwd [-P]\n\n选项与参数：\n\n-P ：显示出确实的路径，而非使用连结 (link) 路径。\n\n实例：单纯显示出目前的工作目录：\n[root@www ~]# pwd\n/root   &lt;== 显示出目录啦～\n\n实例显示出实际的工作目录，而非连结档本身的目录名而已。\n[root@www ~]# cd /var/mail   &lt;==注意，/var/mail是一个连结档\n[root@www mail]# pwd\n/var/mail         &lt;==列出目前的工作目录\n[root@www mail]# pwd -P\n/var/spool/mail   &lt;==怎么回事？有没有加 -P 差很多～\n[root@www mail]# ls -ld /var/mail\nlrwxrwxrwx 1 root root 10 Sep  4 17:54 /var/mail -&gt; spool/mail\n# 看到这里应该知道为啥了吧？因为 /var/mail 是连结档，连结到 /var/spool/mail \n# 所以，加上 pwd -P 的选项后，会不以连结档的数据显示，而是显示正确的完整路径啊！\n\nmkdir (创建新目录)如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。\n语法：\nmkdir [-mp] 目录名称\n\n选项与参数：\n\n-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～\n-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！\n\n实例：请到/tmp底下尝试创建数个新目录看看：\n[root@www ~]# cd /tmp\n[root@www tmp]# mkdir test    &lt;==创建一名为 test 的新目录\n[root@www tmp]# mkdir test1/test2/test3/test4\nmkdir: cannot create directory `test1/test2/test3/test4&#39;: \nNo such file or directory       &lt;== 没办法直接创建此目录啊！\n[root@www tmp]# mkdir -p test1/test2/test3/test4\n\n加了这个 -p 的选项，可以自行帮你创建多层目录！\n实例：创建权限为 rwx–x–x 的目录。\n[root@www tmp]# mkdir -m 711 test2\n[root@www tmp]# ls -l\ndrwxr-xr-x  3 root  root 4096 Jul 18 12:50 test\ndrwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1\ndrwx--x--x  2 root  root 4096 Jul 18 12:54 test2\n\n上面的权限部分，如果没有加上 -m 来强制配置属性，系统会使用默认属性。\n如果我们使用 -m ，如上例我们给予 -m 711 来给予新的目录 drwx–x–x 的权限。\nrmdir (删除空的目录)语法：\n rmdir [-p] 目录名称\n\n选项与参数：\n\n-p ：连同上一级『空的』目录也一起删除\n\n删除 runoob 目录\n[root@www tmp]# rmdir runoob/\n\n将 mkdir 实例中创建的目录(/tmp 底下)删除掉！\n[root@www tmp]# ls -l   &lt;==看看有多少目录存在？\ndrwxr-xr-x  3 root  root 4096 Jul 18 12:50 test\ndrwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1\ndrwx--x--x  2 root  root 4096 Jul 18 12:54 test2\n[root@www tmp]# rmdir test   &lt;==可直接删除掉，没问题\n[root@www tmp]# rmdir test1  &lt;==因为尚有内容，所以无法删除！\nrmdir: `test1&#39;: Directory not empty\n[root@www tmp]# rmdir -p test1/test2/test3/test4\n[root@www tmp]# ls -l        &lt;==您看看，底下的输出中test与test1不见了！\ndrwx--x--x  2 root  root 4096 Jul 18 12:54 test2\n\n利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 一次删除。\n不过要注意的是，这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录。\ncp (复制文件或目录)cp 即拷贝文件和目录。\n语法:\n[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)\n[root@www ~]# cp [options] source1 source2 source3 .... directory\n\n选项与参数：\n\n-a：相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)\n-d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；\n-f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；\n-i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)\n-l：进行硬式连结(hard link)的连结档创建，而非复制文件本身；\n-p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)；\n-r：递归持续复制，用於目录的复制行为；(常用)\n-s：复制成为符号连结档 (symbolic link)，亦即『捷径』文件；\n-u：若 destination 比 source 旧才升级 destination ！\n\n用 root 身份，将 root 目录下的 .bashrc 复制到 /tmp 下，并命名为 bashrc\n[root@www ~]# cp ~/.bashrc /tmp/bashrc\n[root@www ~]# cp -i ~/.bashrc /tmp/bashrc\ncp: overwrite `/tmp/bashrc&#39;? n  &lt;==n不覆盖，y为覆盖\n\n鸟哥的Linux私房菜第四章文章链接\nCtrl + Shift + F1 ~ F6 切换6个终端\ndate 显示当前时间\nlocale 显示当前支持的语系\ncal 显示日历\n​    cal + 年份 显示该年份的日历\nbc 简单的计算器小程序\n​    bc仅支持+ - * / ^ %运算\nnano 一个很简单的文本编辑程序，后面加上文件名即可进行编辑。\nCtrl + C 强制退出\nCtrl + D 表示EOF或者exit\nTab 按两下自动补全\nsync 将内存中的内容转存在硬盘中\n​    在关机之前记得多使用几次这个命令，防止内容的丢失\nshutdown 为关机指令\nreboot 为重启指令\n第五章文章链接\n用户分为自己，自己所在群组，其他人三种。\nsu - 切换为root账户，密码为安装系统时创建的账户的密码\nls -al 显示当前文件夹下的所有文件\n\n\n第一个字符可能为d，-，l，b，c。分别表示文件夹，文件，连接档（类似windows里面的快捷方式），周边设备（随机存储设备），键盘鼠标（一次性存储设备）\n后面三个字母一组表示每类用户的权限，r表示可读，w表示可写，x表示可执行。三组分别为：拥有者，群组内成员，非本人且没有加入本群组之外的账户。\n\n一串字母之后的一个数字是连接数，后面的两个分别是拥有者和拥有者所加入的群组。最后名字前面的是最后修改的时间，在前面一个数字是该文件的大小bytes。\n如果一个目录d的权限没有x的话就不能进入该目录。\nroot无视所有的规则。\nls - l 查看最近修改的记录\nchgrp 更改指定文件的群组。e.g.  chgrp users test.txt\nchown 更改指定文件的拥有者，e.g.  chown bin test.txt e.g.  chown root:root test.txt\ncp 对指定文件进行拷贝。e.g.  cp test.txt test2.txt\nchmod 更改文件的权限，r的权限对应的值是4，w是2，x是1，对于每个类型的用户的权限就是这些权值相加。e.g.  chmod 777 test.txt\n​    很巧妙的是，这个值唯一对应一种权限的组合。\nchmod 的另一种方法e.g.  chmod u=rwx,go=rx test.txt u表示拥有者，g表示群组，o表示其他人，a表示所有类型。\n\n\n文件是否能执行和后缀名无关，和是否有x的权限有关。文件的w权限是指可以修改文件的内容，但是不包括删除该文件。\n\n\n在有w权限的文件夹下是可以删除没有w权限的文件。\n常见的后缀名有：*.sh表示为脚本或者批处理文件，*Z *.tar *.tar.gz *.zip *.tgz表示压缩包文件 *.html *.php表示网络相关的文件。文件是否可以执行和后缀名没有关系，只和这个文件的x权限有关。\nLinux的文件系统依据：FHS\n网页中有一些关于Linux根目录下目录的主要含义的解释。\n\n目录树的简单示意图。\n绝对路径和相对路径：以根目录/开头的路径都是绝对路径，反之则为相对路径，相对路径是指当前所在路径的相对位置来定义的。\n. ./都表示当前目录 .. ../都表示上一级目录\n使用 uname -r 查看核心版本\n使用 uname -a  查看操作系统的版本\n第六章文章链接\n\nLinux中根目录中也有./和../目录，并且 ./ 目录和 ../目录是同一个目录。\ncd 表示切换目录。几个比较特殊的目录在上面的图片上都可以看出。\npwd表示显示当前的目录。pwd -P表示显示文档的实际地址，对于一些快捷方式的地址会发生区别。\nmkdir表示建立一个新目录。e.g. mkdir -p test1/test2/test3/test4会依次建立目录 e.g. mkdir -m711 test2会建立一个test2目录并且权限为711。\n​    一般情况下建立目录需要一层一层建立，加上-p选项可以将所有的目录都按照顺序依次建立起来，而且如果本来目录存在的情况下，系统不会提示错误信息。（不建议，如果出错很麻烦）。\nrmdir删除空目录。e.g. rmdir -p test1/test2/test3/test4该命令只能一层一层删除目录，加上-p可以一次性全部删除，该命令删除的目录中必须不能有别的文档或者目录，如果想要带里面的文件一起删除的话可以使用rm -r test命令来删除，（不过比较危险）。\n输入exit或者按Ctrl + D可以退出已经登录的root账户\necho $PATH可以显示当前用户的PATH路径都有哪些。在使用指令的时候会优先在PATH的路径下寻找可执行文件，如果有多个重名文件的话会优先使用先搜索到的文件。\nPATH=&quot;$&#123;PATH&#125;:/root&quot;可以将/root加入到PATH路径中。\n​    为了安全起见不要将 . 加入PATH中。\n\n\n在Bash Shell中ls -l 可以简写为ll\n\n\ncp表示copy，即对文件进行复制和粘贴。\n​    其中-i选项表示如果出现覆盖先进行询问。-a表示复制的文件的群组和时间都和原文件一样。-l表示创建一个实体链接。-s表示创建一个符号链接，即产生了源文件的一个捷径。-d表示如果复制的文件为一个捷径文件的话复制该捷径，因为cp直接复制一个捷径的话会复制源文件。cp指令可以将多个资料一次复制到一个目录中去，但是最前面一定是目录。\n\n\nrm表示remove，即移除目录或者文档。\n​    其中大部分的发行版Linux都默认rm带上了-i参数，-r很危险，同时不要将文件起名为-aaa-这种类型，因为如果这时想要删除这个文件的时候，就会报错，因为会优先检测出-a这个选项，所以文件起名一般不要用-开头。\n\n\nmv表示move，即移动文件或者目录。\n​    可以使用mv来对一个文件进行更名的操作。\n\n\ncat用来显示文档内的内容。-n选项用来带行号输出，-A用来显示所有的特殊字符和正常字符。\ntac是cat命令的反着输出的版本，从最后一行到第一行输出。\n\n\nnl命令用来带行号输出文件的内容。-b a选项用来将空白行也带上行号。-b a -n rz用来将空白行带上行号之后再前面补零。-b a -n rz -w 3用来将空白行带上行号之后再前面补零,并且规定零加上数字一共宽度为三。\n\nmore命令用来可以翻页的查看一个文档。\n\n进入more一个文档之后的一些操作如上图。对文档内的字符串进行/查找之后按n查看下一个查找到的字符串。\n\nless命令也是可以翻页查看一个文档，功能比more更加的强大。\n\n\nhead命令用来取出前面的几行。\n\n在不加上-n选项的时候默认输出一个文件的前10行，加上-n选项可以自定义输出文件的前几行，值得注意的是，如果-n后面跟的是一个负数，表示的是这些行不输出，比如-n -100表示前100行不输出，从100行之后的所有行全部输出。\n\ntail命令用来取出文件的后面几行。\n\n-n的使用和head大致相同，一个比较好玩的是 -n +100表示100行之后的所有行都输出。-f选项用来持续检测这个文件，如果一个文件一直在进行写入操作，那么会持续的输出这个文件新加入的行，直到按下Ctrl + C后结束检测。\nhead和tail的组合使用可以输出11 ~ 20 行：head -n 20 /etc/man_db.conf | tail -n 10 |表示将前面执行的结果交给后面接着执行。\n在上面的基础上再加上cat可以输出正确的11~20行的行号：cat -n /etc/man_db.conf | head -n 20 | tail -n 10\n\n\nod命令是针对那些非文字文档的一个命令。\n对于一些 data file 或者 binary file 可以使用od命令使这些文件以ASCII码的形式输出出来。\n我们可以利用这个命令来对已有的字符串输出对应的八进制ASCII码：echo password | od -t oCc\n\n使用ls的--time选项来查看每个文件的不同类型的时间。\n\n\n使用touch命令可以：1.建立一个空白的文档。2.将一个文档的时间修改为某一个特定的时间。\n\n\numask命令可以查看当前用户创建的文档或者目录的预设权限。\n输入umask输出的一串数字从第二个到第四个分别表示user，group，other三种用户被拿掉的权限的权值的和。比如4表示读，2表示写，5表示读和执行。\n命令umask 002表示将该用户创建文件的预设权限设置为仅为other的用户不能写。\n一般root用户将umask设置为022，因为是出于安全的考虑。\n\n\nchattr命令表示设置文件或者目录的隐藏属性\nchattr +i attrtest表示给attrtest文件加上锁定的隐藏属性，用chattr -i attrtest来取消该隐藏属性。\n\nlsattr命令用来查看一个文件或者目录的隐藏属性。\n\nSUID（Set UID）是一个特殊的权限，可以让非root用户暂时使用root命令。\nSUID是在原本user的x权限的位置上标为s，此时权限表示为SUID。\n下图为SUID的限制于功能：\n\n\n\n而且需要注意的是SUID只可以用在binary program上，并不能用于shell script。\n\nSGID（Set GID）是指在群组的x权限的位置上标为s的一个权限。\nSGID对于可执行文件的限制于功能为下图：\n\nSGID对于目录的限制于功能为下图：\n\n\nSBIT 只能对目录有作用。\n\n\n\n4，2, 1分别表示这三个隐藏权限的权值。在chmod的第一个值中表示该文件的隐藏权限属性值。使用：chmod 4755 test可以设置test的隐藏权限。\n\n上图是使用文字的方式添加文件的隐藏属性。\n\nfail命令来查看改文件的基本资料，是ASCII文件还是date文件或者可执行文件的一些细节。\n\n\nwhich命令用来寻找命令的完整路径。\n\nwhich会根据PATH的路径来依次寻找命令所在的地址。\n\nwhereis命令是用于在一些特定目录中寻找档案名。\n\n\nlocate命令用来通过关键字在自建的数据库中搜索带有该关键字的文件。\n\nlocate使用的是由已建立的資料庫 /var/lib/mlocate/里面的资料所搜到的，该数据库默认每天更新一次，所以如果没有更新的话就可能搜索不到，这时就可以进行手动更新。\nupdatedb命令会搜索硬盘中的文档的名称并且更新资料库中的档案。\n\n\nfind命令用来查找文件。\n\n\n\n\n\n\n","categories":["技术"],"tags":["学习笔记","Linux"]},{"title":"微信小程序开发入门","url":"/13114","content":"刚开始，先进行一个demo的学习。原文链接：https://blog.csdn.net/lu_embedded/article/details/86181251\n项目目录结构微信小程序的基本文件构造和项目目录结构说明如下：\n.\n├── app.js     # 小程序的逻辑文件\n├── app.json   # 小程序的配置文件\n├── app.wxss   # 全局公共样式文件\n├── pages      # 存放小程序的各个页面\n│   ├── index  # index页面\n│   │   ├── index.js     # 页面逻辑\n│   │   ├── index.wxml   # 页面结构\n│   │   └── index.wxss   # 页面样式表\n│   └── logs   # logs页面\n│       ├── logs.js      # 页面逻辑\n│       ├── logs.json    # 页面配置\n│       ├── logs.wxml    # 页面结构\n│       └── logs.wxss    # 页面样式表\n├── project.config.json\n└── utils\n    └── util.js\n\n页头页尾pages 属性用来设置页面路径，它是一个数组，每一项都是字符串来指定小程序由哪些页面组成。数组的第一项代表小程序的初始页面。小程序中新增或减少页面，都需要对 pages 数组进行修改。\nwindow 属性用于设置小程序的状态栏、导航条、标题、窗口背景色。\n我们把页头的标题和颜色修改一下，页尾部分我们做一个 tab 栏来切换页面，这个属性叫做 tabBar，代码如下：\n&#123;\n  &quot;pages&quot;:[\n    &quot;pages/index/index&quot;,\n    &quot;pages/logs/logs&quot;\n  ],\n  &quot;window&quot;:&#123;\n    &quot;backgroundTextStyle&quot;:&quot;light&quot;,\n    &quot;navigationBarBackgroundColor&quot;: &quot;#2f2f8f&quot;,    \n    &quot;navigationBarTitleText&quot;: &quot;GoZeroWaste&quot;,    # 标题\n    &quot;navigationBarTextStyle&quot;:&quot;white&quot;\n  &#125;,\n  &quot;tabBar&quot;:&#123;                    \n    &quot;color&quot;: &quot;#bfc1ab&quot;,\n    &quot;selectedColor&quot;: &quot;#13b11c&quot;,\n    &quot;backgroundColor&quot;: &quot;#1f1f4f&quot;,\n    &quot;list&quot;: [    # 导航栏的两个按钮\n      &#123;\n        &quot;pagePath&quot;: &quot;pages/index/index&quot;,\n        &quot;iconPath&quot;: &quot;image/icon_component.png&quot;,    # 第一个按钮的图标\n        &quot;selectedIconPath&quot;: &quot;image/icon_component_HL.png&quot;,    # 选择第二个按钮后第一个的按钮的图标\n        &quot;text&quot;: &quot;个人中心&quot;    # 按钮的名字\n      &#125;,\n      &#123;\n        &quot;pagePath&quot;: &quot;pages/details/details&quot;,\n        &quot;iconPath&quot;: &quot;image/icon_API.png&quot;,    # 第二个按钮的图标\n        &quot;selectedIconPath&quot;: &quot;image/icon_API_HL.png&quot;,    # 选择第一个按钮后第二个的按钮的图标\n        &quot;text&quot;: &quot;生活指南&quot;    # 按钮的名字\n      &#125;\n    ]\n  &#125;\n&#125;\n\n（所用到的图片放在项目的 image 目录，你也可以使用自己的图片）\n这里用到几个 tabBar 的属性是 color、selectedColor、backgroundColor 和 list，list 是一个数组，主要用于设定导航的路径。\n因为导航栏中一个按钮关联的是另一个页面，但是这个页面还没有存在，所以我们需要在app.json文件的list中直接添加，修改app.json文件：\n&#123;\n    &quot;pages&quot;:[\n    &quot;pages/index/index&quot;,\n    &quot;pages/logs/logs&quot;,\n    &quot;pages/details/details&quot;\n    ],\n    \n\nCTRL + S 保存之后，模拟器就会自动刷新，马上可以看到效果。保存刷新之后就会发现，目录结构里自动创建了这一页。\n简单起见，我们就在 pages/index 目录下实现 “个人中心” 页面好了。双击打开 index.wxml，初始内容如下：\n这里已经有一些代码了，虽然现在可能还看不懂，但我们知道，这就是现在页面的源代码。我们把 “Hello World” 部分注释掉，增加我们希望显示的内容：\n&lt;!--index.wxml-->\n&lt;view class=\"container\">\n  &lt;view class=\"userinfo\">\n    &lt;button wx:if=\"{{!hasUserInfo &amp;&amp; canIUse}}\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\"> 获取头像昵称 &lt;/button>\n    &lt;block wx:else>\n      &lt;image bindtap=\"bindViewTap\" class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" background-size=\"cover\">&lt;/image>\n      &lt;text class=\"userinfo-nickname\">{{userInfo.nickName}}&lt;/text>\n    &lt;/block>\n  &lt;/view>\n   &lt;!-- &lt;view class=\"usermotto\">\n    &lt;text class=\"user-motto\">{{motto}}&lt;/text>\n  &lt;/view>  -->    &lt;!--注释内容-->\n    &lt;!--页面的三行字-->\n  &lt;view class=\"ID_Badge\">\n    &lt;view>\n      &lt;text class=\"ID_info\">{{company}}&lt;/text>    \n    &lt;/view>\n    &lt;view>\n      &lt;text class='ID_info'>{{position}}&lt;/text>\n    &lt;/view>\n    &lt;view>\n      &lt;text class='ID_info'>{{lesson}}&lt;/text>\n    &lt;/view>\n  &lt;/view>\n&lt;/view>\n\n发现HTML的几种特性，自己总结的：\n1.一个标签出现之后会有一个相同的带反斜线的作为结尾，所以每一个标签都是成对出现的比如：&lt;view>&lt;/view>   &lt;text>&lt;/text>  \n2.在一个标签可以修饰一个变量，然后这个变化的量有一个类，用class来说明，比如&lt;view class = \"ID_Badge\"> &lt;text class = \"ID_info\">\n3.一个变量可以与.js文件中的date中的值相互关联，所以html只作为一个最前面的一个框架的作用，后面的.js文件支撑整个页面逻辑。\n4.只有html文件和js文件并不行，每一个类都需要在本页面的css文件内进行声明，并且设置这个类的样式属性。\n5.每一个text或者image的标签必须被一对view标签包围。\n\n","categories":["技术"],"tags":["学习笔记"]},{"title":"2021牛客寒假算法基础集训营6","url":"/50660","content":"A题  回文括号序列计数链接：https://ac.nowcoder.com/acm/contest/9986/A来源：牛客网\n题目描述我们定义一个字符串S是回文的，表示S的左右反转和S相同。\n 我们定义一个字符串是括号序列：\n​     \\1. 空串是括号序列。​     \\2. 两个括号序列P和Q的拼接是括号序列。​     \\3. 如果P是括号序列，’(‘+P+’)’是括号序列。\n 求长度为 n (0&lt;=n&lt;=10^9) 的回文括号序列的方案数，对 998244353 取膜。\n输入描述:\n第一行一个 T 表示数据组数。T&lt;=1000000。接下来 T 行，每行一个 n 。\n\n输出描述:\nT 行。对于每组数据，你的答案。\n\n示例1\n输入\n2\n0\n1\n\n输出\n1\n0\n\n\n思路啥都不说了，凉心出题人。题目十分的阴间。\n看看这迷人的通过率，还浪费了我大把的卡常时间。\n说实话我现在还是没有看懂题，啥叫“一个字符串S是回文的，表示S的左右反转和S相同。”\nPS：在题解文档出来之后，并且翻阅了好多其他人的题解之后我懂了这个“（）”为什么不是回文：它指的回文是”abba”但是很显然（与）是两个符号。所以并不是aa形而是ab形，所以“（）”并不是一个回文序列。同理根据题中所给的构造条件可知，长度大于0的串都不可能是回文串。\n代码#include&lt;bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int ncase;\n    scanf(\"%d\", &amp;ncase);\n    while (ncase--)\n    {\n        int n;\n        scanf(\"%d\", &amp;n);\n        if (n == 0) puts(\"1\");\n        else puts(\"0\");\n    }\n    return 0;\n}\n\n这短小精湛的代码告诉我们，写题之前先读题。\n（出题人还让答案对一个数取模，看起来跟真的似的，给忽悠瘸了）\nJ题  天空之城链接：https://ac.nowcoder.com/acm/contest/9986/J来源：牛客网\n题目描述天空之城有5个小镇，名字分别为Ada, Aed, Akk, Orz, Apq，他们也有相互的路径长度。  \n  希达早已期盼着天空之城，如今她登上了天空之城，就想走遍天空之城的每一个城市，但是她希望自己走的路的长度越小越好，以节省体力和节约时间。  \n  巴鲁同意了，但由于他是主力（男孩子嘛），需要帮希达计算出走遍所有城市的最短路径长度。  \n  由于天空之城具有魔力，如果希达想再走一次自己之前走过的路，则她可以在这条路上不花费任何时间。  \n  但是天空之城的城市太多了，他实在计算不过来，只得请你来帮帮忙了。\n输入描述:\n第一行，输入n，q, 表示有n个城市，q条边；\n第二行，输入一个名字tmp，表示希达想要从tmp城市开始行走；\n接下来q行，每行输入两个名字a,b和一个数字val, 表示a城市与b城市之间的距离为val.(注意可能有重边和自环)\n\n输出描述:\n帮助巴鲁计算出最短的路径长度，如果无法走遍所有城市，输出“No!”。\n\n示例1\n输入\n\n5 5\nOrz\nAda Aed 5\nOrz Ada 6\nApq Aed 8\nAkk Apq 12\nAed Orz 3\n\n\n输出\n\n28\n\n\n说明\n\nAda-&gt;Aed-&gt;Orz-&gt;Aed-&gt;Apq-&gt;Akk\n\n备注:\n多组输入输出（以EOF结束），保证数据组数不超过 10 。\n1 &lt;= n &lt;= 5000, 1 &lt;= q &lt;= 200000, 1 &lt;= val &lt;= 1e9. 每个城市的名字长度不超过10。\n保证 ∑q≤200000\\sum q \\le 200000∑q≤200000 。\n\n图论题，由题可知我们要求一个图中的最小生成树。\n复习一下Kruskal算法。\nKruskal算法的核心是贪心算法，我们根据边权进行从小到大排序，每次取出边权最小的那一个，然后将两点加入到生成树中，在添加的过程中需要注意的是，维护一个并查集，实时监测是否出现了环，如果出现了环那么这条边舍弃，结束的条件是当加入了n-1条边之后，最小生成树即建成。\n代码：#include&lt;bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\nconst int maxn = 5005;\nconst int maxm = 200005;\nll n, q, ans, tot;\nstruct edge {\n    int from, to;\n    ll v;\n    bool operator &lt; (const edge &amp;b)const{\n        return v &lt; b.v;\n    }\n}a[maxm];\nll f[maxn];\nmap&lt;string, ll> mp;\nll find(ll x){return x == f[x] ? x : f[x] = find(f[x]);}\nvoid Kruskal() {\n    sort(a + 1, a + 1 + q);\n    for (int i=1;i&lt;=q;++i) {\n        ll x = find(a[i].from);\n        ll y = find(a[i].to);\n        if (x != y) {\n            f[x] = y;\n            ans += a[i].v;\n        }\n    }\n    ll x = find(1);\n    for (int i=2;i&lt;=n;++i) {\n        if (find(i) != x) {\n            cout &lt;&lt; \"No!\" &lt;&lt; endl;\n            return;//这个细节错了一次，忘记输出完no后直接返回\n        }\n    }\n    cout &lt;&lt; ans &lt;&lt; endl;\n    return;\n}\n\nint main() {\n    while (cin >> n >> q) {\n        string aaa, bbb;\n        mp.clear();\n        tot = 0;\n        ans = 0;\n        for (int i=1;i&lt;=n;++i)    f[i] = i;\n        cin >> aaa;\n        for (int i=1;i&lt;=q;++i)  {\n            cin >> aaa >> bbb;\n            cin >> a[i].v;\n            if (mp.count(aaa) == 0) mp[aaa] = ++tot;\n            if (mp.count(bbb) == 0) mp[bbb] = ++tot;\n            a[i].from = mp[aaa];\n            a[i].to = mp[bbb];\n        }\n        Kruskal();\n    }\n    return 0;\n}\n\n\n来总结一下Kruskal的一些小细节，首先是并查集函数的背诵和f数组的初始化不要忘。\n然后就是存贮边的结构体中要重载一下小于号的运算符，以w为排序的依据。\n\nF题  组合数问题链接：https://ac.nowcoder.com/acm/contest/9986/F来源：牛客网\n题目描述小 M 很喜欢组合数。\n 小 Z 给了她一个数 n （n为偶数），让她计算 (n0)+(n2)+(n4)..+(nn)\\binom{n}{0}+\\binom{n}{2}+\\binom{n}{4}..+\\binom{n}{n}(0n​)+(2n​)+(4n​)..+(nn​) ，小 M 一下子就秒掉了，觉得题好简单。\n 因此，小 Z 给了她一个难题：给定一个数 n （n 是4的倍数），计算 (n0)+(n4)+(n8)+…+(nn)\\binom{n}{0}+\\binom{n}{4}+\\binom{n}{8}+…+\\binom{n}{n}(0n​)+(4n​)+(8n​)+…+(nn​) ，答案对 998244353 取模。\n 小 M 不会做，请你来帮帮她吧！\n输入描述:\n输入一个数 n 。\n\n\n输出描述:\n输出答案对 998244353 取模的值。\n\n\n示例1\n输入\n\n12\n\n\n输出\n\n992\n\n备注:\n对于所有的数据，1\\le n\\le 10^{18}1≤n≤10 18。\n\n思路:怎么说，这道题只看懂了题解，实现可能还差点东西（虚数快速幂）\n\n\n这是主办方的题解记录，最后的公式导出其实是用了高中组合数学中的一些公式推得的，所以这道题考验了高中的组合数学能力和虚数快速幂代码的能力。（然而百度了一下发现好像并没有虚数快速幂的相关资料）\n","categories":["竞赛"],"tags":["赛后总结","组合数学","思考题","最小生成树"]},{"title":"2021牛客寒假算法基础集训营5","url":"/16246","content":"B 比武招亲（上）链接：https://ac.nowcoder.com/acm/contest/9985/B来源：牛客网\n题目描述众所周知，天姐姐只喜欢天下最聪明的人，为了找到这样的人，她决定比武招亲！\n只见天姐姐在榜上留下了这样一道问题，谁做出来了就可以俘获她的芳心！\n爱慕天姐姐已久的泽鸽鸽问询赶来，只见榜上写着：\n\n给定 n,m，定义一种序列，构造方法如下：\n1.1. 在 [1,n] 中任意选择 m 次，得到了 m 个整数（显然数字可能相同）;\n2.2. 将选出的 m 个数字排序之后得到一个序列 {a1,a2,…,am}。\n定义一个序列的贡献为 max{a1,a2,…,am}−min{a1,a2,…,am}，求所有本质不同的序列的贡献和。\n为了防止结果过大，将答案为 998244353 取模后输出。（对于两个序列长度为m的序列 A、B，若 ∃i∈[1,m]，Ai≠Bi，则序列 A、B 本质不同）\n\n泽鸽鸽心有余而力不足，而你作为他最好的基友决定帮助泽鸽鸽俘获美人心！\n现在，这个重任就交给你啦！\n输入描述\n一行输入两个正整数 n，m【数据规模与约定】1 &lt;= n, m &lt;= 5*10^5\n\n输出描述\n一行一个整数，为答案对 998244353 取模后的结果。\n\n示例1输入\n3 2\n\n输出\n4\n\n说明\n本质不同的序列有如下几种：1 1、2 2、3 3、1 2、1 3、2 3，贡献为 0+0+0+1+2+1=4。\n\n看到的第一感觉是一个dp，思考f[n][m]怎样从f[n-1][m-1]或者f[n][m-1]，f[n-1][m]转移而来，但是没想出来，觉得像是和组合数的方法数统计有关。\n前置知识复习：1.组合数递推。2.乘法逆元。\n1.组合数可以通过用公式算得，所以只需递推出n的阶乘即可。\n公式为：C（n,m） = n ! / (n - m) ! * m !\n2.乘法逆元的线性递推，这个看起来好像有一点点的复杂，在两三年前我曾经懂得这个的完全推法，但是现在的我已经伤仲永了…. 先记住线性递推逆元的写法，至于原理之后再研究….但是 ！ 由于这道题的性质， p 是一个质数并且阶乘的数字比较大所以用小费马定理可以比较方便的求出逆元的大小。\n\ninv[i] = (mod-mod/i) * inv[mod % i] % mod; // 一行线性递推乘法逆元。小费马定理是： inv(x) = power(a, p-2, p);\n\n现在可以开始写这道题了。\n思路：根据问题，计算贡献和大致是dp或者排列组合计数来解。仔细一看发现和DP没啥关系，于是考虑组合计数。\n首先根据题意，知道一个序列的最大值和最小值后这个序列的贡献就可以被唯一确定出来，即最大值减最小值。不妨设某个长度为m的序列最大值为mx，最小值为mn，那么这个序列排序后究竟长什么样呢？是mn, .., .., .., ……. .., mx。肯定有一个mx和一个mn是确定的，关键在于剩下m - 2个数有多少种选法。我们用选法数乘以(mx - mn)就能得到最大值为mx最小值为mn的所有序列的总贡献了。而易知剩下m - 2个数肯定都在[mn, mx]内，现在就转化为一个高中常见的排列组合问题：x个相同的小球放入y个盒子，允许有空盒，问一共有多少种放法。答案是C(x + y - 1, y - 1)。对于这个问题而言，相当于m - 2个数分配到[mn, mx]的区间内，允许有数不被覆盖，问有多少种分配方法。即C(m - 2 + mx - mn, mx - mn - 1)。\n组合数取模有模版，根据卢卡斯定理，预处理出逆元来就可以计算。那么问题来了：最大值和最小值怎么确定。直接二重循环枚举肯定t得妈妈都不认识，但其实没有必要二重循环。注意到mn = 1, mx = 5和mn = 2, mx = 6的情况其实答案相同，因此我们直接枚举mx - mn（mx - mn其实也是贡献），再乘上这样的区间个数计算即可。\n坑点：预处理逆元的时候要开2倍n的大小！这个要根据组合数计算的范围来开！\n\n这中间用到了组合数学的一些知识，那一个盒子放数的模型也要等到后面再研究了。\n\n代码：#include&lt;bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1e6 + 8;\nconst int p = 998244353;\n\nll n, m, ans = 0;\nll f[maxn];\n\nll power(ll a, ll b, ll p) {\n    ll res = 1 % p;\n    while(b) {\n        if (b&amp;1) res = (ll) res * a % p ;\n        a = (ll) a * a % p;\n        b >>= 1;\n    }\n    return res;\n}\n\ninline ll inv(ll x) {\n    return power(x, p-2, p);\n}\n\nvoid init() {\n    cin >> n >> m;\n    f[0] = f[1] = 1;\n    for (int i=2;i&lt;=maxn;++i) \n        f[i] = f[i - 1] * i % p; \n}\n\ninline ll C(ll n, ll m) {\n    if (n == m|| m == 0)    return 1;\n    return (f[n] * inv(f[m]) % p * inv(f[n - m]) % p);\n}\n\nint main() {\n    init();\n    for (int d=1;d&lt;=n-1;++d) {\n        ll tmp = d * (n - d) % p;\n        ans = (ans + tmp * C(d + m - 2, m - 2) % p) %p;\n    }\n    cout &lt;&lt; ans;\n    return 0;\n} \n\n这篇题解是从csdn上我的账号搬运过来的，新的博客搭好啦，开始搬运计划√\n","categories":["竞赛"],"tags":["赛后总结","组合数学","乘法逆元"]},{"title":"2021牛客寒假算法基础集训营2","url":"/1765","content":"F.牛牛与交换排序链接：https://ac.nowcoder.com/acm/contest/9982/F来源：牛客网\n题目描述牛牛有一个数组，数组元素是 1 到 n 的排列，即数组的值在 1 ∼ n 范围内，且每个数字仅出现 1 次。牛牛想要将该数组变为升序排列的，他可以进行如下的操作。\n首先他要确定一个长度 k ，k 的范围在 1 ∼ n 之间。接下来他将会进行若干次操作。在每轮操作中他都可以选择一段长度为k的子数组，然后进行区间的翻转操作。\n他可以做任意次数的操作，但是要求他每次选择的子数组区间满足 li &lt;= li+1，并且区间长度等于一开始选定的 k ，也就是说一旦某一次操作选择了数组的某个位置进行区间翻转操作，下一次做区间翻转的位置将会比上一次更靠右。\n牛牛发现，并不总是存在一个 k 可以使得数组排序变为有序，请你告诉牛牛是否存在一个 k 能够在满足规则的情况下完成排序。\n输入描述:第一行输入一个正整数 n ( 1 ≤ n ≤ 10^5 ) 表示数组的大小。接下来输出一行 n 个正整数表示一个排列，即每个数的大小范围在 1 到 n 且每个正整数仅出现一次。\n输出描述:如果存在至少一个 k 能够使牛牛完成排序，请先在一行中输出一个 “yes”，然后另起一行输出一个可以满足排序的k，要求k的范围在 [ 1 , n ]  之间，如果有多解，你可以输出任意一个。\n反之如果不存在任何一个k可以完成排序，请直接在一行输出一个”no”\n示例1\n输入\n5\n5 2 1 4 3\n1\n2\n\n输出\nyes\n3\n1\n2\n\n\n示例2\n输入\n5\n1 2 3 4 5\n1\n2\n\n输出\nyes\n1\n1\n2\n\n\n示例3\n输入\n5\n5 4 3 2 1\n1\n2\n\n输出\nyes\n5\n\n\n思路：首先，我们应该如何找到k。由于我们最后要得到的是一个排序好的数列，所以如果这个数列可以成功排序的话，对于1位置上的数来说一定是1，那么第一次交换一定得让1回到1这个位置上去，所以k的大小就是数字1的下标距离1的差值。如果，1就在1这个位置上的话，那么我们判断2，或者更大的数字来确定k的值。\n之后我们如何判断这个k是否可以完成排序呢。我们只需要遵守题目中的规则然后去模拟就可以了。如果模拟到底发现可以排序成功那么就可以，反之则不行。\n但是我们可以想到的是，单纯模拟的话时间复杂度起码是n^2以上的，所以我们有什么好一点的方法优化这个时间吗？答案当然是有的，我们可以通过反转标记和双端队列的方式来优化这个模拟的过程。\n这个过程就是，维护一个长度为k的双端队列，表示如果下一次进行翻转，会受到影响的那些数字，然后从头开始进行模拟，如果i和队列头或者尾的数字相同，那么让他出队然后在反方向上将新的数字入队，维持这一操作直到全部数字出队或者出现无法复位的数字时停止即可。\n\n代码：#include&lt;bits/stdc++.h> \nusing namespace std;\nconst int N = 1e5 + 8;\nint n, k , flag = 0;\nint a[N], pos[N];\ndeque&lt;int> q;\n\nint main() {\n    cin >> n;\n    for (int i=1;i&lt;=n;++i) {\n        cin >> a[i];\n        pos[a[i]] = i;\n    }\n    for (int i=1;i&lt;=n;++i) {\n        if (pos[i] != i) {\n            k = pos[i] - i + 1;\n            break;\n        }\n    }\n    if (!k)  {\n        cout &lt;&lt; \"yes\\n\" &lt;&lt; 1;\n        return 0;\n    }\n    for (int i=1;i&lt;=k;++i)    q.push_back(a[i]);\n    for (int i=1+k;i&lt;=n+k;++i) {\n        if (!(flag % 2)) {\n            if (i - k == q.front())    q.pop_front();\n            else if(i - k == q.back())    flag ^= 1, q.pop_back();\n            else {\n                cout &lt;&lt; \"no\";\n                return 0;\n            }\n        }\n        else if (flag % 2){\n            if (i - k == q.back())    q.pop_back();\n            else if (i - k == q.front())    flag ^= 1, q.pop_front();\n            else {\n                cout &lt;&lt; \"no\";\n                return 0;\n            }\n        }\n        if (i &lt;= n) {\n            if (flag % 2)    q.push_front(a[i]);\n            else    q.push_back(a[i]);\n        }\n    }\n    cout &lt;&lt; \"yes\\n\" &lt;&lt; k;\n    return 0;\n}\n\nI: 牛牛的“质因数”链接：https://ac.nowcoder.com/acm/contest/9982/I来源：牛客网\n题目描述算数基本定理，又称唯一分解定理，算术基本定理可表述为：任何一个大于1的自然数 N,如果N不为质数，那么N可以唯一分解成有限个质数的乘积。 朴素的质因子分解算法就是利用了算数基本定理，依次枚举p判断N是否包含素因子p。\n 牛牛最近对于质因数分解产生了浓厚的兴趣。\n 牛牛定义了一个函数F(x)，它表示将x做质因数分解后得到的数字从小到大升序排列，然后将其“拼接”成一个大整数。 例如1500=22355*5,F(1500)=223555。 牛牛现在想要知道∑(n, 2)F(i)的值。\n 由于这个结果非常大，所以你只用告诉牛牛最终答案对10^9 + 7取余数的结果即可。\n输入描述:仅一行一个正整数n(2 ≤ n ≤ 4×10^6)\n\n输出描述:仅一行，表示答案对10^9+7取余数的结果。\n\n示例1\n输入3\n\n输出5\n\n说明\n\n\n示例2\n输入10\n\n输出342\n\n说明F(2)=2\nF(3)=3\nF(4)=22\nF(5)=5\nF(6)=23\nF(7)=7\nF(8)=222\nF(9)=33\nF(10)=25\n2+3+22+5+23+7+222+33+25=342\n\n\n思路这道题的思路其实就是题中所说的进行模拟即可，素数筛法选择快一点的筛子，用线性筛O（n）的时间复杂度，然后维护一个 f[i] 数组即可。可以叫做：筛法DP。其中有一个细节需要注意的是写了两次都被卡到的一个点。对一个数进行数的长度处理的时候还进行了取模运算，这个时候之前的数字的长度其实是不准的。需要用一个数组将这些数据记录下来。\n注意：并不是在模运算下不出现除法得到的结果就一定是正确的了，还要考虑一个数取模之后长度的变化问题。\n\n代码：#include&lt;bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\nconst int maxn = 4e6 + 10;\nconst int mod = 1e9 + 7;\nll n, ans;\nll prime[maxn], size = 0;\nll f[maxn];\nll P[maxn];\nbool vis[maxn]; \nll F(ll x) {\n    int c = 0;\n    while(x) x /= 10, c++;\n    return c;\n}\nll power(ll a, ll b) {\n    ll res = 1;\n    for (; b; b >>= 1) {\n        if (b &amp; 1) res = ll(res * a % mod);\n        a = ll(a * a % mod); \n    }\n    return res;\n}\nvoid init() {\n    memset(vis, true, sizeof(vis));\n    memset(prime, 0, sizeof(vis));\n    vis[1] = false;\n    for (ll i=2;i&lt;=n;++i) {\n        if (vis[i]) {\n            prime[++size] = i;\n            f[i] = i;\n            P[i] = F(i);\n        }\n        for (ll j=1;j&lt;=size&amp;&amp;i*prime[j]&lt;=n;++j) {\n              vis[i * prime[j]] = false;\n              int p = P[i];\n            f[i * prime[j]] = ((prime[j] * power(10, p) % mod) % mod + f[i]) % mod;\n            P[i * prime[j]] = F(prime[j]) + P[i];\n            if (i % prime[j] == 0)    break;\n        }\n    }\n}\n\nint main() {\n    cin >> n;\n    init();\n    for (int i=2;i&lt;=n;++i)    ans = (ans + f[i]) % mod;\n    cout &lt;&lt; ans;\n    return 0;\n}\n\n","categories":["竞赛"],"tags":["赛后总结","双端队列","DP"]},{"title":"2021牛客寒假算法基础集训营1","url":"/1957","content":"I题 限制不互素对的排列链接：https://ac.nowcoder.com/acm/contest/9981/I来源：牛客网\n题目描述输入一个数 n ，请构造一个长度为 n 的排列，使得其中正好有 k 对相邻的数gcd（最大公约数）大于 1 。 排列是指 1 到 n 一共  n 个数，每个数都出现过且仅出现过 1 次。例如，{1, 3, 2, 5, 4}是一个排列，而 {1, 3, 5, 4, 3}、 {1, 2, } 则不是排列\n输入描述:\n两个整数 n 和  k ，用空格隔开。2 &lt;= n &lt;= 100000, 0 &lt;= k &lt;= n / 2\n\n输出描述:\n如果不存在可行的构造方案，输出-1。\n否则输出一行  n 数，用空格隔开。如果有多组可行的构造方案，输出任意一组即可。\n\n示例1\n输入\n2 1\n\n输出\n-1\n\n说明\n长度为2的排列有2个：&#123;1,2&#125;和&#123;2,1&#125;，显然都不符合题意\n\n\n示例2\n输入\n6 3\n\n输出\n5 3 6 2 4 1\n\n说明\n共有3对相邻数不互素：&#123;3,6&#125;、&#123;6,2&#125;和&#123;2,4&#125;。\n这并不是唯一解，只要构造任意合法解即可。\n\n\n思路:由题中给的一个很重要的信息可知，k&lt;=n/2的，而且我们可以轻易地知道对于所有的偶数，他们的最大公因数是2满足大于1的条件，并且n以内偶数的个数正好也是n/2个。所以可以比较轻易的凑够n/2-1对儿满足条件的数对儿。这就是k&lt;=n/2-1的方法。对于k = n/2的情况，我们只需将6放到n/2个偶数的最后一个即可，然后后面放一个3来保证出现第n/2对儿。\n\n代码：#include&lt;bits/stdc++.h> \nusing namespace std;\nint n, k;\nvoid work1() {\n    for (int i=1;i&lt;=k+1;++i)    cout &lt;&lt; i * 2 &lt;&lt; ' ';\n    for (int i=k*2+3;i&lt;=n;++i)    cout &lt;&lt; i &lt;&lt; ' ';\n    for (int i=1;i&lt;=k+1;++i)    cout &lt;&lt; 2 * i - 1 &lt;&lt; ' ';\n}\nvoid work2() {\n    if (n &lt; 6)    {\n        cout &lt;&lt; -1;\n        return;\n    }\n    for (int i=4;i&lt;=k;++i)    cout &lt;&lt; i * 2 &lt;&lt; ' ';\n    cout &lt;&lt; 2 &lt;&lt; ' ' &lt;&lt; 4 &lt;&lt; ' ' &lt;&lt; 6 &lt;&lt; ' ' &lt;&lt; 3 &lt;&lt; ' ';\n       cout &lt;&lt; 1;// 问题出在这一句上，按照之前的写法，会出现9 4, 答案中 3 和 9 碰到一起的情况，这时候就不对了，所以我们用1来隔开。\n    for (int i=k*2+1;i&lt;=n;++i)    cout &lt;&lt; i &lt;&lt; ' ';\n    for (int i=3;i&lt;=k;++i)    cout &lt;&lt; 2 * i - 1 &lt;&lt; ' ';       //    cout &lt;&lt; 1;// 问题出在这一句上\n}\nint main() {\n    cin >> n >> k;\n    if (k &lt;= n / 2 - 1) work1();\n    else work2();\n    return 0;\n}\n//有问题的代码，状态：已订正\n//一些奇妙的性质：相邻的两个数一定互质，相邻的两个奇数一定互质。\n\nJ.一群小青蛙呱蹦呱蹦呱链接：https://ac.nowcoder.com/acm/contest/9981/J来源：牛客网\n题目描述：有n个格子，每个格子里有一个数，1,2,3,4…n\n牛牛放出无穷只青蛙。第一只青蛙的路线是：1-&gt;2-&gt;4-&gt;8-&gt;16-&gt;…第二只青蛙的路线是：1-&gt;3-&gt;9-&gt;27-&gt;81-&gt;…第三只青蛙的路线是：1-&gt;5-&gt;25-&gt;125…第四只青蛙的路线是：1-&gt;7-&gt;49…。。。。。。用数学语言描述，第 只青蛙的路线是首项为1，公比为的等比数列，其中代表第个素数。当青蛙跳到一个格子上，如果这个格子上面有一个数，青蛙就会把这个数吃掉。牛牛想知道，所有没有被吃掉的数的lcm（最小公倍数 ，Least common multiple）是多少？由于这个lcm可能非常大，请输出它对 1 0 9 + 7 10^9+7109 +7 取模的值。\n输入描述:一个正整数\n输出描述:如果所有数都被吃掉了，请输出一个字符串”empty”否则输出所有没有被吃掉的数的lcm，对 1 0 9 + 7 10^9+710 9+7 取模\n示例1:\n输入\n7\n\n输出\n6\n\n说明\n数字 1 可以被所有青蛙吃掉；\n数字 2 可以被第 1 只青蛙吃掉；\n数字 3 可以被第 2 只青蛙吃掉；\n数字 4 可以被第 1 只青蛙吃掉；\n数字 5 可以被第 3 只青蛙吃掉；\n数字 6 无法被吃掉；\n数字 7 可以被第 4 只青蛙吃掉。\n所以剩下的数字只有一个 6 ，所有数的 lcm 为 6\n\n\n示例2:\n输入\n123456789\n\n输出\n539747460\n\n\n思路：性质一：由题可知按照顺序划掉的是每一个素数的几次方，所以很明显的是最后留下来的数一定是由两个以上的素数相乘得到的。\n性质二：我们可以知道lcm是指两个数的最小公倍数，所以最后的答案一定是这些剩下的数字的质因数的某次方中最高那一个互相相乘的答案。\n性质三：我们可以知道一个数进行质因数分解的结果应该是唯一的。\n所以解法来了，先求出n / 2以内的质因数，然后对于2来说，找到log2(n/3)即为2的次方数。对于大于2小于n / 2的所有质数pi来说，logpi(n/2) 就是pi的次方数，然后将这些数都乘到一起就可以得到答案的lcm了。\n知识点复习：线性筛素数：\nll prime[maxn], size = 0;\nbool vis[maxn];\nvoid Prime() {\n    memset(vis, true, sizeof(vis));\n    memset(prime, 0, sizeof(prime));\n    vis[1] = true;\n    for (int i=2;i&lt;=n;++i) {\n        if (vis[i])    prime[++size] = i;\n        for (int j=1;j&lt;=size&amp;&amp;i*prime[j]&lt;=n;++j) {\n            vis[i * prime[j]] = false;\n            if (i % prime[j] == 0) break;\n        }\n    }\n}\n\n快速幂：\nll power(ll a, ll b) {\n    ll res = 1 % mod;\n    for (; b; b >>= 1) {\n        if (b &amp; 1) res = ll(res * a % mod);\n        a = ll(a * a % mod);\n    }\n    return res;\n}\n\n代码：#include&lt;bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 8e7;\nconst int mod = 1e9 + 7;\nll n, ans = 1; \nll prime[maxn / 10], size = 0;\nbool vis[maxn];\nvoid Prime() {\n    memset(vis, true, sizeof(vis));\n    memset(prime, 0, sizeof(prime));\n    vis[1] = true;\n    int t = maxn;\n    for (int i=2;i&lt;=t;++i) {\n        if (vis[i])    prime[++size] = i;\n        for (int j=1;j&lt;=size&amp;&amp;i*prime[j]&lt;=t;++j) {\n            vis[i * prime[j]] = false;\n            if (i % prime[j] == 0) break;\n        }\n    }\n}\nll power(ll a, ll b) {\n    ll res = 1 % mod;\n    for (; b; b >>= 1) {\n        if (b &amp; 1) res = ll(res * a % mod);\n        a = ll(a * a % mod);\n    }\n    return res;\n}\nint main() {\n    Prime();\n    cin >> n;\n    if (n &lt; 6)  {\n        cout &lt;&lt; \"empty\";\n        return 0;\n    }\n    ll tmp = n / 3, c = 0;\n    while(tmp >= 2) tmp /= 2, c++;//细节是当tmp小于prime数之后就不要除了，不然次数都会大个1.\n    ans = (ans * power(2, c) % mod) % mod;\n    for (int i=2;i&lt;=size;++i) {\n        if(prime[i] > n / 2)  break;//这也是一个小优化\n        tmp = n / 2, c = 0;\n        while(tmp >= prime[i]) tmp /= prime[i], c++;\n        ans = (ans * power(prime[i], c) % mod) % mod;\n    }\n    cout &lt;&lt; ans % mod;\n    return 0;\n}\n\n","categories":["竞赛"],"tags":["赛后总结","数论"]},{"title":"博弈论入门","url":"/39273","content":"巴什博弈：经典的巴什博奕模型：\n只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个，最后取光者得胜。\n\n解决思路：当n=m+1时，由于一次最多只能取m个，所以无论先取者拿走多少个，后取者都能够一次拿走剩余的物品，后者取胜，所以当一方面对的局势是n%(m+1)=0时，其面临的是必败的局势。所以当n=（m+1)r+s，（r为任意自然数，s≤m)时,如果先取者要拿走s个物品，如果后取者拿走x（≤m)个，那么先取者再拿走m+1-x个，结果剩下（m+1）（r-1）个，以后保持这样的取法，那么先取者肯定获胜。总之，要保持给对手留下（m+1）的倍数，就能最后获胜。结论：当n%(m+1)=0时，在最优策略下，后手必胜。\n变形最后取光的人输…结论：当n%(m+1)=1 时，在最优策略下，后手必胜。\n为什么？因为赢得人肯定会先取完(n - 1)个石子。\n\n\n\n\n巴什博奕的简单变形：\n 只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取a，最多取b个，最后取光者得胜。\n\n\n\n\n威佐夫博弈：\n两堆各若干个物品，两个人轮流从任意一堆中取出至少一个或者同时从两堆中取出同样多的物品，规定每次至少取一个，至多不限，最后取光者胜利。\n\n参考博客\ninline bool check(int x, int y) {\n    int a = min(x, y), b = max(x, y);\n    double c = (double)abs(b - a);\n    double r = (sqrt(5.0) + 1) / 2;\n    int tmp = int(c * r);\n    if (a == tmp) return 0; //后手必胜 \n    else return 1; //先手必胜 \n}\n\n尼姆博奕\n有N堆石子。A B两个人轮流拿，A先拿。每次只能从一堆中取若干个，可将一堆全取走，但不可不取，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N及每堆石子的数量，问最后谁能赢得比赛。\n\n参考博客\n斐波那契博弈\n有一堆个数为n的石子，游戏双方轮流取石子，满足：\n（1）先手不能在第一次把所有的石子取完；\n（2）之后每次可以取的石子数介于1到对手刚取的石子数的2倍之间（包含1和对手刚取的石子数的2倍）。 约定取走最后一个石子的人为赢家。\n\n结论：当n为Fibonacci数时，先手必败。即存在先手的必败态当且仅当石头个数为Fibonacci数。 \n公平组合博弈（ICG）每次只能走到必胜点的是必败点，可以走到必败点的是必胜点。\n","categories":["竞赛"],"tags":["博弈论","学习笔记"]},{"title":"第八届“图灵杯”NEUQ-ACM程序设计竞赛个人赛（同步赛）总结 + 补题","url":"/23417","content":"\n\n\nA题 切蛋糕题目链接 ：https://ac.nowcoder.com/acm/contest/11746/A基本思路是将1/k进行二进制拆分，比如说对于k=5，1 / 5 的二进制为 0.001100110011，则应存在5份大小为0.001的蛋糕，5份大小为0.0001的蛋糕，以此类推。（看到2的几次方相加就应该想到二进制拆分）代码不会写Orz，还不会实现，先留着之后补。\nB题 小宝的幸运数组题目链接 ：https://ac.nowcoder.com/acm/contest/11746/B题目的思路大概是一个同余的相互跳的一个搜索之类的东西，很巧妙。\n#include&lt;bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 10;\ntypedef long long ll;\nll T, n, k, ans, sum, t;\nll head[maxn];\nint main() {\n    for (scanf(\"%ld\", &amp;T);T;T--) {//学来的多组处理\n        scanf(\"%ld%ld\", &amp;n, &amp;k);\n        ans = sum = 0;\n        for (int i=0;i&lt;=k;++i)    head[i] = -1;//head[x]表示的是第一次出现总和加到一起的余数为x的时候的a的位置是多少。这样可以一边加一边处理，如果某个数加到总和上之后和之前第一次的余数对应上了，说明这之间的数字的和可以被K整除。\n        head[0] = 0;//显然对于余数为0来说，不需要有数字加上就行。\n        for (int i=1;i&lt;=n;++i) {\n            scanf(\"%ld\", &amp;t);\n            sum = (sum + t) % k;//维持一个加上当前值然后在k里的一个特征值。\n            if (head[sum] != -1) \n                ans = max(ans, i - head[sum]);//维护答案 \n            else \n                head[sum] = i;//如果第一次出现的话就保存位置\n        }\n        ans = ans == 0 ? -1 : ans;\n        printf(\"%ld\\n\", ans);\n    }\n    return 0;\n}\n\nC题 上进的凡凡这道题的思路是：一个非降序数组的所有子串都为非降序，只要把给定数组分为若干个非降序部分（每个部分要尽可能长），然后计算子串数，对于长度为n的数组子串数为 n * (n + 1) / 2，遍历然后相加。思路的正确性：一个非降序数组的所有子串都为非降序串。\n#include&lt;bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 100005;\ntypedef long long ll;\n\nll a[maxn];\nll sum, n;\nint main() {\n    ios :: sync_with_stdio(false);\n    cin >> n;\n    for (int i = 1; i &lt;= n; i++)    cin >> a[i];\n    for (ll i = 1,t = 1; i &lt;= n; ) {\n        t = i;\n        t++;\n        while (a[t] >= a[t - 1] &amp;&amp; t &lt;= n)\n            t++;\n        ll ans = t - i;\n        sum += ans * (ans + 1)/2;\n        i = t;\n    }\n    cout &lt;&lt; sum &lt;&lt; endl;\n    return 0;\n}\n\nD    Seek the Joker I这题是个：巴什博弈（终于要学新东西了啊）。\n","categories":["竞赛"],"tags":["赛后总结","搜索"]},{"title":"Python入门学习","url":"/55956","content":"\n\nPython文档阅读这是一个英语阅读生词总结笔记（大雾）\nSome prompts : \n\n(&gt;&gt;&gt;) (three greater-than signs) primary prompt\n(…) secondary prompt\n\nOperators :\n\n(//) to do floor division and get a integer result (discarding any flactional result)\n (\\)** to calculate power\n(_) if you use Python as a calculator you can type _ to get the last printed expression (ps. Don not assign the value to it)\nuse round(a, b) to keep a in the b decimal place \n(j or J) use the J suffix to indicate the imaginary part\n\nString operators : quotes : 单引号 double quotes : 双引号 backslashes : 反斜线 (\\) use \\‘ to escape the single quote (\\n) \\n means newline\nString operation :If you don’t want character prefaced by \\ to be interpreted as special characters, you can use raw string by adding an r  before the first quote.\n&gt;&gt;&gt; print(&#39;C:\\some\\name&#39;)\nC:\\some\name\n&gt;&gt;&gt; print(r&#39;C:\\some\\name&#39;)\nC:\\some\\name\n\nusing triple-quotes : &#39;&#39;&#39; or &quot;&quot;&quot; so that the strings literals can span multiple lines. and use \\at the end of the line to avoid that  end of lines are automatically included in the string.The following example:\nprint(\"\"\"\\\nUsage: thingy [OPTIONS]\n     -h                        Display this usage message\n     -H hostname               Hostname to connect to\n\"\"\")\n\nUsage: thingy [OPTIONS]\n     -h                        Display this usage message\n     -H hostname               Hostname to connect to\n\nStrings can be concatenated (glued together) with the + operator and repeated with *.Two or more string literals next to each other are automatically concatenated.\n>>> text = ('Put several strings within parentheses '\n...         'to have them joined together.')\n>>> text\n'Put several strings within parentheses to have them joined together.'\n\nThis feature is only work with two literals, not with variables or expressions.\nThe string indices alse can be negative number,to counting from the right.negetive indices start from -1\nslicing  slicing is used to obtain the substringThere follwing examples :\n>>> word = 'Python'\n>>> word[0:2]  # characters from position 0 (included) to 2 (excluded)\n'Py'\n>>> word[2:5]  # characters from position 2 (included) to 5 (excluded)\n'tho'\n\nThe start is always included, and end always excluded.This make sure that s[:i] + s[i:] always equal to s.\nNote : an omitted first index defaults to zero.\nPython strings are immutable, so assigning to an indexed position in the string result in an error.\nList :Lists can contain different types, but usually the items all have the same type.List also can be indexed and sliced.(same as string)\n>>> squares[0]  # indexing returns the item\n1\n>>> squares[-1]\n25\n>>> squares[-3:]  # slicing returns a new list\n[9, 16, 25]\n\nList also support operations like concatenation.\n>>> squares + [36, 49, 64, 81, 100]\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\nUnlike string, list is a mutable type, it is possible to change their content.You can also add new items at the end of the list, by using the append() method (we will see more about methods later):\n>>> cubes.append(216)  # add the cube of 6\n>>> cubes.append(7 ** 3)  # and the cube of 7\n>>> cubes\n[1, 8, 27, 64, 125, 216, 343]\n\nAssignment to slices is also possible, and this can even change the size of the list or clear it entirely:\n>>> letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']\n>>> letters\n['a', 'b', 'c', 'd', 'e', 'f', 'g']\n>>> # replace some values\n>>> letters[2:5] = ['C', 'D', 'E']\n>>> letters\n['a', 'b', 'C', 'D', 'E', 'f', 'g']\n>>> # now remove them\n>>> letters[2:5] = []\n>>> letters\n['a', 'b', 'f', 'g']\n>>> # clear the list by replacing all the elements with an empty list\n>>> letters[:] = []\n>>> letters\n[]\n\nbuild-in function len() also applies to lists.nest list is also allowed.\nContains in whileThe condition may also be a string or list value, in fact any sequence; anything with a non-zero length is true, empty sequences are false. \nIndentation is Python’s way of grouping statements.\nThe keyword argument end can be used to avoid the newline after the output, or end the output with a different string:\n>>> a, b = 0, 1\n>>> while a &lt; 1000:\n...     print(a, end=',')\n...     a, b = b, a+b\n...\n0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,\n\nMore Control Flow Toolsif StatementsThe else part is optional.The keyword ‘elif’ is short for ‘else if’,and is useful to avoid excessive indentation.An if … elif … elif … sequence is a substitute for the switch or case statements found in other languages.\nfor StatementsPython’s for statement iterates over the items of any sequence (a list or a string), in the order that they appear in the sequence. For example (no pun intended):\n>>> # Measure some strings:\n... words = ['cat', 'window', 'defenestrate']\n>>> for w in words:\n...     print(w, len(w))\n...\ncat 3\nwindow 6\ndefenestrate 12\n\nThe range() Functionthe built-in function range() can make the sequence of numbers.These following example:\n>>> for i in range(5):\n...     print(i)\n...\n0\n1\n2\n3\n4\n\nIt is possible to let the range start at another number, or to specify a different increment:\nrange(5, 10)\n   5, 6, 7, 8, 9\n\nrange(0, 10, 3)\n   0, 3, 6, 9\n\nrange(-10, -100, -30)\n  -10, -40, -70\n\nA strange thing happens if you just print a range:\n>>> print(range(10))\nrange(0, 10)\n\nHere is the solution:\n>>> list(range(4))\n[0, 1, 2, 3]\n\nbreak and continue statements and else Clauses on Loops:break and continue are like in C++.\n>>> for n in range(2, 10):\n...     for x in range(2, n):\n...         if n % x == 0:\n...             print(n, 'equals', x, '*', n//x)\n...             break\n...     else:\n...         # loop fell through without finding a factor\n...         print(n, 'is a prime number')\n...\n2 is a prime number\n3 is a prime number\n4 equals 2 * 2\n5 is a prime number\n6 equals 2 * 3\n7 is a prime number\n8 equals 2 * 4\n9 equals 3 * 3\n\nIn this code, the else is belongs to the for loop, not the if statement.The loop’s else clause runs when no break occurs. \npass Statement :It can be used when a statement is required syntactically but the program requires no action.pass can be used is as a place-holder for a function or conditional body when you are working on new code\nDefining Functions :Other names can also point to that same function object and can also be used to access the function:\n>>> fib\n&lt;function fib at 10042ed0>\n>>> f = fib\n>>> f(100)\n0 1 1 2 3 5 8 13 21 34 55 89\n\nThe example for the defining function:\ndef ask_ok(prompt, retries=4, reminder='Please try again!'):\n    while True:\n        ok = input(prompt)\n        if ok in ('y', 'ye', 'yes'):\n            return True\n        if ok in ('n', 'no', 'nop', 'nope'):\n            return False\n        retries = retries - 1\n        if retries &lt; 0:\n            raise ValueError('invalid user response')\n        print(reminder)\n\nThis function can be called in several ways:giving only the mandatory argument: ask_ok(‘Do you really want to quit?’)giving one of the optional arguments: ask_ok(‘OK to overwrite the file?’, 2)or even giving all arguments: ask_ok(‘OK to overwrite the file?’, 2, ‘Come on, only yes or no!’)\nPython语法点拾遗import表示引入某一个模块。\n\nimport [... ] as  (...) 表示引入一个 [...] 模块并且重命名为 (...)。\n\nfrom [...] import (...) 表示从[...]模块中引入(...)函数。\n\nfrom [...] import (...) as {...}表示从[...]模块中引入(...)函数并且重命名为 {...}。\n\n","categories":["技术"],"tags":["文档阅读"]},{"title":"算法竞赛技巧总结","url":"/18521","content":"\n\n一天一个上分小技巧：\n如果在用评测机做题的话，可以用当n大于某一值时while(1)来判断数据点的范围，如过范围猜中，这时这个测试点就会T掉，反复多交几次就可以判断出测试点的数据大小了\n可以将main函数的返回值类型设为signed，signed和int实质上等价，这时如果需要将全文中的int换为long long时会更加的方便。\nswap(a,b)等价于a ^= b ^= a ^= b\nlowbit(x) = -x&amp;x\n写图论的题的时候记得考虑分层图\n模运算是满足分配率的，即(a + b) % p = (a % p + b % p) % p;对于减法和乘法同样适用。\n在结果对一个数取模的时候注意是否出现了负数，负数取模并不会变成正的。\n对于非负整数n，当n为偶数时，n xor 1 等于 n + 1，当n为奇数时，n xor 1 等于 n - 1\n\n一天一个爆零小技巧：\n加法运算符的优先级要高于位移，i + j &gt;&gt; 1会优先运算加法，不需要加括号\nvector中的size()方法去减一可能会出错。\n\n","categories":["竞赛"],"tags":["方法总结"]}]