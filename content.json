{"pages":[{"title":"关于","text":"关于博主姓名: Dicemy / Tobin Meng 坐标: 中国，开封 状态: 本科在读 教育经历： 硕士：XDU 本科：HENU 高中：JZYZ 联系方式: QQ:1583925267 email：tobinmeng@126.com 友链： 十六岁的我自己 国民仙女郭老师 牛汁","link":"/about/"},{"title":"","text":"","link":"/picwall/"}],"posts":[{"title":"2021ccpc省赛总结","text":"2021ccpc河南省省赛，算是大学第一场比较正规的acm比赛吧，最后过了4道题，有点危险的拿到了银。 打完比赛之后和高中机房的邱宇同学沟通了一下，发现自己的成绩并不算很好，给高中丢人了。。 一些感受吧： 高中竞赛的失败导致对acm抱有复杂的感情，爱并且怕着。 从初中开始接触算法竞赛，到现在已经有六七个年头了。这些年里写了好多的代码。一些题已经做了两遍三遍，忘记了，再做，有一些题，看到就想吐。为了拾起来之前的东西，去做哪些已经做了太多次的题，我已经无法从那些做过的题中找到学习新东西的乐趣了，这让我有一些恶心。 但是我还是爱着acm的。 解一道没做过的题之后的快乐，那是一种高级的喜悦。每一次体会这种快乐，都不会让我感到厌烦。 这可能也是为什么喜欢做新题的原因吧。 在这场比赛中，有两道题是由我完成的。这两道题，都是提交一遍然后AC，我觉得这个过程，还是十分的令人激动，并且快乐的。 总结一下这场比赛： 团队的问题： 签到有点慢，开始之后要看榜，这场比赛3分钟左右才开始看榜，这时候就已经比其他人慢了。 写题没有什么比较大的问题。 到最后两道题有点乱，没有分配好要写哪道题。 大家的DP都比较薄弱。 以后比赛还是上午留着睡觉吧，不然大家的状态都不好，都感觉晕乎乎的。。。 自己的问题： DP比较薄弱。 对自己的代码没有自信。","link":"/17211"},{"title":"2021牛客寒假算法基础集训营1","text":"2021牛客寒假算法基础集训营1的补题记录 I题 限制不互素对的排列链接：https://ac.nowcoder.com/acm/contest/9981/I来源：牛客网 题目描述输入一个数 n ，请构造一个长度为 n 的排列，使得其中正好有 k 对相邻的数gcd（最大公约数）大于 1 。 排列是指 1 到 n 一共 n 个数，每个数都出现过且仅出现过 1 次。例如，{1, 3, 2, 5, 4}是一个排列，而 {1, 3, 5, 4, 3}、 {1, 2, } 则不是排列 输入描述: 两个整数 n 和 k ，用空格隔开。2 &lt;= n &lt;= 100000, 0 &lt;= k &lt;= n / 2 输出描述: 如果不存在可行的构造方案，输出-1。 否则输出一行 n 数，用空格隔开。如果有多组可行的构造方案，输出任意一组即可。 示例1 输入 12 1 输出 1-1 说明 1长度为2的排列有2个：{1,2}和{2,1}，显然都不符合题意 示例2 输入 16 3 输出 15 3 6 2 4 1 说明 12共有3对相邻数不互素：{3,6}、{6,2}和{2,4}。这并不是唯一解，只要构造任意合法解即可。 思路:由题中给的一个很重要的信息可知，k&lt;=n/2的，而且我们可以轻易地知道对于所有的偶数，他们的最大公因数是2满足大于1的条件，并且n以内偶数的个数正好也是n/2个。所以可以比较轻易的凑够n/2-1对儿满足条件的数对儿。这就是k&lt;=n/2-1的方法。对于k = n/2的情况，我们只需将6放到n/2个偶数的最后一个即可，然后后面放一个3来保证出现第n/2对儿。 代码：123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt; using namespace std;int n, k;void work1() { for (int i=1;i&lt;=k+1;++i) cout &lt;&lt; i * 2 &lt;&lt; ' '; for (int i=k*2+3;i&lt;=n;++i) cout &lt;&lt; i &lt;&lt; ' '; for (int i=1;i&lt;=k+1;++i) cout &lt;&lt; 2 * i - 1 &lt;&lt; ' ';}void work2() { if (n &lt; 6) { cout &lt;&lt; -1; return; } for (int i=4;i&lt;=k;++i) cout &lt;&lt; i * 2 &lt;&lt; ' '; cout &lt;&lt; 2 &lt;&lt; ' ' &lt;&lt; 4 &lt;&lt; ' ' &lt;&lt; 6 &lt;&lt; ' ' &lt;&lt; 3 &lt;&lt; ' '; cout &lt;&lt; 1;// 问题出在这一句上，按照之前的写法，会出现9 4, 答案中 3 和 9 碰到一起的情况，这时候就不对了，所以我们用1来隔开。 for (int i=k*2+1;i&lt;=n;++i) cout &lt;&lt; i &lt;&lt; ' '; for (int i=3;i&lt;=k;++i) cout &lt;&lt; 2 * i - 1 &lt;&lt; ' '; // cout &lt;&lt; 1;// 问题出在这一句上}int main() { cin &gt;&gt; n &gt;&gt; k; if (k &lt;= n / 2 - 1) work1(); else work2(); return 0;}//有问题的代码，状态：已订正//一些奇妙的性质：相邻的两个数一定互质，相邻的两个奇数一定互质。 J.一群小青蛙呱蹦呱蹦呱链接：https://ac.nowcoder.com/acm/contest/9981/J来源：牛客网 题目描述：有n个格子，每个格子里有一个数，1,2,3,4…n 牛牛放出无穷只青蛙。第一只青蛙的路线是：1-&gt;2-&gt;4-&gt;8-&gt;16-&gt;…第二只青蛙的路线是：1-&gt;3-&gt;9-&gt;27-&gt;81-&gt;…第三只青蛙的路线是：1-&gt;5-&gt;25-&gt;125…第四只青蛙的路线是：1-&gt;7-&gt;49…。。。。。。用数学语言描述，第 只青蛙的路线是首项为1，公比为的等比数列，其中代表第个素数。当青蛙跳到一个格子上，如果这个格子上面有一个数，青蛙就会把这个数吃掉。牛牛想知道，所有没有被吃掉的数的lcm（最小公倍数 ，Least common multiple）是多少？由于这个lcm可能非常大，请输出它对 1 0 9 + 7 10^9+7109 +7 取模的值。 输入描述:一个正整数 输出描述:如果所有数都被吃掉了，请输出一个字符串”empty”否则输出所有没有被吃掉的数的lcm，对 1 0 9 + 7 10^9+710 9+7 取模 示例1: 输入 17 输出 16 说明 12345678数字 1 可以被所有青蛙吃掉；数字 2 可以被第 1 只青蛙吃掉；数字 3 可以被第 2 只青蛙吃掉；数字 4 可以被第 1 只青蛙吃掉；数字 5 可以被第 3 只青蛙吃掉；数字 6 无法被吃掉；数字 7 可以被第 4 只青蛙吃掉。所以剩下的数字只有一个 6 ，所有数的 lcm 为 6 示例2: 输入 1123456789 输出 1539747460 思路：性质一：由题可知按照顺序划掉的是每一个素数的几次方，所以很明显的是最后留下来的数一定是由两个以上的素数相乘得到的。 性质二：我们可以知道lcm是指两个数的最小公倍数，所以最后的答案一定是这些剩下的数字的质因数的某次方中最高那一个互相相乘的答案。 性质三：我们可以知道一个数进行质因数分解的结果应该是唯一的。 所以解法来了，先求出n / 2以内的质因数，然后对于2来说，找到log2(n/3)即为2的次方数。对于大于2小于n / 2的所有质数pi来说，logpi(n/2) 就是pi的次方数，然后将这些数都乘到一起就可以得到答案的lcm了。 知识点复习：线性筛素数： 1234567891011121314ll prime[maxn], size = 0;bool vis[maxn];void Prime() { memset(vis, true, sizeof(vis)); memset(prime, 0, sizeof(prime)); vis[1] = true; for (int i=2;i&lt;=n;++i) { if (vis[i]) prime[++size] = i; for (int j=1;j&lt;=size&amp;&amp;i*prime[j]&lt;=n;++j) { vis[i * prime[j]] = false; if (i % prime[j] == 0) break; } }} 快速幂： 12345678ll power(ll a, ll b) { ll res = 1 % mod; for (; b; b &gt;&gt;= 1) { if (b &amp; 1) res = ll(res * a % mod); a = ll(a * a % mod); } return res;} 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 8e7;const int mod = 1e9 + 7;ll n, ans = 1; ll prime[maxn / 10], size = 0;bool vis[maxn];void Prime() { memset(vis, true, sizeof(vis)); memset(prime, 0, sizeof(prime)); vis[1] = true; int t = maxn; for (int i=2;i&lt;=t;++i) { if (vis[i]) prime[++size] = i; for (int j=1;j&lt;=size&amp;&amp;i*prime[j]&lt;=t;++j) { vis[i * prime[j]] = false; if (i % prime[j] == 0) break; } }}ll power(ll a, ll b) { ll res = 1 % mod; for (; b; b &gt;&gt;= 1) { if (b &amp; 1) res = ll(res * a % mod); a = ll(a * a % mod); } return res;}int main() { Prime(); cin &gt;&gt; n; if (n &lt; 6) { cout &lt;&lt; &quot;empty&quot;; return 0; } ll tmp = n / 3, c = 0; while(tmp &gt;= 2) tmp /= 2, c++;//细节是当tmp小于prime数之后就不要除了，不然次数都会大个1. ans = (ans * power(2, c) % mod) % mod; for (int i=2;i&lt;=size;++i) { if(prime[i] &gt; n / 2) break;//这也是一个小优化 tmp = n / 2, c = 0; while(tmp &gt;= prime[i]) tmp /= prime[i], c++; ans = (ans * power(prime[i], c) % mod) % mod; } cout &lt;&lt; ans % mod; return 0;}","link":"/1957"},{"title":"2021牛客寒假算法基础集训营2","text":"2021牛客寒假算法基础集训营2的补题记录 F.牛牛与交换排序链接：https://ac.nowcoder.com/acm/contest/9982/F来源：牛客网 题目描述牛牛有一个数组，数组元素是 1 到 n 的排列，即数组的值在 1 ∼ n 范围内，且每个数字仅出现 1 次。牛牛想要将该数组变为升序排列的，他可以进行如下的操作。 首先他要确定一个长度 k ，k 的范围在 1 ∼ n 之间。接下来他将会进行若干次操作。在每轮操作中他都可以选择一段长度为k的子数组，然后进行区间的翻转操作。 他可以做任意次数的操作，但是要求他每次选择的子数组区间满足 li &lt;= li+1，并且区间长度等于一开始选定的 k ，也就是说一旦某一次操作选择了数组的某个位置进行区间翻转操作，下一次做区间翻转的位置将会比上一次更靠右。 牛牛发现，并不总是存在一个 k 可以使得数组排序变为有序，请你告诉牛牛是否存在一个 k 能够在满足规则的情况下完成排序。 输入描述:第一行输入一个正整数 n ( 1 ≤ n ≤ 10^5 ) 表示数组的大小。接下来输出一行 n 个正整数表示一个排列，即每个数的大小范围在 1 到 n 且每个正整数仅出现一次。 输出描述:如果存在至少一个 k 能够使牛牛完成排序，请先在一行中输出一个 “yes”，然后另起一行输出一个可以满足排序的k，要求k的范围在 [ 1 , n ] 之间，如果有多解，你可以输出任意一个。 反之如果不存在任何一个k可以完成排序，请直接在一行输出一个”no” 示例1 输入 123455 2 1 4 312 输出 1234yes312 示例2 输入 123451 2 3 4 512 输出 1234yes112 示例3 输入 123455 4 3 2 112 输出 12yes5 思路：首先，我们应该如何找到k。由于我们最后要得到的是一个排序好的数列，所以如果这个数列可以成功排序的话，对于1位置上的数来说一定是1，那么第一次交换一定得让1回到1这个位置上去，所以k的大小就是数字1的下标距离1的差值。如果，1就在1这个位置上的话，那么我们判断2，或者更大的数字来确定k的值。 之后我们如何判断这个k是否可以完成排序呢。我们只需要遵守题目中的规则然后去模拟就可以了。如果模拟到底发现可以排序成功那么就可以，反之则不行。 但是我们可以想到的是，单纯模拟的话时间复杂度起码是n^2以上的，所以我们有什么好一点的方法优化这个时间吗？答案当然是有的，我们可以通过反转标记和双端队列的方式来优化这个模拟的过程。 这个过程就是，维护一个长度为k的双端队列，表示如果下一次进行翻转，会受到影响的那些数字，然后从头开始进行模拟，如果i和队列头或者尾的数字相同，那么让他出队然后在反方向上将新的数字入队，维持这一操作直到全部数字出队或者出现无法复位的数字时停止即可。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt; using namespace std;const int N = 1e5 + 8;int n, k , flag = 0;int a[N], pos[N];deque&lt;int&gt; q;int main() { cin &gt;&gt; n; for (int i=1;i&lt;=n;++i) { cin &gt;&gt; a[i]; pos[a[i]] = i; } for (int i=1;i&lt;=n;++i) { if (pos[i] != i) { k = pos[i] - i + 1; break; } } if (!k) { cout &lt;&lt; &quot;yes\\n&quot; &lt;&lt; 1; return 0; } for (int i=1;i&lt;=k;++i) q.push_back(a[i]); for (int i=1+k;i&lt;=n+k;++i) { if (!(flag % 2)) { if (i - k == q.front()) q.pop_front(); else if(i - k == q.back()) flag ^= 1, q.pop_back(); else { cout &lt;&lt; &quot;no&quot;; return 0; } } else if (flag % 2){ if (i - k == q.back()) q.pop_back(); else if (i - k == q.front()) flag ^= 1, q.pop_front(); else { cout &lt;&lt; &quot;no&quot;; return 0; } } if (i &lt;= n) { if (flag % 2) q.push_front(a[i]); else q.push_back(a[i]); } } cout &lt;&lt; &quot;yes\\n&quot; &lt;&lt; k; return 0;} I: 牛牛的“质因数”链接：https://ac.nowcoder.com/acm/contest/9982/I来源：牛客网 题目描述算数基本定理，又称唯一分解定理，算术基本定理可表述为：任何一个大于1的自然数 N,如果N不为质数，那么N可以唯一分解成有限个质数的乘积。 朴素的质因子分解算法就是利用了算数基本定理，依次枚举p判断N是否包含素因子p。 牛牛最近对于质因数分解产生了浓厚的兴趣。 牛牛定义了一个函数F(x)，它表示将x做质因数分解后得到的数字从小到大升序排列，然后将其“拼接”成一个大整数。 例如1500=22355*5,F(1500)=223555。 牛牛现在想要知道∑(n, 2)F(i)的值。 由于这个结果非常大，所以你只用告诉牛牛最终答案对10^9 + 7取余数的结果即可。 输入描述:1仅一行一个正整数n(2 ≤ n ≤ 4×10^6) 输出描述:1仅一行，表示答案对10^9+7取余数的结果。 示例1 输入13 输出15 说明1 示例2 输入110 输出1342 说明12345678910F(2)=2F(3)=3F(4)=22F(5)=5F(6)=23F(7)=7F(8)=222F(9)=33F(10)=252+3+22+5+23+7+222+33+25=342 思路这道题的思路其实就是题中所说的进行模拟即可，素数筛法选择快一点的筛子，用线性筛O（n）的时间复杂度，然后维护一个 f[i] 数组即可。可以叫做：筛法DP。其中有一个细节需要注意的是写了两次都被卡到的一个点。对一个数进行数的长度处理的时候还进行了取模运算，这个时候之前的数字的长度其实是不准的。需要用一个数组将这些数据记录下来。 注意：并不是在模运算下不出现除法得到的结果就一定是正确的了，还要考虑一个数取模之后长度的变化问题。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt; using namespace std;typedef long long ll;const int maxn = 4e6 + 10;const int mod = 1e9 + 7;ll n, ans;ll prime[maxn], size = 0;ll f[maxn];ll P[maxn];bool vis[maxn]; ll F(ll x) { int c = 0; while(x) x /= 10, c++; return c;}ll power(ll a, ll b) { ll res = 1; for (; b; b &gt;&gt;= 1) { if (b &amp; 1) res = ll(res * a % mod); a = ll(a * a % mod); } return res;}void init() { memset(vis, true, sizeof(vis)); memset(prime, 0, sizeof(vis)); vis[1] = false; for (ll i=2;i&lt;=n;++i) { if (vis[i]) { prime[++size] = i; f[i] = i; P[i] = F(i); } for (ll j=1;j&lt;=size&amp;&amp;i*prime[j]&lt;=n;++j) { vis[i * prime[j]] = false; int p = P[i]; f[i * prime[j]] = ((prime[j] * power(10, p) % mod) % mod + f[i]) % mod; P[i * prime[j]] = F(prime[j]) + P[i]; if (i % prime[j] == 0) break; } }}int main() { cin &gt;&gt; n; init(); for (int i=2;i&lt;=n;++i) ans = (ans + f[i]) % mod; cout &lt;&lt; ans; return 0;}","link":"/1765"},{"title":"2021牛客寒假算法基础集训营3","text":"2021牛客寒假算法基础集训营3补题记录 J 加法和乘法链接：https://ac.nowcoder.com/acm/contest/9983/J来源：牛客网 题目描述有一天牛牛和牛妹在做游戏，规则如下： 桌面上摆着n张纸牌，每张纸牌上写着一个正整数，由牛牛先手轮流执行以下操作： 1.如果桌面上只剩一张纸牌，游戏结束，这张纸牌上的数字如果是奇数则牛牛胜利，反之牛妹胜利。 2.当前行动玩家选择两张纸牌，设上面的数字分别为X,Y，接下来玩家从加法和乘法中选择一个并应用到这两个数字上，得到结果为Z，接下来将选择的两张纸牌丢弃，并拿一张新的纸牌放到桌面上，在上面写上Z。 假设双方均以最优策略行动，最后谁会赢？ 输入描述:1234第一行一个正整数n，代表开始的纸牌数。第二行n个空格分隔的正整数ai代表开始纸牌上的数字。1≤n≤10^61≤ai≤10^9 输出描述:1如果牛牛能赢，输出NiuNiu，否则输出NiuMei。 示例1:输入 123233 2333 23333 输出 1NiuMei 示例2:输入 1241 1 1 1 输出 1NiuNiu 思路这道题只要在纸上进行演算一下即可，我们将两张牌的情况都列出来，可以发现，如果两张牌都是偶数的话，无论是加法还是乘法得到的都是偶数。剩下的两种情况下，加法和乘法可以一个得到偶数一个得到奇数。由此我们可以推出如果最后一次是牛妹进行操作的话，那么牛妹必胜，如果是牛牛的话，只要在最后一次不遇上两个偶数的情况就行。那么牛牛每一次的操作就是为了消除偶数，牛妹的操作就是为了造偶数。这就是两人的最优策略。 那么，游戏的过程就变成了牛牛消一个偶数，牛妹产生一个偶数，直到最后一次判断是否有两个偶数即可。 代码：1234567891011121314151617#include&lt;bits/stdc++.h&gt; using namespace std;long long n, a, cnt;int main() { cin &gt;&gt; n; for (int i=1;i&lt;=n;++i) { cin &gt;&gt; a; if (a % 2 == 0) cnt ++; } if (n == 1) cout &lt;&lt; (cnt == 0 ? &quot;NiuNiu&quot; : &quot;NiuMei&quot;); else { if (cnt &gt; 1 || n % 2 == 1) cout &lt;&lt; &quot;NiuMei&quot;; else cout &lt;&lt; &quot;NiuNiu&quot;; } return 0;}","link":"/50724"},{"title":"2021牛客寒假算法基础集训营5","text":"2021牛客寒假算法基础集训营5的补题记录 B 比武招亲（上）链接：https://ac.nowcoder.com/acm/contest/9985/B来源：牛客网 题目描述众所周知，天姐姐只喜欢天下最聪明的人，为了找到这样的人，她决定比武招亲！ 只见天姐姐在榜上留下了这样一道问题，谁做出来了就可以俘获她的芳心！ 爱慕天姐姐已久的泽鸽鸽问询赶来，只见榜上写着： 给定 n,m，定义一种序列，构造方法如下： 1.1. 在 [1,n] 中任意选择 m 次，得到了 m 个整数（显然数字可能相同）; 2.2. 将选出的 m 个数字排序之后得到一个序列 {a1,a2,…,am}。 定义一个序列的贡献为 max{a1,a2,…,am}−min{a1,a2,…,am}，求所有本质不同的序列的贡献和。 为了防止结果过大，将答案为 998244353 取模后输出。（对于两个序列长度为m的序列 A、B，若 ∃i∈[1,m]，Ai≠Bi，则序列 A、B 本质不同） 泽鸽鸽心有余而力不足，而你作为他最好的基友决定帮助泽鸽鸽俘获美人心！ 现在，这个重任就交给你啦！ 输入描述 一行输入两个正整数 n，m【数据规模与约定】1 &lt;= n, m &lt;= 5*10^5 输出描述 一行一个整数，为答案对 998244353 取模后的结果。 示例1输入 3 2 输出 4 说明 本质不同的序列有如下几种：1 1、2 2、3 3、1 2、1 3、2 3，贡献为 0+0+0+1+2+1=4。 看到的第一感觉是一个dp，思考f[n][m]怎样从f[n-1][m-1]或者f[n][m-1]，f[n-1][m]转移而来，但是没想出来，觉得像是和组合数的方法数统计有关。 前置知识复习：1.组合数递推。2.乘法逆元。 1.组合数可以通过用公式算得，所以只需递推出n的阶乘即可。 公式为：C（n,m） = n ! / (n - m) ! * m ! 2.乘法逆元的线性递推，这个看起来好像有一点点的复杂，在两三年前我曾经懂得这个的完全推法，但是现在的我已经伤仲永了…. 先记住线性递推逆元的写法，至于原理之后再研究….但是 ！ 由于这道题的性质， p 是一个质数并且阶乘的数字比较大所以用小费马定理可以比较方便的求出逆元的大小。 inv[i] = (mod-mod/i) * inv[mod % i] % mod; // 一行线性递推乘法逆元。小费马定理是： inv(x) = power(a, p-2, p); 现在可以开始写这道题了。 思路：根据问题，计算贡献和大致是dp或者排列组合计数来解。仔细一看发现和DP没啥关系，于是考虑组合计数。 首先根据题意，知道一个序列的最大值和最小值后这个序列的贡献就可以被唯一确定出来，即最大值减最小值。不妨设某个长度为m的序列最大值为mx，最小值为mn，那么这个序列排序后究竟长什么样呢？是mn, .., .., .., ……. .., mx。肯定有一个mx和一个mn是确定的，关键在于剩下m - 2个数有多少种选法。我们用选法数乘以(mx - mn)就能得到最大值为mx最小值为mn的所有序列的总贡献了。而易知剩下m - 2个数肯定都在[mn, mx]内，现在就转化为一个高中常见的排列组合问题：x个相同的小球放入y个盒子，允许有空盒，问一共有多少种放法。答案是C(x + y - 1, y - 1)。对于这个问题而言，相当于m - 2个数分配到[mn, mx]的区间内，允许有数不被覆盖，问有多少种分配方法。即C(m - 2 + mx - mn, mx - mn - 1)。 组合数取模有模版，根据卢卡斯定理，预处理出逆元来就可以计算。那么问题来了：最大值和最小值怎么确定。直接二重循环枚举肯定t得妈妈都不认识，但其实没有必要二重循环。注意到mn = 1, mx = 5和mn = 2, mx = 6的情况其实答案相同，因此我们直接枚举mx - mn（mx - mn其实也是贡献），再乘上这样的区间个数计算即可。 坑点：预处理逆元的时候要开2倍n的大小！这个要根据组合数计算的范围来开！ 这中间用到了组合数学的一些知识，那一个盒子放数的模型也要等到后面再研究了。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6 + 8;const int p = 998244353;ll n, m, ans = 0;ll f[maxn];ll power(ll a, ll b, ll p) { ll res = 1 % p; while(b) { if (b&amp;1) res = (ll) res * a % p ; a = (ll) a * a % p; b &gt;&gt;= 1; } return res;}inline ll inv(ll x) { return power(x, p-2, p);}void init() { cin &gt;&gt; n &gt;&gt; m; f[0] = f[1] = 1; for (int i=2;i&lt;=maxn;++i) f[i] = f[i - 1] * i % p; }inline ll C(ll n, ll m) { if (n == m|| m == 0) return 1; return (f[n] * inv(f[m]) % p * inv(f[n - m]) % p);}int main() { init(); for (int d=1;d&lt;=n-1;++d) { ll tmp = d * (n - d) % p; ans = (ans + tmp * C(d + m - 2, m - 2) % p) %p; } cout &lt;&lt; ans; return 0;} 这篇题解是从csdn上我的账号搬运过来的，新的博客搭好啦，开始搬运计划√","link":"/16246"},{"title":"深度学习&lt;Dive into deep learning&gt;_2预备知识","text":"所有笔记和教程都使用Pytorch框架来实现 本系列博客来自于： DIVE INTO DEEP LEARNING，李沐老师的课，Orz 2.1数据操作12345678910import torchx = torch.arange(12) #生成一个行向量，arange中的参数是行向量的元素的个数x.shape #输出张量x的形状x.numel() #输出张量的元素的个数X = x.reshape(3, 4) #使用reshape来改变一个张量的形状X = x.reshape(-1, 4) #在reshape中填充-1来表示让reshape自动计算该维度的值torch.zeros((2, 3, 4)) #表示生成一个维度为2, 3, 4的元素值全为0的张量，一定要注意参数是一个元组，而不是三个数字torch.ones((2, 3, 4)) #维度为2, 3, 4的全为1的张量torch.rand(3, 4) #创建一个形状为(3,4)的张量，每一个元素从均值为0、标准差为1的标准高斯分布（正态分布）中随机采样torch.tensor([[2, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]]) #通过提供包含python数值的列表来生成一个张量 运算符： 标量运算符：按照元素进行运算。 对于具有相同形状的张量，常见的标准算术运算符（+、-、*、/和**）都可以被升级为按元素运算 包括一些标量运算函数：torch.exp() 同时可以使用torch.cat将两个张量连接在一起形成一个张量 同时可以使用==或者其他的比较运算符来实现张量中的标量的比较运算 X.sum()可以实现张量中所有元素的求和 123456x + y, x - y, x * y, x / y, x ** y # **运算符是求幂运算torch.exp(x)torch.cat((X, Y), dim = 0)torch.cat((X, Y), dim = 1)X == YX.sum() 广播机制： 对于形状不相同的张量，可以使用广播机制来对这两个张量进行运算 123a = torch.arange(3).reshape((3, 1))b = torch.arange(2).reshape((1, 2))a + b 矩阵a将复制列， 矩阵b将复制行，然后再按元素相加。 索引和切片： -1表示数组中最后一个元素，同时可以使用切片来取数或者批量的赋值 123X[-1], X[1:3]X[1, 2] = 9X[0:2, :] = 12 节省内存： Python中默认的Z = X + Y生成的结果会新产生一个对象，原来的Z张量内存就被浪费掉了，为了避免这种情况发生，可以使用Z[:]来解决 1Z[:] = X + Y 对象的转换： 12a = torch.tensor([3.5])a, a.item(), float(a), int(a) 2.2数据预处理数据的处理一般采用pandas来实现 数据的读取： 对于csv（逗号分隔值）文件数据： 123456# 如果没有安装pandas，只需取消对以下行的注释来安装pandas# !pip install pandasimport pandas as pddata = pd.read_csv(data_file)print(data) 处理缺失值： 一般的“NAN”表示缺失值，一般处理缺失值的方法有：插值法和删除法。 位置索引iloc可以将数组分为若干部分。其中fillna表示填充数据中的NAN数据，inputs.mean()表示数据中每一列的均值。 123inputs, outputs = data.iloc[:, 0:2], data.iloc[:, 2]inputs = inputs.fillna(inputs.mean())print(inputs) 对于离散值或者类别值，pandas可以将这一列中的所有类别拆分成若干列，并通过标记0和1来表示该行记录是哪一个离散值 12inputs = pd.get_dummies(inputs, dummy_na=True)print(inputs) 转换为张量格式： 通过torch.tensor将数值类型转换为张量类型。 123import torchX, y = torch.tensor(inputs.values), torch.tensor(outputs.values)X, y 2.3线性代数标量是只有一个元素的张量， 向量是一维的张量 对于向量来说，向量的维度为向量的长度。（然而，张量的维度用来表示张量具有的轴数。） 矩阵是向量从一阶推广到二阶的结果。 矩阵具有相同数量的行和列时，它被称为方阵 交换矩阵的行和列时，结果称为矩阵的转置 1A.T #表示为A矩阵的转置 对称矩阵是方阵的一种特殊类型，对称矩阵等于其本身的转置 张量是矩阵的推广，张量具有任意数量的轴 张量的按元素一元运算不会该表张量的形状，相同形状的两个张量按元素运算的结果也是相同形状的张量 两个矩阵的按元素乘法称为Hadamard积（数学符号⊙） 将张量乘以或加上一个标量，不会改变该张量的形状，其中张量的每个元素都会与标量相加或相乘 降维： 对张量进行求和可以对张量实现降维。比如对张量进行整体求和，就是将张量沿所有的轴减低张量的维度，使其称为一个标量 我们还可以指定张量按照某一个轴进行降维 对于矩阵来说，行的轴是轴0，若对行进行降维后，行这一轴就会消失，同理矩阵的列是轴1。 若对一个矩阵沿一个维度降维，无论是行还是列，降维的结果都将是一个向量即一个行向量，若要沿列降维后得到一个列向量，需要使用非降维求和 ，这样的求和还会保持原来矩阵的形状（行数），这样方便后续进行广播操作。 123456A_sum_axis0 = A.sum(axis=0)A_sum_axis0, A_sum_axis0.shapeA_sum_axis1 = A.sum(axis=1)A_sum_axis1, A_sum_axis1.shapeA.sum(axis=[0, 1]) # SameasA.sum()sum_A = A.sum(axis=1, keepdims=True) #得到的是一个列向量 均值： 平均值常常通过总和除以元素总数来计算。 均值也可以沿指定轴降低张量的维度 12A.mean(), A.sum() / A.numel()A.mean(axis=0), A.sum(axis=0) / A.shape[0] #这样得到的是A每一列的均值，即把行进行降维并且求了每一列中每一行的均值 点积： 点积是两个向量之间的操作。 点积就是两个向量相同位置的按元素乘积的和 对于向量点积来说，由于没有行向量和列向量的区分，我们可以直接将两个向量按元素进行乘法，然后对结果向量进行求和。 向量的点积可以计算值的加权和或者加权平均，或者夹角的余弦 12torch.dot(x, y)torch.sum(x * y) 矩阵-向量积： 矩阵向量积中的向量常常指的是列向量。 一个m*n的矩阵和一个维度为n的向量的矩阵向量积的结果是一个维度为m的列向量 我们可以把矩阵向量积看为一个维度为n的向量向维度为m的向量的一个转换。构造一个矩阵可以协助向量进行转换。 1torch.mv(A, x) #matrix &amp; vector =&gt; mv 矩阵-矩阵乘法： 矩阵矩阵乘法指的是一个mk的矩阵和一个k\\n矩阵之间的矩阵乘法。 1torch.mm(A, b) # matrix &amp; matrix =&gt; mm 范数： 范数为了表示一个向量的大小，这里的大小不是维度，而是分量的大小。 范数有一些性质： 对向量进行成倍缩放，该向量的范数也会成倍的缩放 三角不等式，两个向量的和的范数应该小于等于两个向量范数的和 范数应该是非负的 欧几里得距离被称为L2范数，L2范数是向量元素平方和的平方根： 常常使用中L2范数会忽略下标2 在深度学习中，比较经常的使用L2范数的平方 L1范数，指的是向量元素的绝对值之和： 与L2范数相比，L1范数受异常值的影响较小 与向量相似，矩阵的Frobenius范数是矩阵元素的平法和的平方根，Frobenius范数满足向量范数的所有性质。 123torch.norm(u) #计算出的就是u向量的L2范数torch.abs(u).sum() #计算出来的就是u向量的L1范数torch.norm(torch.ones((4, 9))) #计算出来4*9的1矩阵的Frobenius范数 范数的意义： 在深度学习中，我们常常解决最优化问题，要最大化或最小化某一个指标，其中向量之间的距离即目标，就是范数。 2.4微积分","link":"/36858"},{"title":"2021牛客寒假算法基础集训营6","text":"2021牛客寒假算法基础集训营6的补题记录 A题 回文括号序列计数链接：https://ac.nowcoder.com/acm/contest/9986/A来源：牛客网 题目描述我们定义一个字符串S是回文的，表示S的左右反转和S相同。 我们定义一个字符串是括号序列： ​ \\1. 空串是括号序列。​ \\2. 两个括号序列P和Q的拼接是括号序列。​ \\3. 如果P是括号序列，’(‘+P+’)’是括号序列。 求长度为 n (0&lt;=n&lt;=10^9) 的回文括号序列的方案数，对 998244353 取膜。 输入描述: 第一行一个 T 表示数据组数。T&lt;=1000000。接下来 T 行，每行一个 n 。 输出描述: T 行。对于每组数据，你的答案。 示例1 输入 123201 输出 1210 思路啥都不说了，凉心出题人。题目十分的阴间。 看看这迷人的通过率，还浪费了我大把的卡常时间。 说实话我现在还是没有看懂题，啥叫“一个字符串S是回文的，表示S的左右反转和S相同。” PS：在题解文档出来之后，并且翻阅了好多其他人的题解之后我懂了这个“（）”为什么不是回文：它指的回文是”abba”但是很显然（与）是两个符号。所以并不是aa形而是ab形，所以“（）”并不是一个回文序列。同理根据题中所给的构造条件可知，长度大于0的串都不可能是回文串。 代码123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ int ncase; scanf(&quot;%d&quot;, &amp;ncase); while (ncase--) { int n; scanf(&quot;%d&quot;, &amp;n); if (n == 0) puts(&quot;1&quot;); else puts(&quot;0&quot;); } return 0;} 这短小精湛的代码告诉我们，写题之前先读题。 （出题人还让答案对一个数取模，看起来跟真的似的，给忽悠瘸了） J题 天空之城链接：https://ac.nowcoder.com/acm/contest/9986/J来源：牛客网 题目描述天空之城有5个小镇，名字分别为Ada, Aed, Akk, Orz, Apq，他们也有相互的路径长度。 希达早已期盼着天空之城，如今她登上了天空之城，就想走遍天空之城的每一个城市，但是她希望自己走的路的长度越小越好，以节省体力和节约时间。 巴鲁同意了，但由于他是主力（男孩子嘛），需要帮希达计算出走遍所有城市的最短路径长度。 由于天空之城具有魔力，如果希达想再走一次自己之前走过的路，则她可以在这条路上不花费任何时间。 但是天空之城的城市太多了，他实在计算不过来，只得请你来帮帮忙了。 输入描述: 第一行，输入n，q, 表示有n个城市，q条边； 第二行，输入一个名字tmp，表示希达想要从tmp城市开始行走； 接下来q行，每行输入两个名字a,b和一个数字val, 表示a城市与b城市之间的距离为val.(注意可能有重边和自环) 输出描述: 帮助巴鲁计算出最短的路径长度，如果无法走遍所有城市，输出“No!”。 示例1 输入 12345675 5OrzAda Aed 5Orz Ada 6Apq Aed 8Akk Apq 12Aed Orz 3 输出 128 说明 1Ada-&gt;Aed-&gt;Orz-&gt;Aed-&gt;Apq-&gt;Akk 备注: 多组输入输出（以EOF结束），保证数据组数不超过 10 。 1 &lt;= n &lt;= 5000, 1 &lt;= q &lt;= 200000, 1 &lt;= val &lt;= 1e9. 每个城市的名字长度不超过10。 保证 ∑q≤200000\\sum q \\le 200000∑q≤200000 。 图论题，由题可知我们要求一个图中的最小生成树。 复习一下Kruskal算法。 Kruskal算法的核心是贪心算法，我们根据边权进行从小到大排序，每次取出边权最小的那一个，然后将两点加入到生成树中，在添加的过程中需要注意的是，维护一个并查集，实时监测是否出现了环，如果出现了环那么这条边舍弃，结束的条件是当加入了n-1条边之后，最小生成树即建成。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt; using namespace std;typedef long long ll;const int maxn = 5005;const int maxm = 200005;ll n, q, ans, tot;struct edge { int from, to; ll v; bool operator &lt; (const edge &amp;b)const{ return v &lt; b.v; }}a[maxm];ll f[maxn];map&lt;string, ll&gt; mp;ll find(ll x){return x == f[x] ? x : f[x] = find(f[x]);}void Kruskal() { sort(a + 1, a + 1 + q); for (int i=1;i&lt;=q;++i) { ll x = find(a[i].from); ll y = find(a[i].to); if (x != y) { f[x] = y; ans += a[i].v; } } ll x = find(1); for (int i=2;i&lt;=n;++i) { if (find(i) != x) { cout &lt;&lt; &quot;No!&quot; &lt;&lt; endl; return;//这个细节错了一次，忘记输出完no后直接返回 } } cout &lt;&lt; ans &lt;&lt; endl; return;}int main() { while (cin &gt;&gt; n &gt;&gt; q) { string aaa, bbb; mp.clear(); tot = 0; ans = 0; for (int i=1;i&lt;=n;++i) f[i] = i; cin &gt;&gt; aaa; for (int i=1;i&lt;=q;++i) { cin &gt;&gt; aaa &gt;&gt; bbb; cin &gt;&gt; a[i].v; if (mp.count(aaa) == 0) mp[aaa] = ++tot; if (mp.count(bbb) == 0) mp[bbb] = ++tot; a[i].from = mp[aaa]; a[i].to = mp[bbb]; } Kruskal(); } return 0;} 来总结一下Kruskal的一些小细节，首先是并查集函数的背诵和f数组的初始化不要忘。 然后就是存贮边的结构体中要重载一下小于号的运算符，以w为排序的依据。 F题 组合数问题链接：https://ac.nowcoder.com/acm/contest/9986/F来源：牛客网 题目描述小 M 很喜欢组合数。 小 Z 给了她一个数 n （n为偶数），让她计算 (n0)+(n2)+(n4)..+(nn)\\binom{n}{0}+\\binom{n}{2}+\\binom{n}{4}..+\\binom{n}{n}(0n​)+(2n​)+(4n​)..+(nn​) ，小 M 一下子就秒掉了，觉得题好简单。 因此，小 Z 给了她一个难题：给定一个数 n （n 是4的倍数），计算 (n0)+(n4)+(n8)+…+(nn)\\binom{n}{0}+\\binom{n}{4}+\\binom{n}{8}+…+\\binom{n}{n}(0n​)+(4n​)+(8n​)+…+(nn​) ，答案对 998244353 取模。 小 M 不会做，请你来帮帮她吧！ 输入描述: 1输入一个数 n 。 输出描述: 1输出答案对 998244353 取模的值。 示例1 输入 112 输出 1992 备注: 对于所有的数据，1\\le n\\le 10^{18}1≤n≤10 18。 思路:怎么说，这道题只看懂了题解，实现可能还差点东西（虚数快速幂） 这是主办方的题解记录，最后的公式导出其实是用了高中组合数学中的一些公式推得的，所以这道题考验了高中的组合数学能力和虚数快速幂代码的能力。（然而百度了一下发现好像并没有虚数快速幂的相关资料）","link":"/50660"},{"title":"深度学习&lt;Dive into deep learning&gt;_1前言","text":"本系列博客来自于： DIVE INTO DEEP LEARNING，李沐老师的课，Orz 人工智能，机器学习，深度学习，和强化学习机器学习是人工智能的一个分支，也是人工智能的一种方法。 深度学习是机器学习的一个子集 强化学习是机器学习与环境交互并采取行动的一个领域；深度强化学习，将深度学习应用于强化学习。 机器学习关键组件： 数据 模型：用来转换数据 目标函数：用来量化模型的有效性 算法：调整模型参数以优化目标函数 训练模型的通常步骤： 深度学习的分类监督学习擅长在“给定输入特征”的情况下预测标签。 监督学习的一些常见例子： 回归问题：有关于多少的问题很可能就是回归问题，e.g. 这个手术需要多少小时？ 分类问题：希望模型能够预测样本属于哪个类别，分类问题又可以分为二元分类和多元分类，取决于结果的类别的数量 标记问题：想让模型描绘输入图像的内容，预测不相互排斥的类别的问题，给文章打一些标签 搜索：处理搜索结果集内的顺序 推荐系统：向特定用户进行“个性化”推荐 序列学习： 序列学习需要摄取输入序列或预测输出序列，或两者兼而有之。包括：标记和解析，自动语音识别，文本到语音，机器翻译等领域。 无监督学习无监督学习的一些常见例子： 聚类：没有标签的情况下，给数据分类 主成分分析：找到少量的参数来准确地捕捉数据的线性相关属性 因果关系和概率图模型：描述观察到的许多数据的根本原因 生成对抗网络：提供一种合成数据的方法，甚至像图像和音频这样复杂的非结构化数据","link":"/5744"},{"title":"Hyperledger-Fabric试验快速搭建","text":"本文包括了Hyperledger Fabric文档阅读和Hyperledger Fabric平台搭建笔记 Hyperledger Fabric文档阅读介绍（自己总结的）区块链： 分布式网络，节点维护，不可篡改的账本，共识协议来验证交易，节点执行交易来维护账本的副本，账本以区块的方式存在，区块通过哈希和之前的区块相连。 区块链的应用：加密货币：比特币、以太坊：智能合约：为分布式应用创建平台。：公共非许可区块链技术，公共网络，匿名互动。 公共非许可区块链技术的缺点：性能较差，身份匿名。 企业级应用的需求：身份识别，性能强，低延迟，隐私性和机密性。 Hyperledger Fabric的自身定位：开源企业级许可分布式账本技术平台。高度*模块化**，可配置*的架构，支持**通用编程语言编写智能合约，平台是*许可的**，参与者确实*存在信任，**可插拔的共识协议，可以利用*不需要原生加密货币的共识协议**，性能较好*，**隐私和保密。 特性的一些解释：非许可区块链：匿名，信任通过工作量证明进行，采用挖矿来抵消工作量证明的成本。许可区块链:**使用共识协议来进行信任，不需要昂贵的挖掘。**智能合约：“链码”，受信任的分布式应用程序。从区块链中获得信任，在节点中达成共识。共识协议：验证，排序交易，传播到所有节点，各节点按顺序执行交易。一种新方法消除了非确定性，标准编程语言。隐私和保密性：公共非许可区块链网络中，基于Pow的拜占庭容错共识牺牲了合约和数据的保密性。加密数据：可能被破解，零知识证明：使用其他共识，将机密信息限制于授权节点中。可插拔共识：模块化的共识性能和可扩展性： 介绍什么是区块链？：一个分布式账本，记录网络上所有的交易。去中心化，协作维护。信息仅能以附加的方式记录到区块链上，并使用加密技术保证一旦将交易添加到账本就无法修改。简化了信息的溯源。区块链有时被描述为 证明系统 。 智能合约：为了支持以同样的方式更新信息，并实现一整套账本功能（交易，查询等），区块链使用 智能合约 来提供对账本的受控访问。智能合约不仅是在网络中封装和简化信息的关键机制，它还可以被编写成自动执行参与者的特定交易的合约。 共识：保持账本在整个网络中同步的过程称为 共识 。该过程确保账本仅在交易被相应参与者批准时更新，并且当账本更新时，它们以相同的顺序更新相同的交易。 区块链的不同：一套在网络上建立身份，执行交易和存储数据的标准方法。资产来源可以通过查看交易列表来确定，此列表一旦写入，无法更改，因此可信任。 Hyperledger Fabric 与其他区块链系统不同的地方是 私有 和 许可 。与允许未知身份参与网络的开放式非许可系统（需要诸如“工作量证明”之类的协议来验证交易并保护网络）不同，Hyperledger Fabric 网络的成员需要从可信赖的 成员服务提供者（MSP） 注册。 Hyperledger Fabric 还提供创建 通道 的功能，允许一组参与者创建各自的交易账本。对于某些网络而言，这是一个特别重要的选择。这些网络中，一些参与者可能是竞争对手，并且不希望他们做出的每笔交易都被每个参与者知晓，例如，他们只向某些参与者提供的特殊价格，而其他人不是。如果两个参与者组成一个通道，那么只有这两个参与者拥有该通道的账本副本，而其他参与者没有。 智能合约：Hyperledger Fabric 智能合约用 链码 编写，当该应用程序需要与账本交互时，由区块链外部的应用程序调用。在大多数情况下，链码只与账本的数据库、世界状态（例如，查询）交互，而不与交易日志交互。 Hyperledger Fabric 支持私有网络（使用通道）是很重要的，因为网络是相对开放的。 共识：交易必须按照发生的顺序写入账本，即使它们可能位于网络中不同的参与者集合之中。为此，必须建立交易的顺序，且必须采用一种方法来拒绝错误（或恶意）插入到账本中的非法交易。 这是一个彻底的计算机科学研究领域，且有很多方法可以实现它，每个方法都有不同的权衡。例如，PBFT（实用拜占庭容错算法）可以为文件副本提供一种机制，使其能够保持各个副本的一致性，即使在发生损坏的情况下也是如此。或者，在比特币中，通过称为挖矿的过程进行排序，其中竞争计算机竞相解决加密难题，该难题定义所有过程随后构建的顺序。 Hyperledger Fabric 被设计为允许网络启动者选择最能代表参与者间存在的关系的共识机制。与隐私一样，有一系列需求；从他们的关系高度结构化的网络，到更加点对点的网络。 参考资料： 项目文档[1] Hyperledger Fabric平台搭建笔记centos7.9系统的安装和基础配置 记得选择语言，汉语，这是在安装界面可以看到的。ps：选错语言的话酒删了重装吧。 记得选择磁盘位置 记得连接网络，很重要！！！ps：如果在有图形的安装界面不进行勾选的话 ，之后再更改配置会十分的困难。 记得勾选基本的安装包。ps：如果不勾选的话一些基本的yum或者tar指令都无法使用。但是也不要选择太多的包，不然有可能会和自己安装的服务产生冲突。 然后进行安装即可。ps：这样进行的安装是没有图形界面的。 如何更换字体和字号： 进入/lib/kbd/consolefonts，选择合适的字体。 输入setfont指令，后面跟上字体的名称。 输入echo 'setfont latarcyrheb-sun32' &gt;&gt; /etc/profile指令将字体设置设为开机启动。 wget的安装： 刚开始安装好的centos系统是没有wget的，需要用yum安装。 yum -y install wget Go语言安装 Go语言安装 从官网下载最新的linux-amd64.tar.gz压缩包（这里是go1.15.6.linux-amd64.tar.gz） 1wget https://golang.google.cn/dl/go1.15.6.linux-amd64.tar.gz 将其解压到/usr/local目录下： 1sudo tar -C /usr/local -zxf [压缩包名] 配置环境变量，在/etc/profile文件的末尾加入（在加入之前创建/home/gopath目录） 12export GOPATH=/home/gopathexport PATH=$PATH:/usr/local/go/bin 配置中国的代理 12go env -w GO111MODULE=ongo env -w GOPROXY=https://goproxy.cn,direct 查看是否配置成功 1go env mwget安装wget太慢使用mwget 12345678910wget http://jaist.dl.sourceforge.net/project/kmphpfm/mwget/0.1/mwget_0.1.0.orig.tar.bz2yum install bzip2 gcc-c++ openssl-devel intltool -ybzip2 -d mwget_0.1.0.orig.tar.bz2tar -xvf mwget_0.1.0.orig.tar cd mwget_0.1.0.orig./configure makemake install echo &quot;至此，安装完成&quot;% 断点续传wget -c 要下载的文件，实现断点续传。 最后的配置工作生成身份材料 进入BasicNetwork-2.0/artifacts/channel目录，执行 1./create-artifacts.sh 进入BasicNetwork-2.0/artifacts目录执行 1./docker-compose up -d 进入BasicNetwork-2.0 1./createChannel.sh 智能合约部署 进入BasicNetwork-2.0/artifacts/src/github.com/fabcar/go/目录下，执行（为智能合约安装依赖） 1GO111MODULE=on go mod vendor 进入BasicNetwork-2.0/，执行智能合约的部署和测试在执行deployChaincode.sh之前，按以下命令修改文件夹的权限 1sudo chmod 777 /home/gopath/* 开始部署 1./deployChaincode.sh 部署explorer 启动Explorer, 进入ContainerisingBlockchainExplorer目录下 1docker-compose up -d 服务全部启动成功，可以在windows上查看相关的服务。 注意：hyperledge Fabric搭建完成后将虚拟机挂起后再重新开启并不能恢复所有的服务，需要重新开启一遍。 平台使用查看可视化的区块链信息，访问： 1[ip地址]:8080 查看产的最新状态，访问： 1[ip地址]:5984/_utils 常用操作超级账本的下载地址： 1wget -c https://github.com/hyperledger/fabric/releases/download/v2.2.1/hyperledger-fabric-linux-amd64-2.2.1.tar.gz 超级账本的解压缩： 1sudo tar -C ./ -zxf hyperledger-fabric-linux-amd64-2.2.1.tar.gz 超级账本的bin目录内的东西放到/usr/local/bin下 1sudo mv ./bin/* /usr/local/bin 把BasicNetwork-2.0/artifacts/channel下的crypto-config拷贝到ContainerisingBlockExplorer下 1sudo mv BasicNetwork-2.0/artifacts/channel/crypto-config ContainerisingBlockchainExplorer 在ContainerisingBlockchainExplorer下创建data和walletstore文件夹 12sudo mkdir datasudo mkdir walletstore 查看Centos的ip（看en33那个ip） 1ip add 启动docker服务 1systemctl restart docker.service 关闭所有运行着的docker容器 1docker rm -f $(docker ps -a -q) tips: 1注意go的版本 参考资料： 实验平台在服务器上的基于脚本的自动化部署[1] 区块链实验平台部署[2]","link":"/29920"},{"title":"Java进阶","text":"从互联网上各处找到的一些东西，用于查漏补缺 Java常用APIString类 String 类代表字符串，Java 程序中的所有字符串文字（例如“abc”）都被实现为此类的实例。也就是说，Java 程序中所有的双引号字符串，都是 String 类的对象。String 类在 java.lang 包下，所以使用的时候不需要导包！ 特点 底层原理是字节数组 创建后不能更改 但是可以共享 构造方法1234public String() //创建一个空字符串public String(char[] str) //根据字符数组的内容创建字符串public String(byte[] bys) //根据字节数组的内容创建字符串String str = &quot;abc&quot;; //直接赋值的方式创建字符串 创建String方法的差异 构造方法创建每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同 直接赋值的方式创建以“”方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，JVM 都只会建立一个 String 对象，并在字符串池中维护 字符串的比较 ==比较 比较两个字符串的地址 equals()方法比较 比较两个字符串内容是否相同、区分大小写 String的常用方法 StringBuffer类特点StringBuffer是一个可变的字符串类，可以看做一个容器，理解为对象中的内容可变 构造方法12public StringBuffer() //空的可变字符串public StringBuffer(String str) //根据字符串的内容来创建可变字符串对象 StringBuffer的常用方法1234public StringBuffer append(任意类型) //添加数据，并返回对象本身public StringBuffer reverse() //返回相反的字符序列public int length() //返回字符串的长度public String toString() //把StringBuilder转换为String StringBuffer与String的转换 StringBuffer转为String 使用toString()方法 String转为StringBuffer 使用StringBuffer的构造方法 ArrayList类概念 什么是集合 存储空间可变的存储模型，存储的数据容量可以发生改变 ArrayList的特点 底层是数组实现的，长度可变 泛型使用 用于约束集合中存储元素的数据类型 构造方法1public ArrayList() //创建一个空的集合对象 常用方法1234567public boolean remove(Object o) //删除指定的元素public E remove(int index) //删除指定位置的元素public E set(int index, E element) //修改指定索引处的元素，返回被修改的元素public E get(int index) //返回指定索引处的元素public int size() //返回集合中的元素的个数public boolean add(E e) //将指定的元素追加到此集合的末尾public void add(int index,E element) //在此集合中的指定位置插入指定的元素 Math类概念 Math 包含执行基本数字运算的方法 Math类中无构造方法，但内部的方法都是静态的，则可以通过 类名.进行调用 常用方法 System类常用方法 Object类概念Object 是类层次结构的根，每个类都可以将 Object 作为超类。所有类都直接或者间接的继承自该类，换句话说，该类所具备的方法，所有类都会有一份 常用方法 toString() equals() Arrays类常用方法 Integer类概念Integer是一个包装类， 包装一个对象中的原始类型 int 的值 构造方法 int和String的互相转换 int转换为String 方式一：直接在数字后加一个空字符串 方式二：通过String类静态方法valueOf()","link":"/64358"},{"title":"Python入门学习","text":"Python文档阅读和Python语法点拾遗 Python文档阅读这是一个英语阅读生词总结笔记（大雾） Some prompts : (&gt;&gt;&gt;) (three greater-than signs) primary prompt (…) secondary prompt Operators : (//) to do floor division and get a integer result (discarding any flactional result) (\\)** to calculate power (_) if you use Python as a calculator you can type _ to get the last printed expression (ps. Don not assign the value to it) use round(a, b) to keep a in the b decimal place (j or J) use the J suffix to indicate the imaginary part String operators : quotes : 单引号 double quotes : 双引号 backslashes : 反斜线 (\\) use \\‘ to escape the single quote (\\n) \\n means newline String operation :If you don’t want character prefaced by \\ to be interpreted as special characters, you can use raw string by adding an r before the first quote. 12345&gt;&gt;&gt; print('C:\\some\\name')C:\\someame&gt;&gt;&gt; print(r'C:\\some\\name')C:\\some\\name using triple-quotes : ''' or &quot;&quot;&quot; so that the strings literals can span multiple lines. and use \\at the end of the line to avoid that end of lines are automatically included in the string.The following example: 12345print(&quot;&quot;&quot;\\Usage: thingy [OPTIONS] -h Display this usage message -H hostname Hostname to connect to&quot;&quot;&quot;) 123Usage: thingy [OPTIONS] -h Display this usage message -H hostname Hostname to connect to Strings can be concatenated (glued together) with the + operator and repeated with *.Two or more string literals next to each other are automatically concatenated. 1234&gt;&gt;&gt; text = ('Put several strings within parentheses '... 'to have them joined together.')&gt;&gt;&gt; text'Put several strings within parentheses to have them joined together.' This feature is only work with two literals, not with variables or expressions. The string indices alse can be negative number,to counting from the right.negetive indices start from -1 slicing slicing is used to obtain the substringThere follwing examples : 12345&gt;&gt;&gt; word = 'Python'&gt;&gt;&gt; word[0:2] # characters from position 0 (included) to 2 (excluded)'Py'&gt;&gt;&gt; word[2:5] # characters from position 2 (included) to 5 (excluded)'tho' The start is always included, and end always excluded.This make sure that s[:i] + s[i:] always equal to s. Note : an omitted first index defaults to zero. Python strings are immutable, so assigning to an indexed position in the string result in an error. List :Lists can contain different types, but usually the items all have the same type.List also can be indexed and sliced.(same as string) 123456&gt;&gt;&gt; squares[0] # indexing returns the item1&gt;&gt;&gt; squares[-1]25&gt;&gt;&gt; squares[-3:] # slicing returns a new list[9, 16, 25] List also support operations like concatenation. 12&gt;&gt;&gt; squares + [36, 49, 64, 81, 100][1, 4, 9, 16, 25, 36, 49, 64, 81, 100] Unlike string, list is a mutable type, it is possible to change their content.You can also add new items at the end of the list, by using the append() method (we will see more about methods later): 1234&gt;&gt;&gt; cubes.append(216) # add the cube of 6&gt;&gt;&gt; cubes.append(7 ** 3) # and the cube of 7&gt;&gt;&gt; cubes[1, 8, 27, 64, 125, 216, 343] Assignment to slices is also possible, and this can even change the size of the list or clear it entirely: 123456789101112131415&gt;&gt;&gt; letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']&gt;&gt;&gt; letters['a', 'b', 'c', 'd', 'e', 'f', 'g']&gt;&gt;&gt; # replace some values&gt;&gt;&gt; letters[2:5] = ['C', 'D', 'E']&gt;&gt;&gt; letters['a', 'b', 'C', 'D', 'E', 'f', 'g']&gt;&gt;&gt; # now remove them&gt;&gt;&gt; letters[2:5] = []&gt;&gt;&gt; letters['a', 'b', 'f', 'g']&gt;&gt;&gt; # clear the list by replacing all the elements with an empty list&gt;&gt;&gt; letters[:] = []&gt;&gt;&gt; letters[] build-in function len() also applies to lists.nest list is also allowed. Contains in whileThe condition may also be a string or list value, in fact any sequence; anything with a non-zero length is true, empty sequences are false. Indentation is Python’s way of grouping statements. The keyword argument end can be used to avoid the newline after the output, or end the output with a different string: 123456&gt;&gt;&gt; a, b = 0, 1&gt;&gt;&gt; while a &lt; 1000:... print(a, end=',')... a, b = b, a+b...0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987, More Control Flow Toolsif StatementsThe else part is optional.The keyword ‘elif’ is short for ‘else if’,and is useful to avoid excessive indentation.An if … elif … elif … sequence is a substitute for the switch or case statements found in other languages. for StatementsPython’s for statement iterates over the items of any sequence (a list or a string), in the order that they appear in the sequence. For example (no pun intended): 12345678&gt;&gt;&gt; # Measure some strings:... words = ['cat', 'window', 'defenestrate']&gt;&gt;&gt; for w in words:... print(w, len(w))...cat 3window 6defenestrate 12 The range() Functionthe built-in function range() can make the sequence of numbers.These following example: 12345678&gt;&gt;&gt; for i in range(5):... print(i)...01234 It is possible to let the range start at another number, or to specify a different increment: 12345678range(5, 10) 5, 6, 7, 8, 9range(0, 10, 3) 0, 3, 6, 9range(-10, -100, -30) -10, -40, -70 A strange thing happens if you just print a range: 12&gt;&gt;&gt; print(range(10))range(0, 10) Here is the solution: 12&gt;&gt;&gt; list(range(4))[0, 1, 2, 3] break and continue statements and else Clauses on Loops:break and continue are like in C++. 1234567891011121314151617&gt;&gt;&gt; for n in range(2, 10):... for x in range(2, n):... if n % x == 0:... print(n, 'equals', x, '*', n//x)... break... else:... # loop fell through without finding a factor... print(n, 'is a prime number')...2 is a prime number3 is a prime number4 equals 2 * 25 is a prime number6 equals 2 * 37 is a prime number8 equals 2 * 49 equals 3 * 3 In this code, the else is belongs to the for loop, not the if statement.The loop’s else clause runs when no break occurs. pass Statement :It can be used when a statement is required syntactically but the program requires no action.pass can be used is as a place-holder for a function or conditional body when you are working on new code Defining Functions :Other names can also point to that same function object and can also be used to access the function: 12345&gt;&gt;&gt; fib&lt;function fib at 10042ed0&gt;&gt;&gt;&gt; f = fib&gt;&gt;&gt; f(100)0 1 1 2 3 5 8 13 21 34 55 89 The example for the defining function: 1234567891011def ask_ok(prompt, retries=4, reminder='Please try again!'): while True: ok = input(prompt) if ok in ('y', 'ye', 'yes'): return True if ok in ('n', 'no', 'nop', 'nope'): return False retries = retries - 1 if retries &lt; 0: raise ValueError('invalid user response') print(reminder) This function can be called in several ways:giving only the mandatory argument: ask_ok(‘Do you really want to quit?’)giving one of the optional arguments: ask_ok(‘OK to overwrite the file?’, 2)or even giving all arguments: ask_ok(‘OK to overwrite the file?’, 2, ‘Come on, only yes or no!’) Python语法点拾遗1234567import表示引入某一个模块。import [... ] as (...) 表示引入一个 [...] 模块并且重命名为 (...)。from [...] import (...) 表示从[...]模块中引入(...)函数。from [...] import (...) as {...}表示从[...]模块中引入(...)函数并且重命名为 {...}。","link":"/55956"},{"title":"git入门","text":"Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。也是Linus Torvalds为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。 代码回溯 版本切换 多人协作 远程备份 Git是什么Git是目前世界上最先进的分布式版本控制系统。 工作原理 / 流程： Workspace：工作区Index / Stage：暂存区Repository：仓库区（或本地仓库）Remote：远程仓库 SVN和Git的区别SVN是集中式版本控制系统。 Git是分布式版本控制系统 Git的基本操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061mkdir： XX (创建一个空目录 XX指目录名)pwd： 显示当前目录的路径。git init 把当前的目录变成可以管理的git仓库，生成隐藏.git文件。git add XX 把xx文件添加到暂存区去。git commit –m “XX” 提交文件 –m 后面的是注释。git status 查看仓库状态git diff XX 查看XX文件修改了那些内容git log 查看历史记录git reset --hard HEAD^ 或者 git reset --hard HEAD~ 回退到上一个版本(如果想回退到100个版本，使用git reset –hard HEAD~100 )cat XX 查看XX文件内容git reflog 查看历史记录的版本号idgit checkout -- XX 把XX文件在工作区的修改全部撤销。git rm XX 删除XX文件git remote add origin https://github.com/tugenhua0707/testgit 关联一个远程库git push –u(第一次要用-u 以后不需要) origin master 把当前master分支推送到远程库git clone https://github.com/tugenhua0707/testgit 从远程库中克隆git checkout –b dev 创建dev分支 并切换到dev分支上git branch 查看当前所有的分支git checkout master 切换回master分支git merge dev 在当前的分支上合并dev分支git branch –d dev 删除dev分支git branch name 创建分支git stash 把当前的工作隐藏起来 等以后恢复现场后继续工作git stash list 查看所有被隐藏的文件列表git stash apply 恢复被隐藏的文件，但是内容不删除git stash drop 删除文件git stash pop 恢复文件的同时 也删除文件git remote 查看远程库的信息git remote –v 查看远程库的详细信息git push origin master Git会把master分支推送到远程库对应的远程分支上 常用命令速查：https://www.cnblogs.com/upstudy/p/15868898.html 创建版本库 什么是版本库？版本库又名仓库，英文名repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。 通过命令 git init 把这个目录变成git可以管理的仓库，如下： 把文件添加到版本库中 首先要明确下，所有的版本控制系统，只能跟踪文本文件的改动，比如txt文件，网页，所有程序的代码等，Git也不列外，版本控制系统可以告诉你每次的改动，但是图片，视频这些二进制文件，虽能也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是知道图片从1kb变成2kb，但是到底改了啥，版本控制也不知道。 使用命令 git add readme.txt添加到暂存区里面去。如下： 用命令 git commit告诉Git，把文件提交到仓库。 使用git status来查看下结果，如下： 现在继续来改下readme.txt内容,继续使用git status来查看下结果，如下： 接下来我想看下readme.txt文件到底改了什么内容，如何查看呢？可以使用如下命令：git diff readme.txt 版本回退 我现在想查看下历史记录，如何查呢？我们现在可以使用命令 git log 演示如下所示： 现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，要使用什么命令呢？可以使用如下2种命令，第一种是：git reset –hard HEAD^ 那么如果要回退到上上个版本只需把HEAD^ 改成 HEAD^^ 以此类推。那如果要回退到前100个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作：git reset –hard HEAD~100 即可。 如果想回退到上一个版本的命令如下操作：git reset --hard HEAD^ 但是现在我想回退到最新的版本，如：有333333的内容要如何恢复呢？我们可以通过版本号回退，使用命令方法如下： git reset –hard 版本号 可以通过如下命令即可获取到版本号：git reflog 演示如下： 通过上面的显示我们可以知道，增加内容3333的版本号是 6fcfc89.我们现在可以命令 git reset –hard 6fcfc89来恢复了。演示如下： 可以看到 目前已经是最新的版本了。 理解工作区与暂存区的区别 工作区：就是你在电脑上看到的目录，比如目录下testgit里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。版本库(Repository)：工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。 撤销修改和删除文件操作 使用git status检查工作区中文件的状态 使用git restore readme.txt来丢弃工作区的修改 完结 这张图实在太全了，好像没啥问题了，看看这个链接里的指令的说明。Ok了，以后有问题再回来补充。","link":"/10811"},{"title":"刷题柱","text":"一个小小的刷题柱记录刷过的题 kuangbin刷题柱Dungeon Master（5.23）bfs，细节在于搜索到点之后入队时就进行标记已经搜索到了。不然会反复入队导致超时。 Find The Multiple（5.25）一个技巧，在dfs中如果不想让递归回到上一层之后继续执行的话，不要把dfs的返回类型设为void，而是设为bool，让多层的dfs返回到上一层就遇到一个if，就保证找到答案之后就会返回，不会寻找到多个值。常常用于有spj的搜索题。 Prime Path（8.1）水题，素数筛 + bfs。 Shuffle’m Up（8.2）水题，字符串模拟。注意：字符串为空的时候不要进行下标赋值，会出现问题，用s.push_back向空字符串中放置字符，否则会出现下标可以访问字符但是整体字符串为空的情况发生。 Pots（8.2）BFS，寻找最小变换次数即最小步数。比较特殊的是这个需要保存操作的步骤，可以用一个三维vector来保存每一次操作的动作编号，然后在到达状态之后依次输出即可。 Fire Game（8.3）离谱的是FZU挂掉了，没办法评测，样例都过了， 复习了一下如何求联通块的个数和双起点BFS。经验：下次做题前看一下uoj在那个网站提交的标志是不是红色。。。 分类刷题柱队列蚯蚓（5.4）https://ac.nowcoder.com/acm/problem/16430 这道题的解法是维护三个单调队列，由题可知蚯蚓切完的性质仍然满足蚯蚓的长度是依次递减的，由于是按照比例切的，那么切的是相同比例的蚯蚓放到一个队列中，由于靠前切的蚯蚓一定切出来的也是比之后切出来的蚯蚓长，所以当前的最长的蚯蚓只需从这三个队列中找到队头即可。 Cow Line（5.5）https://ac.nowcoder.com/acm/problem/24876 这道题就是一个简单的双端队列的模拟，题中数据的范围是模拟可以接受的，看出来题考的数据结构是双端队列就行了，维护两边的进队和出队即可。 Team Queuehttps://ac.nowcoder.com/acm/problem/50966 又是一道模拟题，团队队列只需用团队编号作为大队伍的标志，然后再委会每一个团队队列的内部次序即可。用一个queue和一个queue数组和一个map即可，细节还行，难度适中。出现的问题是数组越界了。最后发现标志该团队是否入大队列的bool数组并不是必要的。可以用检查该团队队列是否为空来代替。 长跑（5.6）https://ac.nowcoder.com/acm/problem/14570 是道队列bfs，从起点开始搜索，如果当前节点加上maxn可以到达并且钱够的商店就入队，然后如果碰到终点就退出。就是一道朴素的bfs，但是如果看不出来的还是有点迷惑的。 道路铺设（5.8）https://ac.nowcoder.com/acm/problem/21222 再次做到NOIP2018提高组的题，感慨万千。隐约记得在考场上发现是前两天做过的原题的兴奋的心情了。当时的我先发现是差分，处理出差分数组之后经过观察是差分数组为正值的所有值的和即为答案，当时并没有经过严谨的证明，隐约感觉正值和负值之间一定会相互抵消。今天重新写到，当时的感觉重新涌上心头。 其实就是一道水题，并不是优先队列，差分之后将正值加到一块即可。可以进行一个简单的证明，一个数列的差分数组的所有元素的和一定为0，那么想要将这个差分数组的正数变为0，那么每一个正数都要和负数相对应结合。其中一个问题是如果确定进行变化的一对差分中间没有0，其实这也好证明，因为每一个正数会找到最近的一个负数进行中和，那么可以保证在对更远的负数进行中和的时候，比较最近的负数已经进行了中和，级这个比较大的数通过和附近的数进行中和，已经和周围的数的大小基本相同，所以不会出现跨过一个比较小的数然后进行更行的情况发生。第二个问题是，会不会出现前面的正数不能将一个比较大的负数使用完就直接跳到后面的正数了，显然也是不会的，因为这个数列是一个正整数列。 栈好串（5.7）https://ac.nowcoder.com/acm/problem/21874 一个栈的水题。 吐泡泡https://ac.nowcoder.com/acm/problem/15029 一个栈的应用，水题。 表达式计算4（5.8）https://ac.nowcoder.com/acm/problem/50999 栈的经典应用，表达式求值。这是一个中缀表达式求值。维护两个栈，一个栈存数字，一个栈存符号，数字进栈没有什么要求，如果有一个符号要进栈的话，先把比该符号优先级高的在符号栈中的符号都先弹出栈，符号两边的数字进行运算。这样就保证了每一个运算都是优先级高的先运算。模拟的过程会比较繁琐，而且注意栈如果为空的话调用栈的.top()会报错，所以把原来的表达式的最外层加一对括号来保护。 括号画家https://ac.nowcoder.com/acm/problem/50998 括号匹配，寻找最长合法括号匹配串。由于如果出现不合法的情况，那么之前的合法的长度就不能加到后面的括号序列上了。所以只需维护一个括号匹配栈即可，如果出现了不合法的情况就将最长串和目前的最长串进行一个更新即可，最后答案中的长度就是最长的合法括号字串的长度。 并查集奶酪（5.8）https://ac.nowcoder.com/acm/problem/16417 经典并查集例题，怎么写都能过的无极数据友好的题，只用将两两洞进行测距然后看距离满足，如果满足就直接将两个洞用并查集连在一起。然后看离地下比较近的洞和离上面比较近的洞是否联通即可。这道题应该也可以用其他测联通的方法写出来。 关押罪犯https://ac.nowcoder.com/acm/problem/16591 并查集的经典应用，一个非常好的思路是：我们将并查集的f数组进行拓展一下来表示更多的状态，来简化一些比较困难的逻辑表示。我们将f数组拓展一倍，i表示一个监狱i+n表示另一个监狱。我们对于每一对罪犯，都默认将他们装到不同的两个监狱中即a和b+n，a+n和b，然后检查他们在相同的监狱中是否出现冲突。这个做法其实是将一个状态拆成了比较好表示的两个状态。将逻辑上很复杂才能检测的问题变成一些很简单能判断的问题。这种方法叫做建立虚点。 虚点的建立可以拓展表示一个点的多个状态。 食物链（5.9）https://ac.nowcoder.com/acm/problem/16884 这题本质上应该是然用带权的并查集来写，但是有一种比较好写的方法是开虚点。用三倍的n的数组来表示每一个点的三个不同性质，对不同性质之间进行操作，这样就减小了处理复杂问题的难度。 棋盘问题（5.15）http://poj.org/problem?id=1321 一道经典的搜索题，用dfs进行搜索，一个控制层数，一个控制放了几个棋子。注意dfs中需要将每一层的情况都列出来。 刷题打卡墙5.8： 5道。挺麻的，又开始觉得自己是个fw了 5.15：1道题，被张宇说的网络流刺激到了，又滚来刷题了。 5.23：1道题，kuangbin的题单质量就是高，把之前的一道题改对了，还是浮躁，张文军教练的话，很有道理。 5.24：1道题，今天晚上有cf的#722的div2的比赛。但是进晚了怕掉分没打，写了一下t1，水体一道。 5.25：1道题，kuangbin的搜索专题。","link":"/58203"},{"title":"博弈论入门","text":"几种经典博弈的总结 巴什博弈：经典的巴什博奕模型： 只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个，最后取光者得胜。 解决思路：当n=m+1时，由于一次最多只能取m个，所以无论先取者拿走多少个，后取者都能够一次拿走剩余的物品，后者取胜，所以当一方面对的局势是n%(m+1)=0时，其面临的是必败的局势。所以当n=（m+1)r+s，（r为任意自然数，s≤m)时,如果先取者要拿走s个物品，如果后取者拿走x（≤m)个，那么先取者再拿走m+1-x个，结果剩下（m+1）（r-1）个，以后保持这样的取法，那么先取者肯定获胜。总之，要保持给对手留下（m+1）的倍数，就能最后获胜。结论：当n%(m+1)=0时，在最优策略下，后手必胜。 变形最后取光的人输…结论：当n%(m+1)=1 时，在最优策略下，后手必胜。 为什么？因为赢得人肯定会先取完(n - 1)个石子。 巴什博奕的简单变形： 只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取a，最多取b个，最后取光者得胜。 威佐夫博弈： 两堆各若干个物品，两个人轮流从任意一堆中取出至少一个或者同时从两堆中取出同样多的物品，规定每次至少取一个，至多不限，最后取光者胜利。 参考博客 12345678inline bool check(int x, int y) { int a = min(x, y), b = max(x, y); double c = (double)abs(b - a); double r = (sqrt(5.0) + 1) / 2; int tmp = int(c * r); if (a == tmp) return 0; //后手必胜 else return 1; //先手必胜 } 尼姆博奕 有N堆石子。A B两个人轮流拿，A先拿。每次只能从一堆中取若干个，可将一堆全取走，但不可不取，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N及每堆石子的数量，问最后谁能赢得比赛。 参考博客 斐波那契博弈 有一堆个数为n的石子，游戏双方轮流取石子，满足： （1）先手不能在第一次把所有的石子取完； （2）之后每次可以取的石子数介于1到对手刚取的石子数的2倍之间（包含1和对手刚取的石子数的2倍）。 约定取走最后一个石子的人为赢家。 结论：当n为Fibonacci数时，先手必败。即存在先手的必败态当且仅当石头个数为Fibonacci数。 公平组合博弈（ICG）每次只能走到必胜点的是必败点，可以走到必败点的是必胜点。","link":"/39273"},{"title":"大学物理复习笔记","text":"大一下学期准备大物考试的小小总结 第16章第1-3节：q = ne 电荷是量子化的 e = 1.62×10 ^ -19 C密立根油滴实验：电荷的量子性。mC uC nC pC10^-3 10^-6 10^-9 10^-12质子的质量：1.6×10^-27电子的质量：9×10^-31 极化：电中性的物体中，正负电荷的中心不重合的现象。 库伦定律： K的值：9×10^9 N·㎡/C^2 同号相斥，异号相吸 场是一种物质，无静止质量 第4节：电场强度：单位： N/C or V/m 是电场中某一点的一个性质 q是场源电荷 两条电场线不会相交，电场线不闭合 电偶极子：电偶极矩：p ⃑ = ql ⃑ 方向从负电荷指向正电荷 薄金属球壳中电场线的分布 第5节：“无限大”带电平面所激发的电场 σ:平面上的电荷面密度。“无限大”带电平面所激发的电场强度与离平面的距离无关，即在平面两侧形成一均匀场. 带有等量异号的平行金属板所产生的电场 σ:平面上的电荷面密度 第6节：导体处于静电平衡时，内部电场为0。静电荷分布在导体表面，尖端电荷密度最高。导体内部没有电场线，电场线垂直与导体表面尖端放电现象。 当腔内无导体时：空腔导体不接地的时候外面的电场不会影响腔内当腔内有导体时：空腔导体接地时外面的电场不会影响腔内 在空腔中的导体位置进行移动的话，对腔内和腔外的电场分布没有影响。 第7节：电通量：通过电场中某一给定平面的电场线的总条数叫做通过该面的电通量（垂直穿过或者斜着穿过对电通量的大小相同）电通量计算公式： 简单来说，就是某块平面的电场强度乘以这块平面的面积。几何意义：通过闭合曲面的电场线的净条数。 高斯定理： 静电场的高斯定理(Gauss’s law) 的表述:在静电场内,任一闭合面的电通量等于这闭合面所包围的电量的代数和(净电荷)除以ε0 .该定理将一任意闭合曲面上的电场和闭合曲面内所包围的净电荷联系起来。静电场是有源场。高斯定理求出来的是电通量，电通量乘以面积得到的是电场强度。 高斯定理在求解场强方面的应用： 均匀带电球面的电场分布，设球面半径为R，球面上所带总电量为q。 电荷均匀分布在一条长直细线上。线上单位长度所带电荷恒定为λ。求距离细线r处电场的大小，假设此处与线的两端相距很远。 求无限大均匀带电平面的电场分布。已知带电平面电荷面密度为σ。 第17章第1节：保守力：力所做的功和始末位置有关，和路径无关。静电场环路定理：静电场强沿任意闭合路径的线积分为零。反映了静电场是保守力场（无旋场）。 凡保守力都有与其相关的势能，静电场是有势场。 势能与做功的关系 电势能只与物体的位置有关，与路径无关。 电场力推出的电势能的公式。 第2节： 当取试验电荷为单位正电荷时，V_a和U_a等值，这表示静电场中某点的电势在数值上等于单位正电荷放在该点处时的电势能，也等于单位正电荷从该点经过任意路径到电势零点时电场力所做的功。 求均匀带电球面的电势分布。设球面半径为R，带电量为Q： 电势分布： 一个带电的导体球外的电场和其上所带电荷都集中在球心时形成的点电荷产生的电场相同。 点电荷的电势： 点电荷的电势能： 注意：电场是矢量，电势是标量电场为零的地方电势可以不为零；电势为零的地方电场也可以不是零。 第3-4节：等势面：将电势相等的场点连成连续的曲面——等势面相邻等势面的电势差为常量，可以得到一系列的等势面 电荷沿等势面移动，电场力不做功。 电势能只与物体的位置有关，与路径无关。 静电平衡下的导体内部和导体表面处处电势相等，整个导体是个等势体，导体表面成为等势面。 第5节：电容器：一种储存电能的原件，由电介质隔开的两块任意形状导体组合而成。两导体称为电容器的极板。 定义式：单位：F(法拉) C 是描述电容器储电本领的物理量 C 取决于电容器两板的形状、大小、相对位置及中间电介质的种类和分布情况； 物理意义：导体每升高单位电势所需的电量。 组成：用真空或绝缘体分开的两个导体。 平行板电容器的推导式。 球形电容器的推导式。 圆柱形电容器的推导式。当极板间距d&lt;&lt; RA时，圆柱形电容器类似于平行板电容器。 电容的串并联： 并联： 串联： 第6节：相对介电常数：相对介电常数是一个量纲为一的数，即有介质时的电容和没有介质时的电容比值。 电介质的介电常数与真空介电常数的比值。电容器存储的电势能 能量密度：单位体积的电势能该能量密度的表达式对任意电场都普遍成立。只要有电场的地方就有能量。 第18章：第1-3节：电流：单位时间通过垂直于电流方向的某一面积的净电量。载流子：自由电子、离子、空穴（正的载流子叫作空穴） 电池的电动势： 普通电池尺寸不同，电池越大，它储存的化学物质的量就越多，相应储存的化学能就越多，但它们都提供相同的电动势（1.5V）大小电池的另外一个区别就是大电池通常能更快的抽运电荷，也就是说大电池能提供更大的电流。 电流可表示为：单位体积内传导电子的数量：n，在体积A vD Δt内的电子数为N = nA vD Δt，电量为： ΔQ=Ne= neA vD Δt， 第4节：欧姆定律： 电阻定义： 单位：欧姆（Ω）1 Ω=1V/A电阻率： 电阻率和温度的关系： 路端电压（V）： 第5节:基尔霍夫节点电流定律：流入一个节点的所有支路的电流之和等于流出这个节点的所有支路的电流之和。任何一个电的连接点即为节点。 基尔霍夫回路电压定律:适用于电路中起始和终止于同一点的任何回路。电势改变的代数和为零。 第6节：串联与并联电路：串联电阻器: 串联电容器: 并联电阻器: 并联电容器： 第8-11节：电路中的功率与能量：功率的单位：J/s=A·V=W 在电阻上的能量可表示为: 电流表和电压表 RC电路：同时包含电阻器和电容器的电路。 第19章：第1-2节：磁感应强度B：单位 (SI)： T(特斯拉) 第3节：垂直于匀强磁场运动的带电粒子：粒子做匀速圆周运动 速度选择器: 质谱仪： 回旋加速器： 第4-5节：粒子作螺旋线向前运动，轨迹是螺旋线： 霍耳效应： 第6节： 注意对无线长载流直导线的B的求法。其中μ0 = 4π 第7节： 第8节： 第9节：一、恒定磁场的高斯定理： 二、安培环路定理：","link":"/4612"},{"title":"微信小程序开发入门","text":"刚开始，先进行一个demo的学习。原文链接：https://blog.csdn.net/lu_embedded/article/details/86181251 项目目录结构微信小程序的基本文件构造和项目目录结构说明如下： . ├── app.js # 小程序的逻辑文件 ├── app.json # 小程序的配置文件 ├── app.wxss # 全局公共样式文件 ├── pages # 存放小程序的各个页面 │ ├── index # index页面 │ │ ├── index.js # 页面逻辑 │ │ ├── index.wxml # 页面结构 │ │ └── index.wxss # 页面样式表 │ └── logs # logs页面 │ ├── logs.js # 页面逻辑 │ ├── logs.json # 页面配置 │ ├── logs.wxml # 页面结构 │ └── logs.wxss # 页面样式表 ├── project.config.json └── utils └── util.js 页头页尾pages 属性用来设置页面路径，它是一个数组，每一项都是字符串来指定小程序由哪些页面组成。数组的第一项代表小程序的初始页面。小程序中新增或减少页面，都需要对 pages 数组进行修改。 window 属性用于设置小程序的状态栏、导航条、标题、窗口背景色。 我们把页头的标题和颜色修改一下，页尾部分我们做一个 tab 栏来切换页面，这个属性叫做 tabBar，代码如下： 1234567891011121314151617181920212223242526272829303132{ &quot;pages&quot;:[ &quot;pages/index/index&quot;, &quot;pages/logs/logs&quot; ], &quot;window&quot;:{ &quot;backgroundTextStyle&quot;:&quot;light&quot;, &quot;navigationBarBackgroundColor&quot;: &quot;#2f2f8f&quot;, &quot;navigationBarTitleText&quot;: &quot;GoZeroWaste&quot;, # 标题 &quot;navigationBarTextStyle&quot;:&quot;white&quot; }, &quot;tabBar&quot;:{ &quot;color&quot;: &quot;#bfc1ab&quot;, &quot;selectedColor&quot;: &quot;#13b11c&quot;, &quot;backgroundColor&quot;: &quot;#1f1f4f&quot;, &quot;list&quot;: [ # 导航栏的两个按钮 { &quot;pagePath&quot;: &quot;pages/index/index&quot;, &quot;iconPath&quot;: &quot;image/icon_component.png&quot;, # 第一个按钮的图标 &quot;selectedIconPath&quot;: &quot;image/icon_component_HL.png&quot;, # 选择第二个按钮后第一个的按钮的图标 &quot;text&quot;: &quot;个人中心&quot; # 按钮的名字 }, { &quot;pagePath&quot;: &quot;pages/details/details&quot;, &quot;iconPath&quot;: &quot;image/icon_API.png&quot;, # 第二个按钮的图标 &quot;selectedIconPath&quot;: &quot;image/icon_API_HL.png&quot;, # 选择第一个按钮后第二个的按钮的图标 &quot;text&quot;: &quot;生活指南&quot; # 按钮的名字 } ] }} （所用到的图片放在项目的 image 目录，你也可以使用自己的图片） 这里用到几个 tabBar 的属性是 color、selectedColor、backgroundColor 和 list，list 是一个数组，主要用于设定导航的路径。 因为导航栏中一个按钮关联的是另一个页面，但是这个页面还没有存在，所以我们需要在app.json文件的list中直接添加，修改app.json文件： 1234567{ &quot;pages&quot;:[ &quot;pages/index/index&quot;, &quot;pages/logs/logs&quot;, &quot;pages/details/details&quot; ], CTRL + S 保存之后，模拟器就会自动刷新，马上可以看到效果。保存刷新之后就会发现，目录结构里自动创建了这一页。 简单起见，我们就在 pages/index 目录下实现 “个人中心” 页面好了。双击打开 index.wxml，初始内容如下： 这里已经有一些代码了，虽然现在可能还看不懂，但我们知道，这就是现在页面的源代码。我们把 “Hello World” 部分注释掉，增加我们希望显示的内容： 12345678910111213141516171819202122232425&lt;!--index.wxml--&gt;&lt;view class=&quot;container&quot;&gt; &lt;view class=&quot;userinfo&quot;&gt; &lt;button wx:if=&quot;{{!hasUserInfo &amp;&amp; canIUse}}&quot; open-type=&quot;getUserInfo&quot; bindgetuserinfo=&quot;getUserInfo&quot;&gt; 获取头像昵称 &lt;/button&gt; &lt;block wx:else&gt; &lt;image bindtap=&quot;bindViewTap&quot; class=&quot;userinfo-avatar&quot; src=&quot;{{userInfo.avatarUrl}}&quot; background-size=&quot;cover&quot;&gt;&lt;/image&gt; &lt;text class=&quot;userinfo-nickname&quot;&gt;{{userInfo.nickName}}&lt;/text&gt; &lt;/block&gt; &lt;/view&gt; &lt;!-- &lt;view class=&quot;usermotto&quot;&gt; &lt;text class=&quot;user-motto&quot;&gt;{{motto}}&lt;/text&gt; &lt;/view&gt; --&gt; &lt;!--注释内容--&gt; &lt;!--页面的三行字--&gt; &lt;view class=&quot;ID_Badge&quot;&gt; &lt;view&gt; &lt;text class=&quot;ID_info&quot;&gt;{{company}}&lt;/text&gt; &lt;/view&gt; &lt;view&gt; &lt;text class='ID_info'&gt;{{position}}&lt;/text&gt; &lt;/view&gt; &lt;view&gt; &lt;text class='ID_info'&gt;{{lesson}}&lt;/text&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 123456发现HTML的几种特性，自己总结的：1.一个标签出现之后会有一个相同的带反斜线的作为结尾，所以每一个标签都是成对出现的比如：&lt;view&gt;&lt;/view&gt; &lt;text&gt;&lt;/text&gt; 2.在一个标签可以修饰一个变量，然后这个变化的量有一个类，用class来说明，比如&lt;view class = &quot;ID_Badge&quot;&gt; &lt;text class = &quot;ID_info&quot;&gt;3.一个变量可以与.js文件中的date中的值相互关联，所以html只作为一个最前面的一个框架的作用，后面的.js文件支撑整个页面逻辑。4.只有html文件和js文件并不行，每一个类都需要在本页面的css文件内进行声明，并且设置这个类的样式属性。5.每一个text或者image的标签必须被一对view标签包围。","link":"/13114"},{"title":"数学建模入门","text":"准备数学建模过程中的一些小小笔记 Matlab学习笔记语法小知识： 同一行中间用逗号分隔，也可以不用逗号，直接用空格 分号可以用来分隔每一行的元素就是说逗号是一行中的数据，分号分割行与行之间。 矩阵E(:)表示矩阵的所有元素，E(:,1)表示第一列，E(1,:)表示第一行。 2:5表示从第2到第5，1:3:10表示从1到10，每次递增3。2:end表示从第二行到最后一行， ~=是不等号 Matlab函数的声明要单独放在一个.m文件中，不能直接放在主函数里面。函数声明格式：function [输出变量] = 函数名称(输入变量） 最后用end结束声明 123456789101112131415161718192021222324252627282930313233343536373839404142% 常用指令操作clc % 清屏clear all % 清除工作区的所有变量hold on hold off % 控制图像是否被刷新% 常用字符串函数char(65) % ascii码对应的字符，Alength(s) % 字符串长度strcmp() % 字符串比较函数strcat() % 将多个字符串合并成一个num2str() % 将数字转换为字符串% 常用数学函数size() % 数组大小，第二个参数也是dim表示矩阵的维度。magic() % 生成一个幻方abs(s) % 求s的ascii码floor() % 取整函数sum() % 求和函数，辅助参数dim表示求和的维度，1表示按列，2表示按行，默认dim=1repmat() % 复制扩展矩阵sort() % 将数组或矩阵排序prod() % 计算矩阵每一列的乘积eig() % 计算矩阵的特征值inv() % 求矩阵的逆矩阵rand() % 产生（0,1）之间均匀分布的伪随机数组成的数组randn() % 生成标准正态分布的伪随机数（均值为0，方差为1）randperm() % 将一序号随机打乱，序号必须是整数normrnd(MU,SIGMA) % 生成服从正态分布的随机数% 常用数据输入输出函数disp() % 向命令行输出字符或数字input() % 从命令行读取数据xlsread('xls_name_string') % Excel表格读取save % 用来将数据保存为.mat文件load % 用来加载之间生成的.mat文件% 常用绘图函数plot(x, y) % 创建2维直线图stem(Y) % 绘制数据序列Y的茎状图meshgrid(a, b) % 生成二维网格contour3(x, y, z) % 三维等值线绘图legend('string1','string2') % 标注绘制的图形的名称xlabel() ylabel() zlabel() % 标注x,y,z轴title() % matlab绘图标题设置set() % 设置图像属性axis() % 对坐标轴进行缩放操作 123% matlab里的一些基本规范% 数值% 字符串 floor函数详解 randperm函数详解 normrnd函数详解 repmat函数详解 size函数详解 magic函数详解 sum函数详解 prod函数详解 eig函数详解 find函数详解 plot命令详解 meshgrid函数详解 contour3函数详解 stem函数详解 hold on 和 hold off 语句详解 legend函数详解 xlabel函数详解 set函数详解 axis函数详解 title函数详解+matlab二维画图基本操作 xlsread函数详解 disp函数详解 input函数详解 save 和 load详解 一、矩阵及数组操作例题： 1234567891011121314151617181920212223% 生成一个3x3和15x8的单位矩阵eye(3, 3)eye(15, 8)% 生成全1矩阵ones(3)ones(15, 8)% 全0矩阵zeros(3)zeros(15, 8)% 均匀分布随机矩阵（[-1, 1]之间）2 * rand(3, 3) - 12 * rand(15, 8) - 1% 正态分布矩阵（均值为1，方差为4）1+sqrt(4)*randn(3,3)% 利用fix及rand函数生成[0,10]上的均匀分布的10x10的整数随机矩阵a，然后统计a中大于等于5的元素的个数。a = fix(10*rand(10,10));b = [a&gt;=5];c = [sum(b)];sum(c')% 在给定的矩阵中删除含有整行内容全为0的行，删除整列内容全为0的列。a = [1 2 0 4;0 0 0 0;5 6 0 8; 9 1 0 2];a(:,find(sum(abs(a'))==0)) = [];a(find(sum(abs(a'))==0),:) = [] % 没看懂，该写法待确认 二、绘图： 123456789101112% 在同一图形窗口画出下列两条曲线图像，并用legend标注：x=0 : 1 : 10;y1=2*x+5;y2=x.^2-3*x+1;plot(x, y1, x, y2);legend('y1','y2')% 画出下列函数的曲面及等高线% z = x^2 + y^2 + sin(xy).[x, y] = meshgrid(0:0.25:4*pi);z=x.^2+y.^2+sin(x*y);contour3(x, y, z);meshc(x, y, z) 三、简单程序设计 123456789101112131415161718192021222324% 求分段函数x=input('请输入x的值：');if x&gt;=-3 &amp;&amp; x &lt; -1 y=(-x^2-4*x-3)/2;elseif x&gt;=-1 &amp;&amp; x&lt;1 y=-x^2+1;elseif x&gt;=1 &amp;&amp; x&lt;=3 y=(-x^2+4*x-3)/2;else y='error'endy% 分数序列求和m = 1;n = 2;sum = 0;for k=1:15 f=n/m; sum=sum+f; t=n; n=m+n; m=t;endsum 一些注意事项: 在变量定义的时候多写注释，注明每个变量的作用。 好的数学建模matlab的代码部分注释都很详细。 可以将代码分成几个部分，这样更加清晰，e.g. 数据清除，导入数据，数据预处理，相关步骤等…. 在很多代码开头会遇到：clear;clc 这两条一起使用，起到“初始化”的作用，防止之前的结果对新脚本文件（后缀名是 .m）产生干扰。 数学建模常见算法学习层次分析法（AHP）一、对于一个问题，先分析系统中各因素之间的关系，建立系统的递阶层次结构（三层图）。 二、然后对于同一层次的各元素关于上一层中某一准则的重要性进行两两比较，构造判断矩阵。 在准则层需要生成每个准则的权重，在方案层需要生成对于每个准则的得分，使用两两对比的方法生成判断矩阵然后就可以计算出每个准则的权重或者方案对不同准则的得分了。 在层次分析法中我们构造的判断矩阵均是正互反矩阵(𝑎ij * 𝑎ji = 1)，若正互反矩阵满足𝑎ij * 𝑎jk = 𝑎ik，则我们称为一致矩阵。在判断矩阵计算准则的权重或者方案对不同准则的得分之前，需要对其进行一致性检验。 三、通过计算一致性指标和一致性比例来评判判断矩阵是否可以接受，计算对于该准则的相对权重。 进行一致性检验的一致矩阵准则的权重的计算或者方案对不同准则的得分的计算，计算权重或者得分有多种方式： 算数平均法求权重 集合平均法求权重 特征值法求权重 计算出所有的方案对不同准则的得分和准则的权重之后就可以计算每个方案的加权得分了。 四、计算各层元素对系统目标的合成权重，并进行排序。 TOPSIS法（优劣解距离法）一、将原始矩阵正向化，将所有的指标转化成极大型指标。 极大型指标 极小型指标 中间型指标 区间型指标 二、正向化矩阵标准化。 消除不同指标量纲的影响，例如名次和分数两个指标导致的量纲不统一的影响。 三、计算得分并归一化 通过公式计算每一个评价对象对不同的评价指标离最小值的距离和到最大最小距离的和的比值来得到评价对象在该评价指标上的得分。 四、带权重的TOPSIS 通过层次分析法可以得到不同的指标的权值，在进行计算得分的时候乘以相应的权值。 插值算法 理解：感觉该算法就是通过已知的一些点来推测拟合出一个函数，并借此函数计算出需要插值的点所对应的值是多少 常见插值方法： 多项式插值 分段插值 三角插值 一、拉格朗日插值法 通过该方法，可以通过n+1个点来找到一个n+1项n次的一个多项式作为插值函数，来估计对应插值点的函数值。 龙格现象：高次插值会产生龙格现象，即在两端处波动极大，产生明显的震荡。在不熟悉曲线的运动趋势的前提下，不要轻易使用高次插值 分段线性插值 分段线性插值法的一种为分段二次插值法，在几何上利用分段抛物线来代替原函数，故分段二次插值法又称为分段抛物线插值法。 但是在分段时使用的插值方法本质还是拉格朗日插值法。 二、牛顿插值法 与拉格朗日插值法相比，牛顿插值法具有继承性。（牛顿插值法每次插值只和前n项的值有关，这样每次只要在原来的函数上添加新的项，就能够产生新的函数）但是牛顿插值也存在龙格现象的问题。 拉格朗日插值法和牛顿插值法两种方法得到的多项式都不能全面的反映被插值函数的形态，比如说在一个或者全部节点上的导数值，或者高阶导数值，这两种插值法都不能满足。 三、埃尔米特（Hermite）插值法 埃尔米特插值法可以保证插值函数在节点处有切线（光滑）使插值函数和被插值函数的密合程度比较好。 分段三次埃尔米特插值法 直接使用Hermite插值得到的多项式的次数也比较高，也会存在龙格现象，因此在实际应用中，往往使用分段三次Hermite插值多项式（PCHIP） 四、三次样条插值法 该插值法同样是区间插值法，是可以保证二阶连续可微的插值法。 这些插值法都在Matlab内部提供了封装好的实现方法，体现为内置的函数。","link":"/35840"},{"title":"数据结构复习","text":"期末的小小总结 文件下载蜂考教案 数据结构期末考试考点第一章 数据结构和算法数据结构 算法 第二章 顺序表线性表逻辑结构，顺序表和链表都属于线性表。 顺序表的结构 第三章 链表单链表的结构 双链表和循环链表 第四章 栈和队列 栈的链式结构 队列的循序储存 头指针指的是头，尾指针指的是元素后面那一个。 第五章 串 矩阵的压缩 第六章 树和二叉树 二叉树 一个有趣的推论： 一个n叉树上叶子节点的个数为：度为n的节点的个数乘以n - 1，加上度为n - 1的节点的个数乘以n - 2……直到加上度为2的节点个数乘以1。得到的结果就是n叉树上叶子节点的个数。 可以进行简单的证明。 树和森林 二叉排序树 为了删去78，用87来代替78。同时将原位置上的78进行删除操作，然后进行调整只有将87放到78的位置上。 哈曼夫树 第八章 图 图的储存 第九章 图的应用最小生成树 拓扑排序 关键路径 第十章 查找 顺序查找 折半查找 散列表 第十一章 排序 插入排序直接插入排序 插入排序是指当循环第i次时，将a[i]插入到前i个有序的序列中去。 希尔排序 交换排序冒泡排序 快速排序 第十二章 排序（2）选择排序简单选择排序 选择排序是指当循环到第i次时，将i之后的序列中第i小（大）的值拍到第i的位置上去。 堆排序 归并排序 基数排序 各种排序算法比较","link":"/11651"},{"title":"河南大学暑假集训的日常（1）","text":"DAY1(STL) HDU1880魔咒词典（字符串Hash/map/） 水题，两个map即可，细节在于string用cin读还是getline读，然后可以用string的erase来去掉中括号【】 以上的话，是提交卡在队列里时自信打出来的。最后发现是水的是我。。。 用两个map的话交一遍就会发现一定会MLE。。。而且HDU的MLE规则很奇怪，不要尝试参考评测机的内存大小来调数组的大小，没有用的。。以图为证： 是的，我MLE了20多次，都是在尝试调数组的大小。。。。。 正解应该是Hash+挂链法或者寻址法，但是我写的挂链法也还是MLE。。。最后选择了zy选择的vector。但是注意：这个代码也还是可以被卡掉，这个hash并没有处理字符串冲突的情况。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 100010;vector&lt;int&gt; a, b; string s1[maxn];string s2[maxn];string t1, t2;int cnt, n;int gethash(string s) { int res = 0, leng = s.length(); for (int i=0;i&lt;leng;++i) res += res * 237 + s[i]; return res;}int main() { while(cin &gt;&gt; t1 &amp;&amp; t1 != &quot;@END@&quot;) { getchar(); getline(cin, t2); int c1 = gethash(t1); int c2 = gethash(t2); a.push_back(c1); b.push_back(c2); s1[cnt] = t1; s2[cnt++] = t2; } cin &gt;&gt; n;getchar(); for (int i=1;i&lt;=n;++i) { getline(cin, t1); int tmp = gethash(t1); if (t1[0] == '[') { if (find(a.begin(), a.end(), tmp) == a.end()) cout &lt;&lt; &quot;what?&quot; &lt;&lt; endl; else cout &lt;&lt; s2[find(a.begin(), a.end(), tmp) - a.begin()] &lt;&lt; endl; }else { if (find(b.begin(), b.end(), tmp) == b.end()) cout &lt;&lt; &quot;what?&quot; &lt;&lt; endl; else { string s3 = s1[find(b.begin(), b.end(), tmp) - b.begin()]; for (int i=1;i&lt;s3.length()-1;++i) cout &lt;&lt; s3[i]; cout &lt;&lt; endl; } } } return 0;} HDU1276士兵队列训练问题（模拟/约瑟夫环） 用vector完成，简单模拟，水题。 第一遍没有注意输出空格PE了一次，第二遍A了 代码（比较丑陋）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; a, b;int n, m;int vsize() { int leng = a.size(), res = 0; for (int i=1;i&lt;leng;i++) { if (a[i] != -1) res++; } return res;}void work() { int flag = 0, leng; while(vsize() &gt; 3) { leng = a.size(); if (!flag) { for (int i=1;i&lt;leng;++i) if (i % 2 == 0) { a[i] = -1; } }else { for (int i=1;i&lt;leng;++i) if (i % 3 == 0) { a[i] = -1; } } for (vector&lt;int&gt;::iterator it=a.begin();it!=a.end();it++) { if (*it == -1) { a.erase(it); it--; } } flag = flag == 1 ? 0 : 1; }}int main() { cin &gt;&gt; n; for (int i=1;i&lt;=n;++i) { cin &gt;&gt; m; a.clear(); b.clear(); a.push_back(0); for (int j=1;j&lt;=m;++j) a.push_back(j); work(); for (vector&lt;int&gt;::iterator it=a.begin() + 1;it!=a.end();it++) { if (*it != -1) b.push_back(*it); } for (vector&lt;int&gt;::iterator it=b.begin();it!=b.end();it++) { if (it != b.end() - 1) cout &lt;&lt; *it &lt;&lt; ' '; else cout &lt;&lt; *it; } cout &lt;&lt; endl; } return 0;} 牛客 吐泡泡（栈） 点开之后发现5月的时候写过了。。。看了一下发现记不得自己是怎么做了，估计是要老年痴呆了（确信）简单的栈应用。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;#define rep(i, a, n) for (int i=a;i&lt;=n;++i)#define per(i, n, a) for (int i=n;i&gt;=a;--i)#define enter putchar('\\n')typedef long long ll;using namespace std;string s, ans;stack&lt;char&gt; sk;int len;int main() { while(cin &gt;&gt; s) { ans = &quot;&quot;; len = s.length(); rep(i, 0, len - 1) { if (sk.empty()) { sk.push(s[i]); continue; } else { char temp = sk.top(); if (temp == s[i]) { if (temp == 'o') { sk.pop(); if (sk.size() &amp;&amp; sk.top() == 'O') sk.pop(); else sk.push('O'); } else sk.pop(); }else sk.push(s[i]); } } while(sk.size()) { ans += sk.top(); sk.pop(); } per(i, ans.size() - 1, 0) cout &lt;&lt; ans[i]; enter; } return 0;} DAY2(单调栈、单调队列、ST表)POJ - 3250Bad Hair Day（单调栈） 由题可知将答案求每个羊可以看到多少只右边的羊转化为求每一个羊可以被多少左边的羊看到，然后在纸上模拟一下就可以发现单调栈满足这个过程。单调栈和单调队列难都是在思路的转换，一眼会想不到。 代码（摘了眼镜看形状好奇怪啊。。）： 12345678910111213141516171819#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;stack&lt;ll&gt; st;ll n, ans, tmp;int main() { cin &gt;&gt; n; cin &gt;&gt; tmp; st.push(tmp); for (int i=1;i&lt;n;++i) { cin &gt;&gt; tmp; while(st.size() &amp;&amp; st.top() &lt;= tmp) st.pop(); ans += st.size(); st.push(tmp); } cout &lt;&lt; ans; return 0;} POJ - 2823 Sliding Window（单调队列） 如果我们要得到区间的最大值，那我们可以维护一个队列，在里面存一些我们遇到过的比较大的值，并且保证这个队列是递减的。那么如果我们这时拿到一个新的数据，我们只需要把这个数据放到当前队列的正确的位置然后取队首元素就能找到最大值了。 由于该队列是单调递增的，所以只需要将新的数据和队尾的值进行比较，如果队尾的值比较小，那么直接扔掉，因为我们要得到的是区间的最大值，所以舍去一些比较小并且比较旧的值并没有什么影响。 对于这道题最后需要注意的是处理完数据之后的队首是否在当前数据的窗口中，若不在，那么将旧数据直接舍弃即可。 处理区间的最小值同理。 对于队列维护的模拟可以看这个博客。 这道题还有一些小坑。因为在POJ上，会比较慢，用deque会T掉，可以用数组模拟一个双端队列。然后常数大也会被卡掉，所以要用快读。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;deque&gt;using namespace std;const int maxn = 1e6 +7;int n, k;int a[maxn], b1[maxn], b2[maxn], tot1, tot2, h1, h2, t1, t2;pair&lt;int, int&gt; q1[maxn], q2[maxn];inline int read() { int a=0,f=1; char c=getchar(); while (c&lt;'0'||c&gt;'9') {if (c=='-') f=-1; c=getchar();} while (c&gt;='0'&amp;&amp;c&lt;='9') {a=a*10+c-'0'; c=getchar();} return a*f;}void init() { ios::sync_with_stdio(false); n = read();k=read(); for (int i=1;i&lt;=n;++i) a[i] = read(); h1 = 1, h2 = 1, t1 = 1, t2 = 1;}inline void write(int x){ if(x&gt;9)write(x/10); putchar(x%10+'0');}void solve() { for (int i=1;i&lt;k;++i) { while(h1 &lt; t1 &amp;&amp; q1[t1-1].first &lt;= a[i]) t1--; while(h2 &lt; t2 &amp;&amp; q2[t2-1].first &gt;= a[i]) t2--; q1[t1].second = i;q1[t1++].first = a[i]; q2[t2].second = i;q2[t2++].first = a[i]; } for (int i=k;i&lt;=n;++i) { while(h1 &lt; t1 &amp;&amp; q1[h1].second &lt;= i - k) h1++; while(h2 &lt; t2 &amp;&amp; q2[h2].second &lt;= i - k) h2++; while(h1 &lt; t1 &amp;&amp; q1[t1-1].first &lt;= a[i]) t1--; while(h2 &lt; t2 &amp;&amp; q2[t2-1].first &gt;= a[i]) t2--; q1[t1].second = i;q1[t1++].first = a[i]; q2[t2].second = i;q2[t2++].first = a[i]; b1[++tot1] = q1[h1].first; b2[++tot2] = q2[h2].first; }}void print() { for (int i=1;i&lt;=tot1;++i) if(i!=tot1) printf(&quot;%d &quot;,b2[i]); else printf(&quot;%d\\n&quot;,b2[i]); for (int i=1;i&lt;=tot2;++i) if(i!=tot2) printf(&quot;%d &quot;,b1[i]); else printf(&quot;%d&quot;,b1[i]);}int main() { init(); solve(); print(); return 0;} POJ - 3264 Balanced Lineup（ST表/线段树/树状数组） 这道题是学长讲的ST表的例题，本质是一个RMQ。 ST表，是利用倍增和动态规划的思想处理出的一个查询表，需要用nlogn的时间预处理，得到ST表之后，就可用O(1)的时间查询任意区间内的极值。 ST表的预处理的状态转移方程：d1[i][j]=min(d1[i-1][j],d1[i-1][j+bin[i-1]]); i表示2的i次方，j表示某个点。对于每一个点的所有有意义的2的i次方长度的区间内的极值都需要求出。 ST算法进行查询的核心是在预处理出每个端点本身开始往后的2的i次方的范围内的每一个2区间内的极值后。对于每一次查询，找到满足区间长度r - l + 1所能满足的最大的2的x次方，然后将长度分为两半，以2的x-1次方为区间长度对两个端点的左右进行查询，O（1）的复杂度，然后取这两个值中的极值即为区间的极值。 参考博客：https://blog.csdn.net/Keep_Trying_Go/article/details/116268533https://blog.csdn.net/Hanks_o/article/details/77547380 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;cstring&gt;#define rep(i,a,b) for (int i=a;i&lt;=b;++i)using namespace std;const int maxn = 50010;int n, q; int a[maxn], bin[30], Log[maxn];int d1[30][maxn], d2[30][maxn];void init() { memset(a,0,sizeof(a)); memset(d1,0,sizeof(d1)); memset(d2,0,sizeof(d2)); bin[0] = 1;Log[0] = -1; cin &gt;&gt; n &gt;&gt; q; rep(i,1,n) cin &gt;&gt; a[i]; rep(i,1,20) bin[i] = bin[i - 1] * 2; rep(i,1,50001) Log[i] = Log[i/2] + 1; rep(i,1,n) d1[0][i] = d2[0][i] = a[i]; rep(i,1,Log[n]) { rep(j,1,n) { if(j+bin[i]-1&lt;=n) { d1[i][j]=min(d1[i-1][j],d1[i-1][j+bin[i-1]]); d2[i][j]=max(d2[i-1][j],d2[i-1][j+bin[i-1]]); } } }}void query(int x ,int y) { int t = Log[y-x+1]; int a = max(d2[t][x],d2[t][y-bin[t]+1]); int b = min(d1[t][x],d1[t][y-bin[t]+1]); cout &lt;&lt; a - b &lt;&lt; endl;}int main() { init(); rep(i,1,q) { int a, b; cin &gt;&gt; a &gt;&gt; b; query(a, b); } return 0;} POJ - 2559 Largest Rectangle in a Histogram （单调栈） 单调栈的应用。 对于每一个长方形来说，如果不重复计算的话，这道题的答案就是每个长方形向右画的长方形中面积最大的那一个。 接着想，对于某个长方形，它所能画出的最大高度就是他本身，最大宽度就是他往右的连续的不低于他的长方形的宽度。对于一个高度上升的长方形序列，其中一个长方形所能达到的最大面积就是向右不低于该长方形的所有长方形的宽度和，所以，对于一个还在上升的序列，并不能知道它最右边能够到达的宽度有多少，所以将其加入栈中，如果发现了一个长方形的高度下降，那么这个长方形一定可以作为上升序列中的一些长方形的右边界。此时开始计算，直到序列恢复递增为止。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#define rep(i,a,b) for (int i=a;i&lt;=b;++i)using namespace std;typedef long long ll;const int maxn = 100010;ll n, a[maxn], w[maxn], s[maxn], tail, ans;inline void init() { memset(w, 0, sizeof(w)); memset(a, 0, sizeof(a)); memset(s, 0, sizeof(s)); ans = 0, tail = 0; s[n + 1] = 0; rep(i,1,n) cin &gt;&gt; a[i];}void solve() { rep(i,1,n+1) { if (a[i] &gt; s[tail]) { s[++tail] = a[i]; w[tail] = 1; } else { int width = 0; while(a[i] &lt; s[tail]) { width += w[tail]; ans = max(ans, (ll)width * s[tail]); tail--; } s[++tail] = a[i], w[tail] = width + 1; } }}int main() { while(cin &gt;&gt; n &amp;&amp; n != 0) { init(); solve(); cout &lt;&lt; ans &lt;&lt; endl; } return 0;}","link":"/16332"},{"title":"树莓派入门","text":"找点事干，摸摸硬件 树莓派可以干点什么已经完成过的东西： 通过Frp实现外网访问树莓派 安装Jupyter实现python笔记本 使用webmin监控树莓派使用状态（已搁浅） 使用FFmpeg实现B站直播金鱼（已搁浅） Samba实现简易nas aria2实现下载机（已搁浅） 使用FFmpeg和python脚本实现B站直播轮播视频：python脚本的github仓库（欢迎:star:我的仓库） 软件准备在树莓派的所有操作中，我选择了使用全命令行的操作模式。 使用ssh远程连接树莓派，通过指令进行交互。 关于ssh软件的选择，我使用的是MobaXtream这款软件。它最大的好处是可以在连接之后直接通过文件浏览器的方式对服务器的文件进行管理，这使得本机和服务器的文件交换变得更加方便。 关于硬件改装加装风扇由于树莓派需要进行散热，如果采用被动散热在冬天很容易cpu就上到40℃以上了。 所以在添加完外壳的情况下，在树莓派cpu的上方位置加装了一个散热风扇。可以帮助树莓派更好的散热。 注意事项： 我添加的风扇是一个小功率且不可调节转速的风扇。（网络上有一些可以根据树莓派cpu温度进行自动调节的风扇，比较复杂所以就没有折腾） 该风扇通过树莓的GPIO接口进行供电。 风扇长这个样： 供电接口是一个连着的杜邦线母口 这是树莓派的GPIO引脚说明图： 将风扇的两个杜邦线引脚查到4号和6号接口上即可。 需要解决的问题： 我的树莓派上已经更换了3个小风扇了。 这些风扇常常在工作一段时间之后就会发生异响，虽然还在工作，但是噪音会变得很大。这时候我就会选择更换一个新的风扇。 但是产生异响的原因未知。 加装外壳加装外壳十分的简单，将购买的亚克力板外壳中的贴膜全部撕掉，然后一层一层按照顺序放好之后将树莓派放入外壳中，加装螺丝和螺母固定即可。 注意亚克力板的顺序需要配合树莓派的各个接口进行放置。 加装摄像头关于树莓派摄像头的选择，网络上有两种主流的方案，一种是直接通过usb接口连接一个usb摄像头，另一种是通过树莓派上预留的CSI通过排线连接。 后者的连接方法不需要额外下载安装驱动，所以我选择了后者。 注意：树莓派摄像头的安装一定要再关机的情况下进行，否则有可能会烧毁摄像头元件。 下图是树莓派上的CSI口： 将排线连接好后是这个样子： 连接好排线之后要再树莓派上打开摄像头 完成这些设置之后，摄像头就安装完成了。 摄像头的安装对后面实现直播金鱼做了硬件准备 镜像由于树莓派使用arm架构cpu的限制，使得树莓派不能使用一些针对主流x86系统的服务器镜像。好在树莓派官方有一个为树莓派定制的Linux系统，Raspbian。但是在使用这个系统的过程中，我也发现了许多问题。 Raspbian系统已知的问题有： 不完全支持docker。 Centos系统尝试过刷该系统针对树莓派的版本，但是失败了。 ssh连接如果有图像环境（向外有HDMI输出的话）可以通过图形选择打开树莓派的ssh连接，新买的树莓派是默认关闭ssh连接的，如果需要ssh连接，需要先打开。 如果没有图像环境，可以通过以下步骤进行树莓派的ssh连接。 1.开启ssh将树莓派的SD卡通过读卡器连接到pc上，打开SD卡盘符在的boot分区下建立ssh文本文档，注意，该文档没有后缀。（一些教程说可以建立一个ssh文件夹，应该原理是相似的） 2.进行连接即可通过1将树莓派的ssh打开之后，将sd卡装回树莓派，插一根网线到路由器上，然后重新开机后。找到树莓派对应的内网ip。之后直接通过ssh工具（比如mobaxterm）进行连接即可。或者通过win10的命令窗口也可以进行连接。 win10的ssh命令如下： ssh -oPort=22 pi@xxx.xxx.xxx.xxx 默认的ssh端口是22。 默认的用户名是：pi 默认的登录密码是：raspberry 网络配置有线网络配置直接将网线插入树莓派的网线插口即可，路由器会自动分配一个内网ip，从路由器的管理网站上找到树莓派分配的ip之后就可以进行ssh连接了。 无线网络配置已知的有两种方法进行无线网络的配置，一种是修改刷过镜像的sd卡中的树莓派的文件，一种是ssh连接之后通过命令行进行修改。 这里说一下后一种配置。 1.激活WiFi1）启用wifi rfkill unblock wifi 2）激活网卡 sudo ifconfig wlan0 up 2.扫描WiFi sudo iwlist wlan0 scan 3.设置需要连接的wifi名称及密码 sudo nano /etc/wpa_supplicant/wpa_supplicant.conf ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1country=CN network={ ssid=”这里填需要连接的wifi的名称（不要连5G那个）” psk=”这里填需要连接的wifi的密码” key_mgmt=WPA-PSK} 4.重启树莓派 sudo reboot 重启之后即可生效，拔掉网线，只需一根电源线就可以保证树莓派能够连接到网络辣。","link":"/63228"},{"title":"河南大学暑假集训的日常（2）","text":"DAY3（并查集） HDU - 1213 How Many Tables（并查集） 简单题。 代码： 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;const int maxn = 11000;int T, n, m, a, b;int f[maxn];int ans() { int res = 0; for (int i=1;i&lt;=n;++i) if (f[i] == i) res++; return res;}int find(int x) {return (f[x] == x) ? x : f[x] = find(f[x]);} int main() { cin &gt;&gt; T; for (int i=1;i&lt;=T;++i) { cin &gt;&gt; n &gt;&gt; m; for (int i=1;i&lt;=n;++i) f[i] = i; for (int i=1;i&lt;=m;++i) { cin &gt;&gt; a &gt;&gt; b; int x = find(a), y = find(b); f[y] = x; } printf(&quot;%d\\n&quot;, ans()); } return 0;} HDU - 3038 How Many Answers Are Wrong（带边权并查集） 该题是一道时带边权的并查集。 对于每一个节点，不仅要维护它的祖先节点（若该节点上向右的区间有值的话右端点所对应的节点）的编号，还要维护该节点到它祖先节点的距离。 距离可以为负数，在计算区间的时候减去距离就行了。在对一组区间的数据检测是否合法的时候，检测两个端点是否可以通过某一种方式通过某一种路径联通，即两节点的祖先节点是否为同一节点。如果联通，那么就可以通过这两个节点到其祖先节点的距离来计算出这两个节点之间的距离了。 对于节点到其祖先节点的距离的维护，可以通过递归寻找祖先节点的过程中更新。在每一次寻找的过程中，如果该节点不是最终的祖先节点的话，那么将该节点到祖先节点的距离加上其父节点到祖先节点的距离。 对于新插入的节点，需要维护两节点的根节点的距离关系，可以通过画出向量的方式较为清楚的表达出来： 带边权并查集参考博客 代码： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int maxn = 200010;int f[maxn], d[maxn];int n, m;int find(int x) { if (x != f[x]) { int t = f[x]; f[x] = find(f[x]); d[x] += d[t];//这句话会在find函数进行递归的过程中进行更新路径上的距离值。 } return f[x];}int main() { while(cin &gt;&gt; n &gt;&gt; m) { memset(d, 0, sizeof(d)); for (int i=0;i&lt;=maxn-2;++i) f[i] = i; int l, r, v, ans = 0; for (int i=1;i&lt;=m;++i) { scanf(&quot;%d%d%d&quot;, &amp;l,&amp;r,&amp;v); l--; int fl = find(l); int fr = find(r); if (fl == fr) { if (d[r] - d[l] != v) ans++; }//这个位置没有加大括号WA了好几发，但是我现在还是不知道这里为啥需要加大括号。。。 //这个括号到这我在HDU上WA了10+发 else { f[fr] = fl; d[fr] = d[l] + v - d[r]; } } printf(&quot;%d\\n&quot;,ans); } return 0;} POJ - 2492A Bug’s Life（种类并查集/拓展域并查集） 开两倍的f数组，x+n表示与x不相同的种类，（这种方法也叫作拆点）每一对虫子只需要保证性别不同即可，即x和y+n是联通的x+n和y也是联通的，但是x和y并不联通。如果在同一种类一侧出现了连接，即为产生了矛盾。 代码： 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 2010;int T, n, m, x, y;bool flag = true;int f[maxn &lt;&lt; 1];int find(int x) {return f[x] == x ? x : f[x] = find(f[x]);}inline bool check(int x, int y) { int px = find(x), py = find(y); return px == py;}inline void unino(int x, int y) { int px = find(x), py = find(y); f[py] = px;}int main() { cin &gt;&gt; T; for (int i=1;i&lt;=T;++i) { scanf(&quot;%d%d&quot;, &amp;n,&amp;m); flag = true; for (int i=1;i&lt;=n*2;++i) f[i] = i; for (int i=1;i&lt;=m;++i) { scanf(&quot;%d%d&quot;, &amp;x,&amp;y); if (!flag) continue; if (check(x, y) || check(x+n, y+n)) flag = false; else { unino(x, y+n); unino(x+n, y); } } if (!flag) printf(&quot;Scenario #%d:\\nSuspicious bugs found!\\n\\n&quot;, i); else printf(&quot;Scenario #%d:\\nNo suspicious bugs found!\\n\\n&quot;, i); } return 0;} POJ - 1988 Cube Stacking（带边权并查集） 这道题同样也是带边权的并查集，有点像银河英雄传说这道题。每一个节点需要维护的值有到底部的距离和该栈的元素个数。核心部分还是在合并时权值的处理。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int n = 50010;int m, x, y;int f[n], d[n], h[n];inline void init() { cin &gt;&gt; m; for (int i=1;i&lt;n;++i) { f[i] = i; h[i] = 1; d[i] = 0; }}int find(int x) { if (x != f[x]) { int t = f[x]; f[x] = find(f[x]); d[x] += d[t]; } return f[x];}int main() { init(); string od; for (int i=1;i&lt;=m;++i) { cin &gt;&gt; od; if (od[0] == 'C') { cin &gt;&gt; x; find(x); printf(&quot;%d\\n&quot;, d[x]); }else { cin &gt;&gt; x &gt;&gt; y; int px = find(x); int py = find(y); if (px != py) { f[px] = py; d[px] = h[py]; h[py] += h[px]; } } } return 0;} POJ - 1182食物链（拓展域并查集） 经典的拓展域并查集。 拓展域并查集：首先对与最简单的并查集来说，如果两个是同一类，那么就p[pa]=pb对吧，但是对于两个相互排斥类的怎么办呢，这就涉及到拓展与并查集了，首先想法就是建立两个并查集，但是怎么把两个并查集联系起来呢？拓展个体。 这里的拓展个体是什么意思呢，一个个体我们要拆成多个，比方说两个集合存在队立关系，那么对于一个个体a，我们假设存在一个个体a+n ，a和a+n这两个是处于对立关系的，所以当我们说a和b对立的时候，意思就是在说，a+n和b在同一并查集，b+n和a在同一并查集，当我们说，a和b是同类的时候，那么也就是说a和b属于一个并查集，且a+n和b+n属于一个并查集。 开三倍的数组，除了本身的域之外拓展的两个域表示域和本身的关系。分别表示天敌和捕食。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#define rep(i, a, n) for (ll i=a;i&lt;=n;++i)#define per(i, n, a) for (ll i=n;i&gt;=a;--i)#define IOS std::ios::sync_with_stdio(false)#define enter putchar('\\n')typedef long long ll;using namespace std;const int maxn = 50010;int n, k, f[maxn * 3];int d, x, y, ans;int getfa(int x) {return (f[x] == x) ? x : f[x] = getfa(f[x]);}inline void un(int x, int y) { int a = getfa(x); int b = getfa(y); if (a != b) f[b] = a;}void work(int d, int x, int y) { if (x &gt; n || y &gt; n) {ans++;return;} if (d == 1) { if (getfa(x + n) == getfa(y) || getfa(x + 2 * n) == getfa(y)) {ans++;return;} un(x, y); un(x + n, y + n); un(x + 2 * n, y + 2 * n); } if (d == 2) { if (getfa(x) == getfa(y) || getfa(x + 2 * n) == getfa(y)) {ans++;return;} un(x + n, y); un(y + 2 * n, x); un(y + n, x + 2 * n); }}int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;k); rep(i, 1, n*3) f[i] = i; rep(i, 1, k) { scanf(&quot;%d%d%d&quot;, &amp;d, &amp;x, &amp;y); work(d, x, y); } printf(&quot;%d\\n&quot;, ans); return 0;} DAY4（树状数组）POJ - 3468A Simple Problem with Integers（线段树/树状数组） 一个简单的区间修改和区间求和的板子题。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;typedef long long ll;const int maxn = 1e5 + 7;struct SegmentTree { ll l, r; ll dat, add; #define l(x) tree[x].l #define r(x) tree[x].r #define dat(x) tree[x].dat #define add(x) tree[x].add}tree[maxn &lt;&lt; 2];ll a[maxn &lt;&lt; 1];ll n, m;inline ll Read() { ll x=0,f=1;char ch=getchar(); while(ch&gt;'9'||ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();} return x*f;}inline void update(ll p) {dat(p) = dat(p&lt;&lt;1) + dat(p&lt;&lt;1|1);}void build(ll p, ll l, ll r) { l(p) = l; r(p) = r; if (l == r) {dat(p) = a[l]; return;} ll mid = (l + r) &gt;&gt; 1; build(p&lt;&lt;1, l, mid); build(p&lt;&lt;1|1, mid+1, r); update(p);}void spread(ll p) { if (add(p)) { add(p&lt;&lt;1) += add(p); add(p&lt;&lt;1|1) += add(p); dat(p&lt;&lt;1) += add(p) * (r(p&lt;&lt;1) - l(p&lt;&lt;1) + 1); dat(p&lt;&lt;1|1) += add(p) * (r(p&lt;&lt;1|1) - l(p&lt;&lt;1|1) + 1); add(p) = 0; }}void change(ll p, ll l, ll r, ll d) { if (l &lt;= l(p) &amp;&amp; r &gt;= r(p)) { dat(p) += d * (r(p) - l(p) + 1); add(p) += d; return; } spread(p); ll mid = (l(p) + r(p)) &gt;&gt; 1; if (l &lt;= mid) change(p&lt;&lt;1, l, r, d); if (r &gt; mid) change(p&lt;&lt;1|1, l, r, d); update(p);}ll ask(int p, int l, int r) { if (l &lt;= l(p) &amp;&amp; r &gt;= r(p)) return dat(p); spread(p); ll mid = (l(p) + r(p)) &gt;&gt; 1; ll res = 0; if (l &lt;= mid) res += ask(p&lt;&lt;1, l, r); if (r &gt; mid) res += ask(p&lt;&lt;1|1, l, r); return res;}inline void init() { n = Read(); m = Read(); for (register int i=1;i&lt;=n;++i) a[i] = Read(); build(1, 1, n);}inline void work() { ll l, r, d; char op; while(m--) { cin &gt;&gt; op; if (op == 'C') { l = Read(); r = Read(); d = Read(); change(1, l, r, d); } if (op == 'Q') { l = Read(); r = Read(); printf(&quot;%lld\\n&quot;, ask(1, l, r)); } }}int main() { init(); work(); return 0;} HDU - 1166敌兵布阵（树状数组） 单点修改区间求和的树状数组板子题。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;typedef long long ll;using namespace std;const int maxn = 50010;int T, n, l, r;int a[maxn], c[maxn];string od;inline int Read() { int x=0,f=1;char ch=getchar(); while(ch&gt;'9'||ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();} return x*f;}inline int ask(int x, int res = 0) {for (; x&gt;=1; x-=(x&amp;-x)) res += c[x];return res;}inline void update(int x, int v) {for (; x&lt;=n; x+=(x&amp;-x)) c[x] += v;}inline int query(int l, int r) {return ask(r) - ask(l - 1);}inline void init() { n = Read(); memset(c, 0, sizeof(c)); memset(a, 0, sizeof(a)); for (int i=1;i&lt;=n;++i) { a[i] = Read(); update(i, a[i]); }}int main() { T = Read(); for (int i=1;i&lt;=T;++i) { init(); printf(&quot;Case %d:\\n&quot;, i); while(cin &gt;&gt; od &amp;&amp; od != &quot;End&quot;) { l = Read(); r = Read(); if (od == &quot;Add&quot;) update(l, r); if (od == &quot;Sub&quot;) update(l, -r); if (od == &quot;Query&quot;) printf(&quot;%d\\n&quot;, query(l, r)); } } return 0;} HDU - 1394Minimum Inversion Number（逆序对/树状数组） 树状数组求逆序对数的改进版，需要在题中所给的序列生成的一系列序列中找到逆序对数最小的那一组。 关于求一个数列的逆序对数，可以用树状数组来维护一个数字前面比自己大的数的个数。树状数组可以方便的在线求前缀和，所以说可以用树状数组来完成这道题。 树状数组求逆序对参考博客 代码： 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#define int llusing namespace std;typedef long long ll;const int maxn = 5010;int n, a[maxn &lt;&lt; 2], f[maxn &lt;&lt; 2];int tmp, ans;inline int lowbit(int x) {return -x&amp;x;}void update(int x, int v) {for (; x&lt;=n; x+=lowbit(x))f[x] += v;}int ask(int x, int res = 0) {for (; x&gt;=1;x-=lowbit(x)) res += f[x];return res;}signed main() { while(scanf(&quot;%d&quot;, &amp;n) != EOF) { memset(a, 0, sizeof(a)); memset(f, 0, sizeof(f)); tmp = ans = 0; for (int i=1;i&lt;=n;++i) { scanf(&quot;%d&quot;, &amp;a[i]); a[i]++; update(a[i], 1); tmp += (i - ask(a[i])); }//该过程是求一个序列的逆序对的方法 ans = tmp; for (int i=1;i&lt;n;++i) { tmp += (n - 2 * a[i] + 1); ans = min(ans, tmp); }//这一段是解决如何求出每一个元素后移之后的序列逆序对数 printf(&quot;%d\\n&quot;, ans); } return 0;} HDU - 2795Billboard（线段树） 这道题的实现其实不太难，难点是如何建树。 由题可知，我们可以在广告牌的高度上建树，然后对于每一个新的广告，查找最靠下的可以满足当前广告牌的位置插入，实际上就是维护了一个区间的最大值，来进行判断当前广告是否可以放到该区间中。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;typedef long long ll;const ll maxn = 500010;ll n, h, w;ll a[maxn * 4];inline void update(ll p) {a[p] = max(a[p &lt;&lt; 1], a[p &lt;&lt; 1 | 1]);}void build(ll p, ll l, ll r) { if (l == r) { a[p] = w; return; } ll mid = (l + r) &gt;&gt; 1; build(p &lt;&lt; 1, l, mid); build(p &lt;&lt; 1 | 1, mid + 1, r); update(p);}ll ask(ll x, ll l, ll r, ll p) { if (l == r) { a[p] -= x; return l; } ll mid = (l + r) &gt;&gt; 1; ll res = 0; if (a[p&lt;&lt;1] &gt;= x) res = ask(x, l, mid, p&lt;&lt;1); else res = ask(x, mid + 1, r, p&lt;&lt;1|1); update(p); return res;}int main() { while(scanf(&quot;%d%d%d&quot;, &amp;h, &amp;w, &amp;n) != EOF) { memset(a, 0, sizeof(a)); h = min(h,n); build(1,1,h); ll x = 0; for (int i=1;i&lt;=n;++i) { scanf(&quot;%d&quot;, &amp;x); if (a[1] &lt; x) printf(&quot;-1\\n&quot;); else printf(&quot;%d\\n&quot;, ask(x, 1, h, 1)); } } return 0;} POJ - 2777Count Color（线段树+状态压缩） 用位运算来保存颜色的状态，加上懒惰标记，然后update维护父子节点的信息会不太一样。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#define int llusing namespace std;typedef long long ll;const int maxn = 500010;int n, t, m, l, r, c;int a[maxn &lt;&lt; 2], f[maxn &lt;&lt; 2];char od[5];void update(int p) {a[p] = a[p*2] | a[p*2+1];}void spread(int p) {a[p*2+1] = a[p*2] = f[p*2+1] = f[p*2] = f[p];f[p] = 0;} void change(int p, int l, int r, int x, int y, int c) { if (x &lt;= l &amp;&amp; r &lt;= y) { f[p] = a[p] = 1 &lt;&lt; c; return; } int mid = (l + r) &gt;&gt; 1; if (f[p]) spread(p); if (x &lt;= mid) change(p*2, l, mid, x, y, c); if (y &gt; mid) change(p*2+1, mid + 1, r, x, y, c); update(p); }int ask(int p, int l, int r, int x, int y) { if (x &lt;= l &amp;&amp; r &lt;= y) return a[p]; ll mid = (l + r) &gt;&gt; 1; if (f[p]) spread(p); ll res = 0; if (x &lt;= mid) res |= ask(p&lt;&lt;1, l, mid, x, y); if (y &gt; mid) res |= ask(p&lt;&lt;1|1, mid + 1, r, x, y); return res;}int cnt(int x) { int ans = 0; while(x) ans++, x -= -x&amp;x; return ans;}signed main() { scanf(&quot;%lld%lld%lld&quot;, &amp;n,&amp;t,&amp;m); change(1, 1, n, 1, n, 1); for (int i=1;i&lt;=m;++i) { scanf(&quot;%s%lld%lld&quot;, od, &amp;l, &amp;r); if (l &gt; r) l ^= r ^= l ^= l; if (od[0] == 'C') { scanf(&quot;%lld&quot;, &amp;c); change(1, 1, n, l, r, c); }else printf(&quot;%lld\\n&quot;, cnt(ask(1, 1, n, l, r))); } return 0;}","link":"/8528"},{"title":"河南大学暑假集训的日常（4）","text":"DAY7（DP进阶） POJ - 2342 Anniversary party（树形DP） 入门树形DP。 用vector将边存下来，然后将一个点作为树的根节点进行dp，d[x][0]表示编号为x的员工不参加的愉悦值，d[x][1]表示编号为x的员工参加的愉悦值。v节点表示x节点所连的边，转移方程为：d[x][1] += d[v][0]; d[x][0] += max(d[v][1], d[v][0]); 代码： 1234567891011121314151617181920