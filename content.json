{"pages":[{"title":"关于","text":"关于博主姓名: Dicemy / Tobin Meng 坐标: 中国，开封 状态: 本科在读 教育经历： 本科：河南大学 高中：JZYZ 主要经历： 大二下学期：第十三届蓝桥杯——C/C++程序设计（省赛）一等奖河南大学第十四届“挑战杯”大学生创业计划竞赛软件学院选拔赛 一等奖 负责人第25次CCF CSP软件能力认证：250分，排名位次前7.11% 大二上学期：2021年河南大学本科生开放性试验项目 负责人2021年国家级大学生创新创业训练计划 项目成员2021年全国大学生数学建模竞赛河南赛区省级二等奖2021第三届CCPC河南省赛银奖2021河南省数学建模大赛校级三等奖 大一学年：2021年河南大学三好学生2021年河南大学数学竞赛校级二等奖2020-2021第二届全国大学生算法设计与编程挑战赛（春季赛）铜奖2020=2021年度第三届传智杯全国大学生IT技能大赛程序设计赛道（A组）优秀奖2020年南阳理工学院新生程序设计邀请赛 银奖 高中：2018NOIP HA省省二 友链： 十六岁的我自己 国民仙女郭老师 牛汁 联系方式: QQ:1583925267 email：1583925267@qq.com","link":"/about/"}],"posts":[{"title":"2021ccpc省赛总结","text":"2021ccpc河南省省赛，算是大学第一场比较正规的acm比赛吧，最后过了4道题，有点危险的拿到了银。 打完比赛之后和高中机房的邱宇同学沟通了一下，发现自己的成绩并不算很好，给高中丢人了。。 一些感受吧： 高中竞赛的失败导致对acm抱有复杂的感情，爱并且怕着。 从初中开始接触算法竞赛，到现在已经有六七个年头了。这些年里写了好多的代码。一些题已经做了两遍三遍，忘记了，再做，有一些题，看到就想吐。为了拾起来之前的东西，去做哪些已经做了太多次的题，我已经无法从那些做过的题中找到学习新东西的乐趣了，这让我有一些恶心。 但是我还是爱着acm的。 解一道没做过的题之后的快乐，那是一种高级的喜悦。每一次体会这种快乐，都不会让我感到厌烦。 这可能也是为什么喜欢做新题的原因吧。 在这场比赛中，有两道题是由我完成的。这两道题，都是提交一遍然后AC，我觉得这个过程，还是十分的令人激动，并且快乐的。 总结一下这场比赛： 团队的问题： 签到有点慢，开始之后要看榜，这场比赛3分钟左右才开始看榜，这时候就已经比其他人慢了。 写题没有什么比较大的问题。 到最后两道题有点乱，没有分配好要写哪道题。 大家的DP都比较薄弱。 以后比赛还是上午留着睡觉吧，不然大家的状态都不好，都感觉晕乎乎的。。。 自己的问题： DP比较薄弱。 对自己的代码没有自信。","link":"/17211"},{"title":"2021牛客寒假算法基础集训营1","text":"2021牛客寒假算法基础集训营1的补题记录 I题 限制不互素对的排列链接：https://ac.nowcoder.com/acm/contest/9981/I来源：牛客网 题目描述输入一个数 n ，请构造一个长度为 n 的排列，使得其中正好有 k 对相邻的数gcd（最大公约数）大于 1 。 排列是指 1 到 n 一共 n 个数，每个数都出现过且仅出现过 1 次。例如，{1, 3, 2, 5, 4}是一个排列，而 {1, 3, 5, 4, 3}、 {1, 2, } 则不是排列 输入描述: 两个整数 n 和 k ，用空格隔开。2 &lt;= n &lt;= 100000, 0 &lt;= k &lt;= n / 2 输出描述: 如果不存在可行的构造方案，输出-1。 否则输出一行 n 数，用空格隔开。如果有多组可行的构造方案，输出任意一组即可。 示例1 输入 12 1 输出 1-1 说明 1长度为2的排列有2个：{1,2}和{2,1}，显然都不符合题意 示例2 输入 16 3 输出 15 3 6 2 4 1 说明 12共有3对相邻数不互素：{3,6}、{6,2}和{2,4}。这并不是唯一解，只要构造任意合法解即可。 思路:由题中给的一个很重要的信息可知，k&lt;=n/2的，而且我们可以轻易地知道对于所有的偶数，他们的最大公因数是2满足大于1的条件，并且n以内偶数的个数正好也是n/2个。所以可以比较轻易的凑够n/2-1对儿满足条件的数对儿。这就是k&lt;=n/2-1的方法。对于k = n/2的情况，我们只需将6放到n/2个偶数的最后一个即可，然后后面放一个3来保证出现第n/2对儿。 代码：123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt; using namespace std;int n, k;void work1() { for (int i=1;i&lt;=k+1;++i) cout &lt;&lt; i * 2 &lt;&lt; ' '; for (int i=k*2+3;i&lt;=n;++i) cout &lt;&lt; i &lt;&lt; ' '; for (int i=1;i&lt;=k+1;++i) cout &lt;&lt; 2 * i - 1 &lt;&lt; ' ';}void work2() { if (n &lt; 6) { cout &lt;&lt; -1; return; } for (int i=4;i&lt;=k;++i) cout &lt;&lt; i * 2 &lt;&lt; ' '; cout &lt;&lt; 2 &lt;&lt; ' ' &lt;&lt; 4 &lt;&lt; ' ' &lt;&lt; 6 &lt;&lt; ' ' &lt;&lt; 3 &lt;&lt; ' '; cout &lt;&lt; 1;// 问题出在这一句上，按照之前的写法，会出现9 4, 答案中 3 和 9 碰到一起的情况，这时候就不对了，所以我们用1来隔开。 for (int i=k*2+1;i&lt;=n;++i) cout &lt;&lt; i &lt;&lt; ' '; for (int i=3;i&lt;=k;++i) cout &lt;&lt; 2 * i - 1 &lt;&lt; ' '; // cout &lt;&lt; 1;// 问题出在这一句上}int main() { cin &gt;&gt; n &gt;&gt; k; if (k &lt;= n / 2 - 1) work1(); else work2(); return 0;}//有问题的代码，状态：已订正//一些奇妙的性质：相邻的两个数一定互质，相邻的两个奇数一定互质。 J.一群小青蛙呱蹦呱蹦呱链接：https://ac.nowcoder.com/acm/contest/9981/J来源：牛客网 题目描述：有n个格子，每个格子里有一个数，1,2,3,4…n 牛牛放出无穷只青蛙。第一只青蛙的路线是：1-&gt;2-&gt;4-&gt;8-&gt;16-&gt;…第二只青蛙的路线是：1-&gt;3-&gt;9-&gt;27-&gt;81-&gt;…第三只青蛙的路线是：1-&gt;5-&gt;25-&gt;125…第四只青蛙的路线是：1-&gt;7-&gt;49…。。。。。。用数学语言描述，第 只青蛙的路线是首项为1，公比为的等比数列，其中代表第个素数。当青蛙跳到一个格子上，如果这个格子上面有一个数，青蛙就会把这个数吃掉。牛牛想知道，所有没有被吃掉的数的lcm（最小公倍数 ，Least common multiple）是多少？由于这个lcm可能非常大，请输出它对 1 0 9 + 7 10^9+7109 +7 取模的值。 输入描述:一个正整数 输出描述:如果所有数都被吃掉了，请输出一个字符串”empty”否则输出所有没有被吃掉的数的lcm，对 1 0 9 + 7 10^9+710 9+7 取模 示例1: 输入 17 输出 16 说明 12345678数字 1 可以被所有青蛙吃掉；数字 2 可以被第 1 只青蛙吃掉；数字 3 可以被第 2 只青蛙吃掉；数字 4 可以被第 1 只青蛙吃掉；数字 5 可以被第 3 只青蛙吃掉；数字 6 无法被吃掉；数字 7 可以被第 4 只青蛙吃掉。所以剩下的数字只有一个 6 ，所有数的 lcm 为 6 示例2: 输入 1123456789 输出 1539747460 思路：性质一：由题可知按照顺序划掉的是每一个素数的几次方，所以很明显的是最后留下来的数一定是由两个以上的素数相乘得到的。 性质二：我们可以知道lcm是指两个数的最小公倍数，所以最后的答案一定是这些剩下的数字的质因数的某次方中最高那一个互相相乘的答案。 性质三：我们可以知道一个数进行质因数分解的结果应该是唯一的。 所以解法来了，先求出n / 2以内的质因数，然后对于2来说，找到log2(n/3)即为2的次方数。对于大于2小于n / 2的所有质数pi来说，logpi(n/2) 就是pi的次方数，然后将这些数都乘到一起就可以得到答案的lcm了。 知识点复习：线性筛素数： 1234567891011121314ll prime[maxn], size = 0;bool vis[maxn];void Prime() { memset(vis, true, sizeof(vis)); memset(prime, 0, sizeof(prime)); vis[1] = true; for (int i=2;i&lt;=n;++i) { if (vis[i]) prime[++size] = i; for (int j=1;j&lt;=size&amp;&amp;i*prime[j]&lt;=n;++j) { vis[i * prime[j]] = false; if (i % prime[j] == 0) break; } }} 快速幂： 12345678ll power(ll a, ll b) { ll res = 1 % mod; for (; b; b &gt;&gt;= 1) { if (b &amp; 1) res = ll(res * a % mod); a = ll(a * a % mod); } return res;} 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 8e7;const int mod = 1e9 + 7;ll n, ans = 1; ll prime[maxn / 10], size = 0;bool vis[maxn];void Prime() { memset(vis, true, sizeof(vis)); memset(prime, 0, sizeof(prime)); vis[1] = true; int t = maxn; for (int i=2;i&lt;=t;++i) { if (vis[i]) prime[++size] = i; for (int j=1;j&lt;=size&amp;&amp;i*prime[j]&lt;=t;++j) { vis[i * prime[j]] = false; if (i % prime[j] == 0) break; } }}ll power(ll a, ll b) { ll res = 1 % mod; for (; b; b &gt;&gt;= 1) { if (b &amp; 1) res = ll(res * a % mod); a = ll(a * a % mod); } return res;}int main() { Prime(); cin &gt;&gt; n; if (n &lt; 6) { cout &lt;&lt; &quot;empty&quot;; return 0; } ll tmp = n / 3, c = 0; while(tmp &gt;= 2) tmp /= 2, c++;//细节是当tmp小于prime数之后就不要除了，不然次数都会大个1. ans = (ans * power(2, c) % mod) % mod; for (int i=2;i&lt;=size;++i) { if(prime[i] &gt; n / 2) break;//这也是一个小优化 tmp = n / 2, c = 0; while(tmp &gt;= prime[i]) tmp /= prime[i], c++; ans = (ans * power(prime[i], c) % mod) % mod; } cout &lt;&lt; ans % mod; return 0;}","link":"/1957"},{"title":"2021牛客寒假算法基础集训营2","text":"2021牛客寒假算法基础集训营2的补题记录 F.牛牛与交换排序链接：https://ac.nowcoder.com/acm/contest/9982/F来源：牛客网 题目描述牛牛有一个数组，数组元素是 1 到 n 的排列，即数组的值在 1 ∼ n 范围内，且每个数字仅出现 1 次。牛牛想要将该数组变为升序排列的，他可以进行如下的操作。 首先他要确定一个长度 k ，k 的范围在 1 ∼ n 之间。接下来他将会进行若干次操作。在每轮操作中他都可以选择一段长度为k的子数组，然后进行区间的翻转操作。 他可以做任意次数的操作，但是要求他每次选择的子数组区间满足 li &lt;= li+1，并且区间长度等于一开始选定的 k ，也就是说一旦某一次操作选择了数组的某个位置进行区间翻转操作，下一次做区间翻转的位置将会比上一次更靠右。 牛牛发现，并不总是存在一个 k 可以使得数组排序变为有序，请你告诉牛牛是否存在一个 k 能够在满足规则的情况下完成排序。 输入描述:第一行输入一个正整数 n ( 1 ≤ n ≤ 10^5 ) 表示数组的大小。接下来输出一行 n 个正整数表示一个排列，即每个数的大小范围在 1 到 n 且每个正整数仅出现一次。 输出描述:如果存在至少一个 k 能够使牛牛完成排序，请先在一行中输出一个 “yes”，然后另起一行输出一个可以满足排序的k，要求k的范围在 [ 1 , n ] 之间，如果有多解，你可以输出任意一个。 反之如果不存在任何一个k可以完成排序，请直接在一行输出一个”no” 示例1 输入 123455 2 1 4 312 输出 1234yes312 示例2 输入 123451 2 3 4 512 输出 1234yes112 示例3 输入 123455 4 3 2 112 输出 12yes5 思路：首先，我们应该如何找到k。由于我们最后要得到的是一个排序好的数列，所以如果这个数列可以成功排序的话，对于1位置上的数来说一定是1，那么第一次交换一定得让1回到1这个位置上去，所以k的大小就是数字1的下标距离1的差值。如果，1就在1这个位置上的话，那么我们判断2，或者更大的数字来确定k的值。 之后我们如何判断这个k是否可以完成排序呢。我们只需要遵守题目中的规则然后去模拟就可以了。如果模拟到底发现可以排序成功那么就可以，反之则不行。 但是我们可以想到的是，单纯模拟的话时间复杂度起码是n^2以上的，所以我们有什么好一点的方法优化这个时间吗？答案当然是有的，我们可以通过反转标记和双端队列的方式来优化这个模拟的过程。 这个过程就是，维护一个长度为k的双端队列，表示如果下一次进行翻转，会受到影响的那些数字，然后从头开始进行模拟，如果i和队列头或者尾的数字相同，那么让他出队然后在反方向上将新的数字入队，维持这一操作直到全部数字出队或者出现无法复位的数字时停止即可。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt; using namespace std;const int N = 1e5 + 8;int n, k , flag = 0;int a[N], pos[N];deque&lt;int&gt; q;int main() { cin &gt;&gt; n; for (int i=1;i&lt;=n;++i) { cin &gt;&gt; a[i]; pos[a[i]] = i; } for (int i=1;i&lt;=n;++i) { if (pos[i] != i) { k = pos[i] - i + 1; break; } } if (!k) { cout &lt;&lt; &quot;yes\\n&quot; &lt;&lt; 1; return 0; } for (int i=1;i&lt;=k;++i) q.push_back(a[i]); for (int i=1+k;i&lt;=n+k;++i) { if (!(flag % 2)) { if (i - k == q.front()) q.pop_front(); else if(i - k == q.back()) flag ^= 1, q.pop_back(); else { cout &lt;&lt; &quot;no&quot;; return 0; } } else if (flag % 2){ if (i - k == q.back()) q.pop_back(); else if (i - k == q.front()) flag ^= 1, q.pop_front(); else { cout &lt;&lt; &quot;no&quot;; return 0; } } if (i &lt;= n) { if (flag % 2) q.push_front(a[i]); else q.push_back(a[i]); } } cout &lt;&lt; &quot;yes\\n&quot; &lt;&lt; k; return 0;} I: 牛牛的“质因数”链接：https://ac.nowcoder.com/acm/contest/9982/I来源：牛客网 题目描述算数基本定理，又称唯一分解定理，算术基本定理可表述为：任何一个大于1的自然数 N,如果N不为质数，那么N可以唯一分解成有限个质数的乘积。 朴素的质因子分解算法就是利用了算数基本定理，依次枚举p判断N是否包含素因子p。 牛牛最近对于质因数分解产生了浓厚的兴趣。 牛牛定义了一个函数F(x)，它表示将x做质因数分解后得到的数字从小到大升序排列，然后将其“拼接”成一个大整数。 例如1500=22355*5,F(1500)=223555。 牛牛现在想要知道∑(n, 2)F(i)的值。 由于这个结果非常大，所以你只用告诉牛牛最终答案对10^9 + 7取余数的结果即可。 输入描述:1仅一行一个正整数n(2 ≤ n ≤ 4×10^6) 输出描述:1仅一行，表示答案对10^9+7取余数的结果。 示例1 输入13 输出15 说明1 示例2 输入110 输出1342 说明12345678910F(2)=2F(3)=3F(4)=22F(5)=5F(6)=23F(7)=7F(8)=222F(9)=33F(10)=252+3+22+5+23+7+222+33+25=342 思路这道题的思路其实就是题中所说的进行模拟即可，素数筛法选择快一点的筛子，用线性筛O（n）的时间复杂度，然后维护一个 f[i] 数组即可。可以叫做：筛法DP。其中有一个细节需要注意的是写了两次都被卡到的一个点。对一个数进行数的长度处理的时候还进行了取模运算，这个时候之前的数字的长度其实是不准的。需要用一个数组将这些数据记录下来。 注意：并不是在模运算下不出现除法得到的结果就一定是正确的了，还要考虑一个数取模之后长度的变化问题。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt; using namespace std;typedef long long ll;const int maxn = 4e6 + 10;const int mod = 1e9 + 7;ll n, ans;ll prime[maxn], size = 0;ll f[maxn];ll P[maxn];bool vis[maxn]; ll F(ll x) { int c = 0; while(x) x /= 10, c++; return c;}ll power(ll a, ll b) { ll res = 1; for (; b; b &gt;&gt;= 1) { if (b &amp; 1) res = ll(res * a % mod); a = ll(a * a % mod); } return res;}void init() { memset(vis, true, sizeof(vis)); memset(prime, 0, sizeof(vis)); vis[1] = false; for (ll i=2;i&lt;=n;++i) { if (vis[i]) { prime[++size] = i; f[i] = i; P[i] = F(i); } for (ll j=1;j&lt;=size&amp;&amp;i*prime[j]&lt;=n;++j) { vis[i * prime[j]] = false; int p = P[i]; f[i * prime[j]] = ((prime[j] * power(10, p) % mod) % mod + f[i]) % mod; P[i * prime[j]] = F(prime[j]) + P[i]; if (i % prime[j] == 0) break; } }}int main() { cin &gt;&gt; n; init(); for (int i=2;i&lt;=n;++i) ans = (ans + f[i]) % mod; cout &lt;&lt; ans; return 0;}","link":"/1765"},{"title":"2021牛客寒假算法基础集训营3","text":"2021牛客寒假算法基础集训营3补题记录 J 加法和乘法链接：https://ac.nowcoder.com/acm/contest/9983/J来源：牛客网 题目描述有一天牛牛和牛妹在做游戏，规则如下： 桌面上摆着n张纸牌，每张纸牌上写着一个正整数，由牛牛先手轮流执行以下操作： 1.如果桌面上只剩一张纸牌，游戏结束，这张纸牌上的数字如果是奇数则牛牛胜利，反之牛妹胜利。 2.当前行动玩家选择两张纸牌，设上面的数字分别为X,Y，接下来玩家从加法和乘法中选择一个并应用到这两个数字上，得到结果为Z，接下来将选择的两张纸牌丢弃，并拿一张新的纸牌放到桌面上，在上面写上Z。 假设双方均以最优策略行动，最后谁会赢？ 输入描述:1234第一行一个正整数n，代表开始的纸牌数。第二行n个空格分隔的正整数ai代表开始纸牌上的数字。1≤n≤10^61≤ai≤10^9 输出描述:1如果牛牛能赢，输出NiuNiu，否则输出NiuMei。 示例1:输入 123233 2333 23333 输出 1NiuMei 示例2:输入 1241 1 1 1 输出 1NiuNiu 思路这道题只要在纸上进行演算一下即可，我们将两张牌的情况都列出来，可以发现，如果两张牌都是偶数的话，无论是加法还是乘法得到的都是偶数。剩下的两种情况下，加法和乘法可以一个得到偶数一个得到奇数。由此我们可以推出如果最后一次是牛妹进行操作的话，那么牛妹必胜，如果是牛牛的话，只要在最后一次不遇上两个偶数的情况就行。那么牛牛每一次的操作就是为了消除偶数，牛妹的操作就是为了造偶数。这就是两人的最优策略。 那么，游戏的过程就变成了牛牛消一个偶数，牛妹产生一个偶数，直到最后一次判断是否有两个偶数即可。 代码：1234567891011121314151617#include&lt;bits/stdc++.h&gt; using namespace std;long long n, a, cnt;int main() { cin &gt;&gt; n; for (int i=1;i&lt;=n;++i) { cin &gt;&gt; a; if (a % 2 == 0) cnt ++; } if (n == 1) cout &lt;&lt; (cnt == 0 ? &quot;NiuNiu&quot; : &quot;NiuMei&quot;); else { if (cnt &gt; 1 || n % 2 == 1) cout &lt;&lt; &quot;NiuMei&quot;; else cout &lt;&lt; &quot;NiuNiu&quot;; } return 0;}","link":"/50724"},{"title":"2021牛客寒假算法基础集训营5","text":"2021牛客寒假算法基础集训营5的补题记录 B 比武招亲（上）链接：https://ac.nowcoder.com/acm/contest/9985/B来源：牛客网 题目描述众所周知，天姐姐只喜欢天下最聪明的人，为了找到这样的人，她决定比武招亲！ 只见天姐姐在榜上留下了这样一道问题，谁做出来了就可以俘获她的芳心！ 爱慕天姐姐已久的泽鸽鸽问询赶来，只见榜上写着： 给定 n,m，定义一种序列，构造方法如下： 1.1. 在 [1,n] 中任意选择 m 次，得到了 m 个整数（显然数字可能相同）; 2.2. 将选出的 m 个数字排序之后得到一个序列 {a1,a2,…,am}。 定义一个序列的贡献为 max{a1,a2,…,am}−min{a1,a2,…,am}，求所有本质不同的序列的贡献和。 为了防止结果过大，将答案为 998244353 取模后输出。（对于两个序列长度为m的序列 A、B，若 ∃i∈[1,m]，Ai≠Bi，则序列 A、B 本质不同） 泽鸽鸽心有余而力不足，而你作为他最好的基友决定帮助泽鸽鸽俘获美人心！ 现在，这个重任就交给你啦！ 输入描述 一行输入两个正整数 n，m【数据规模与约定】1 &lt;= n, m &lt;= 5*10^5 输出描述 一行一个整数，为答案对 998244353 取模后的结果。 示例1输入 3 2 输出 4 说明 本质不同的序列有如下几种：1 1、2 2、3 3、1 2、1 3、2 3，贡献为 0+0+0+1+2+1=4。 看到的第一感觉是一个dp，思考f[n][m]怎样从f[n-1][m-1]或者f[n][m-1]，f[n-1][m]转移而来，但是没想出来，觉得像是和组合数的方法数统计有关。 前置知识复习：1.组合数递推。2.乘法逆元。 1.组合数可以通过用公式算得，所以只需递推出n的阶乘即可。 公式为：C（n,m） = n ! / (n - m) ! * m ! 2.乘法逆元的线性递推，这个看起来好像有一点点的复杂，在两三年前我曾经懂得这个的完全推法，但是现在的我已经伤仲永了…. 先记住线性递推逆元的写法，至于原理之后再研究….但是 ！ 由于这道题的性质， p 是一个质数并且阶乘的数字比较大所以用小费马定理可以比较方便的求出逆元的大小。 inv[i] = (mod-mod/i) * inv[mod % i] % mod; // 一行线性递推乘法逆元。小费马定理是： inv(x) = power(a, p-2, p); 现在可以开始写这道题了。 思路：根据问题，计算贡献和大致是dp或者排列组合计数来解。仔细一看发现和DP没啥关系，于是考虑组合计数。 首先根据题意，知道一个序列的最大值和最小值后这个序列的贡献就可以被唯一确定出来，即最大值减最小值。不妨设某个长度为m的序列最大值为mx，最小值为mn，那么这个序列排序后究竟长什么样呢？是mn, .., .., .., ……. .., mx。肯定有一个mx和一个mn是确定的，关键在于剩下m - 2个数有多少种选法。我们用选法数乘以(mx - mn)就能得到最大值为mx最小值为mn的所有序列的总贡献了。而易知剩下m - 2个数肯定都在[mn, mx]内，现在就转化为一个高中常见的排列组合问题：x个相同的小球放入y个盒子，允许有空盒，问一共有多少种放法。答案是C(x + y - 1, y - 1)。对于这个问题而言，相当于m - 2个数分配到[mn, mx]的区间内，允许有数不被覆盖，问有多少种分配方法。即C(m - 2 + mx - mn, mx - mn - 1)。 组合数取模有模版，根据卢卡斯定理，预处理出逆元来就可以计算。那么问题来了：最大值和最小值怎么确定。直接二重循环枚举肯定t得妈妈都不认识，但其实没有必要二重循环。注意到mn = 1, mx = 5和mn = 2, mx = 6的情况其实答案相同，因此我们直接枚举mx - mn（mx - mn其实也是贡献），再乘上这样的区间个数计算即可。 坑点：预处理逆元的时候要开2倍n的大小！这个要根据组合数计算的范围来开！ 这中间用到了组合数学的一些知识，那一个盒子放数的模型也要等到后面再研究了。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6 + 8;const int p = 998244353;ll n, m, ans = 0;ll f[maxn];ll power(ll a, ll b, ll p) { ll res = 1 % p; while(b) { if (b&amp;1) res = (ll) res * a % p ; a = (ll) a * a % p; b &gt;&gt;= 1; } return res;}inline ll inv(ll x) { return power(x, p-2, p);}void init() { cin &gt;&gt; n &gt;&gt; m; f[0] = f[1] = 1; for (int i=2;i&lt;=maxn;++i) f[i] = f[i - 1] * i % p; }inline ll C(ll n, ll m) { if (n == m|| m == 0) return 1; return (f[n] * inv(f[m]) % p * inv(f[n - m]) % p);}int main() { init(); for (int d=1;d&lt;=n-1;++d) { ll tmp = d * (n - d) % p; ans = (ans + tmp * C(d + m - 2, m - 2) % p) %p; } cout &lt;&lt; ans; return 0;} 这篇题解是从csdn上我的账号搬运过来的，新的博客搭好啦，开始搬运计划√","link":"/16246"},{"title":"2021牛客寒假算法基础集训营6","text":"2021牛客寒假算法基础集训营6的补题记录 A题 回文括号序列计数链接：https://ac.nowcoder.com/acm/contest/9986/A来源：牛客网 题目描述我们定义一个字符串S是回文的，表示S的左右反转和S相同。 我们定义一个字符串是括号序列： ​ \\1. 空串是括号序列。​ \\2. 两个括号序列P和Q的拼接是括号序列。​ \\3. 如果P是括号序列，’(‘+P+’)’是括号序列。 求长度为 n (0&lt;=n&lt;=10^9) 的回文括号序列的方案数，对 998244353 取膜。 输入描述: 第一行一个 T 表示数据组数。T&lt;=1000000。接下来 T 行，每行一个 n 。 输出描述: T 行。对于每组数据，你的答案。 示例1 输入 123201 输出 1210 思路啥都不说了，凉心出题人。题目十分的阴间。 看看这迷人的通过率，还浪费了我大把的卡常时间。 说实话我现在还是没有看懂题，啥叫“一个字符串S是回文的，表示S的左右反转和S相同。” PS：在题解文档出来之后，并且翻阅了好多其他人的题解之后我懂了这个“（）”为什么不是回文：它指的回文是”abba”但是很显然（与）是两个符号。所以并不是aa形而是ab形，所以“（）”并不是一个回文序列。同理根据题中所给的构造条件可知，长度大于0的串都不可能是回文串。 代码123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ int ncase; scanf(&quot;%d&quot;, &amp;ncase); while (ncase--) { int n; scanf(&quot;%d&quot;, &amp;n); if (n == 0) puts(&quot;1&quot;); else puts(&quot;0&quot;); } return 0;} 这短小精湛的代码告诉我们，写题之前先读题。 （出题人还让答案对一个数取模，看起来跟真的似的，给忽悠瘸了） J题 天空之城链接：https://ac.nowcoder.com/acm/contest/9986/J来源：牛客网 题目描述天空之城有5个小镇，名字分别为Ada, Aed, Akk, Orz, Apq，他们也有相互的路径长度。 希达早已期盼着天空之城，如今她登上了天空之城，就想走遍天空之城的每一个城市，但是她希望自己走的路的长度越小越好，以节省体力和节约时间。 巴鲁同意了，但由于他是主力（男孩子嘛），需要帮希达计算出走遍所有城市的最短路径长度。 由于天空之城具有魔力，如果希达想再走一次自己之前走过的路，则她可以在这条路上不花费任何时间。 但是天空之城的城市太多了，他实在计算不过来，只得请你来帮帮忙了。 输入描述: 第一行，输入n，q, 表示有n个城市，q条边； 第二行，输入一个名字tmp，表示希达想要从tmp城市开始行走； 接下来q行，每行输入两个名字a,b和一个数字val, 表示a城市与b城市之间的距离为val.(注意可能有重边和自环) 输出描述: 帮助巴鲁计算出最短的路径长度，如果无法走遍所有城市，输出“No!”。 示例1 输入 12345675 5OrzAda Aed 5Orz Ada 6Apq Aed 8Akk Apq 12Aed Orz 3 输出 128 说明 1Ada-&gt;Aed-&gt;Orz-&gt;Aed-&gt;Apq-&gt;Akk 备注: 多组输入输出（以EOF结束），保证数据组数不超过 10 。 1 &lt;= n &lt;= 5000, 1 &lt;= q &lt;= 200000, 1 &lt;= val &lt;= 1e9. 每个城市的名字长度不超过10。 保证 ∑q≤200000\\sum q \\le 200000∑q≤200000 。 图论题，由题可知我们要求一个图中的最小生成树。 复习一下Kruskal算法。 Kruskal算法的核心是贪心算法，我们根据边权进行从小到大排序，每次取出边权最小的那一个，然后将两点加入到生成树中，在添加的过程中需要注意的是，维护一个并查集，实时监测是否出现了环，如果出现了环那么这条边舍弃，结束的条件是当加入了n-1条边之后，最小生成树即建成。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt; using namespace std;typedef long long ll;const int maxn = 5005;const int maxm = 200005;ll n, q, ans, tot;struct edge { int from, to; ll v; bool operator &lt; (const edge &amp;b)const{ return v &lt; b.v; }}a[maxm];ll f[maxn];map&lt;string, ll&gt; mp;ll find(ll x){return x == f[x] ? x : f[x] = find(f[x]);}void Kruskal() { sort(a + 1, a + 1 + q); for (int i=1;i&lt;=q;++i) { ll x = find(a[i].from); ll y = find(a[i].to); if (x != y) { f[x] = y; ans += a[i].v; } } ll x = find(1); for (int i=2;i&lt;=n;++i) { if (find(i) != x) { cout &lt;&lt; &quot;No!&quot; &lt;&lt; endl; return;//这个细节错了一次，忘记输出完no后直接返回 } } cout &lt;&lt; ans &lt;&lt; endl; return;}int main() { while (cin &gt;&gt; n &gt;&gt; q) { string aaa, bbb; mp.clear(); tot = 0; ans = 0; for (int i=1;i&lt;=n;++i) f[i] = i; cin &gt;&gt; aaa; for (int i=1;i&lt;=q;++i) { cin &gt;&gt; aaa &gt;&gt; bbb; cin &gt;&gt; a[i].v; if (mp.count(aaa) == 0) mp[aaa] = ++tot; if (mp.count(bbb) == 0) mp[bbb] = ++tot; a[i].from = mp[aaa]; a[i].to = mp[bbb]; } Kruskal(); } return 0;} 来总结一下Kruskal的一些小细节，首先是并查集函数的背诵和f数组的初始化不要忘。 然后就是存贮边的结构体中要重载一下小于号的运算符，以w为排序的依据。 F题 组合数问题链接：https://ac.nowcoder.com/acm/contest/9986/F来源：牛客网 题目描述小 M 很喜欢组合数。 小 Z 给了她一个数 n （n为偶数），让她计算 (n0)+(n2)+(n4)..+(nn)\\binom{n}{0}+\\binom{n}{2}+\\binom{n}{4}..+\\binom{n}{n}(0n​)+(2n​)+(4n​)..+(nn​) ，小 M 一下子就秒掉了，觉得题好简单。 因此，小 Z 给了她一个难题：给定一个数 n （n 是4的倍数），计算 (n0)+(n4)+(n8)+…+(nn)\\binom{n}{0}+\\binom{n}{4}+\\binom{n}{8}+…+\\binom{n}{n}(0n​)+(4n​)+(8n​)+…+(nn​) ，答案对 998244353 取模。 小 M 不会做，请你来帮帮她吧！ 输入描述: 1输入一个数 n 。 输出描述: 1输出答案对 998244353 取模的值。 示例1 输入 112 输出 1992 备注: 对于所有的数据，1\\le n\\le 10^{18}1≤n≤10 18。 思路:怎么说，这道题只看懂了题解，实现可能还差点东西（虚数快速幂） 这是主办方的题解记录，最后的公式导出其实是用了高中组合数学中的一些公式推得的，所以这道题考验了高中的组合数学能力和虚数快速幂代码的能力。（然而百度了一下发现好像并没有虚数快速幂的相关资料）","link":"/50660"},{"title":"Hyperledger-Fabric试验快速搭建","text":"本文包括了Hyperledger Fabric文档阅读和Hyperledger Fabric平台搭建笔记 Hyperledger Fabric文档阅读介绍（自己总结的）区块链： 分布式网络，节点维护，不可篡改的账本，共识协议来验证交易，节点执行交易来维护账本的副本，账本以区块的方式存在，区块通过哈希和之前的区块相连。 区块链的应用：加密货币：比特币、以太坊：智能合约：为分布式应用创建平台。：公共非许可区块链技术，公共网络，匿名互动。 公共非许可区块链技术的缺点：性能较差，身份匿名。 企业级应用的需求：身份识别，性能强，低延迟，隐私性和机密性。 Hyperledger Fabric的自身定位：开源企业级许可分布式账本技术平台。高度*模块化**，可配置*的架构，支持**通用编程语言编写智能合约，平台是*许可的**，参与者确实*存在信任，**可插拔的共识协议，可以利用*不需要原生加密货币的共识协议**，性能较好*，**隐私和保密。 特性的一些解释：非许可区块链：匿名，信任通过工作量证明进行，采用挖矿来抵消工作量证明的成本。许可区块链:**使用共识协议来进行信任，不需要昂贵的挖掘。**智能合约：“链码”，受信任的分布式应用程序。从区块链中获得信任，在节点中达成共识。共识协议：验证，排序交易，传播到所有节点，各节点按顺序执行交易。一种新方法消除了非确定性，标准编程语言。隐私和保密性：公共非许可区块链网络中，基于Pow的拜占庭容错共识牺牲了合约和数据的保密性。加密数据：可能被破解，零知识证明：使用其他共识，将机密信息限制于授权节点中。可插拔共识：模块化的共识性能和可扩展性： 介绍什么是区块链？：一个分布式账本，记录网络上所有的交易。去中心化，协作维护。信息仅能以附加的方式记录到区块链上，并使用加密技术保证一旦将交易添加到账本就无法修改。简化了信息的溯源。区块链有时被描述为 证明系统 。 智能合约：为了支持以同样的方式更新信息，并实现一整套账本功能（交易，查询等），区块链使用 智能合约 来提供对账本的受控访问。智能合约不仅是在网络中封装和简化信息的关键机制，它还可以被编写成自动执行参与者的特定交易的合约。 共识：保持账本在整个网络中同步的过程称为 共识 。该过程确保账本仅在交易被相应参与者批准时更新，并且当账本更新时，它们以相同的顺序更新相同的交易。 区块链的不同：一套在网络上建立身份，执行交易和存储数据的标准方法。资产来源可以通过查看交易列表来确定，此列表一旦写入，无法更改，因此可信任。 Hyperledger Fabric 与其他区块链系统不同的地方是 私有 和 许可 。与允许未知身份参与网络的开放式非许可系统（需要诸如“工作量证明”之类的协议来验证交易并保护网络）不同，Hyperledger Fabric 网络的成员需要从可信赖的 成员服务提供者（MSP） 注册。 Hyperledger Fabric 还提供创建 通道 的功能，允许一组参与者创建各自的交易账本。对于某些网络而言，这是一个特别重要的选择。这些网络中，一些参与者可能是竞争对手，并且不希望他们做出的每笔交易都被每个参与者知晓，例如，他们只向某些参与者提供的特殊价格，而其他人不是。如果两个参与者组成一个通道，那么只有这两个参与者拥有该通道的账本副本，而其他参与者没有。 智能合约：Hyperledger Fabric 智能合约用 链码 编写，当该应用程序需要与账本交互时，由区块链外部的应用程序调用。在大多数情况下，链码只与账本的数据库、世界状态（例如，查询）交互，而不与交易日志交互。 Hyperledger Fabric 支持私有网络（使用通道）是很重要的，因为网络是相对开放的。 共识：交易必须按照发生的顺序写入账本，即使它们可能位于网络中不同的参与者集合之中。为此，必须建立交易的顺序，且必须采用一种方法来拒绝错误（或恶意）插入到账本中的非法交易。 这是一个彻底的计算机科学研究领域，且有很多方法可以实现它，每个方法都有不同的权衡。例如，PBFT（实用拜占庭容错算法）可以为文件副本提供一种机制，使其能够保持各个副本的一致性，即使在发生损坏的情况下也是如此。或者，在比特币中，通过称为挖矿的过程进行排序，其中竞争计算机竞相解决加密难题，该难题定义所有过程随后构建的顺序。 Hyperledger Fabric 被设计为允许网络启动者选择最能代表参与者间存在的关系的共识机制。与隐私一样，有一系列需求；从他们的关系高度结构化的网络，到更加点对点的网络。 参考资料： 项目文档[1] Hyperledger Fabric平台搭建笔记centos7.9系统的安装和基础配置 记得选择语言，汉语，这是在安装界面可以看到的。ps：选错语言的话酒删了重装吧。 记得选择磁盘位置 记得连接网络，很重要！！！ps：如果在有图形的安装界面不进行勾选的话 ，之后再更改配置会十分的困难。 记得勾选基本的安装包。ps：如果不勾选的话一些基本的yum或者tar指令都无法使用。但是也不要选择太多的包，不然有可能会和自己安装的服务产生冲突。 然后进行安装即可。ps：这样进行的安装是没有图形界面的。 如何更换字体和字号： 进入/lib/kbd/consolefonts，选择合适的字体。 输入setfont指令，后面跟上字体的名称。 输入echo 'setfont latarcyrheb-sun32' &gt;&gt; /etc/profile指令将字体设置设为开机启动。 wget的安装： 刚开始安装好的centos系统是没有wget的，需要用yum安装。 yum -y install wget Go语言安装 Go语言安装 从官网下载最新的linux-amd64.tar.gz压缩包（这里是go1.15.6.linux-amd64.tar.gz） 1wget https://golang.google.cn/dl/go1.15.6.linux-amd64.tar.gz 将其解压到/usr/local目录下： 1sudo tar -C /usr/local -zxf [压缩包名] 配置环境变量，在/etc/profile文件的末尾加入（在加入之前创建/home/gopath目录） 12export GOPATH=/home/gopathexport PATH=$PATH:/usr/local/go/bin 配置中国的代理 12go env -w GO111MODULE=ongo env -w GOPROXY=https://goproxy.cn,direct 查看是否配置成功 1go env mwget安装wget太慢使用mwget 12345678910wget http://jaist.dl.sourceforge.net/project/kmphpfm/mwget/0.1/mwget_0.1.0.orig.tar.bz2yum install bzip2 gcc-c++ openssl-devel intltool -ybzip2 -d mwget_0.1.0.orig.tar.bz2tar -xvf mwget_0.1.0.orig.tar cd mwget_0.1.0.orig./configure makemake install echo &quot;至此，安装完成&quot;% 断点续传wget -c 要下载的文件，实现断点续传。 最后的配置工作生成身份材料 进入BasicNetwork-2.0/artifacts/channel目录，执行 1./create-artifacts.sh 进入BasicNetwork-2.0/artifacts目录执行 1./docker-compose up -d 进入BasicNetwork-2.0 1./createChannel.sh 智能合约部署 进入BasicNetwork-2.0/artifacts/src/github.com/fabcar/go/目录下，执行（为智能合约安装依赖） 1GO111MODULE=on go mod vendor 进入BasicNetwork-2.0/，执行智能合约的部署和测试在执行deployChaincode.sh之前，按以下命令修改文件夹的权限 1sudo chmod 777 /home/gopath/* 开始部署 1./deployChaincode.sh 部署explorer 启动Explorer, 进入ContainerisingBlockchainExplorer目录下 1docker-compose up -d 服务全部启动成功，可以在windows上查看相关的服务。 注意：hyperledge Fabric搭建完成后将虚拟机挂起后再重新开启并不能恢复所有的服务，需要重新开启一遍。 平台使用查看可视化的区块链信息，访问： 1[ip地址]:8080 查看产的最新状态，访问： 1[ip地址]:5984/_utils 常用操作超级账本的下载地址： 1wget -c https://github.com/hyperledger/fabric/releases/download/v2.2.1/hyperledger-fabric-linux-amd64-2.2.1.tar.gz 超级账本的解压缩： 1sudo tar -C ./ -zxf hyperledger-fabric-linux-amd64-2.2.1.tar.gz 超级账本的bin目录内的东西放到/usr/local/bin下 1sudo mv ./bin/* /usr/local/bin 把BasicNetwork-2.0/artifacts/channel下的crypto-config拷贝到ContainerisingBlockExplorer下 1sudo mv BasicNetwork-2.0/artifacts/channel/crypto-config ContainerisingBlockchainExplorer 在ContainerisingBlockchainExplorer下创建data和walletstore文件夹 12sudo mkdir datasudo mkdir walletstore 查看Centos的ip（看en33那个ip） 1ip add 启动docker服务 1systemctl restart docker.service 关闭所有运行着的docker容器 1docker rm -f $(docker ps -a -q) tips: 1注意go的版本 参考资料： 实验平台在服务器上的基于脚本的自动化部署[1] 区块链实验平台部署[2]","link":"/29920"},{"title":"Python入门","text":"本文参考《python编程从入门到实践》，在Jupyter上完成各章节的学习和试验 下面是从Jupyter中导出的PDF文件 目录 《Python编程从入门到实践》(1~3章) 《Python编程从入门到实践》(4~5章) 《Python编程从入门到实践》(6~7章)","link":"/21062"},{"title":"Python入门学习","text":"Python文档阅读和Python语法点拾遗 Python文档阅读这是一个英语阅读生词总结笔记（大雾） Some prompts : (&gt;&gt;&gt;) (three greater-than signs) primary prompt (…) secondary prompt Operators : (//) to do floor division and get a integer result (discarding any flactional result) (\\)** to calculate power (_) if you use Python as a calculator you can type _ to get the last printed expression (ps. Don not assign the value to it) use round(a, b) to keep a in the b decimal place (j or J) use the J suffix to indicate the imaginary part String operators : quotes : 单引号 double quotes : 双引号 backslashes : 反斜线 (\\) use \\‘ to escape the single quote (\\n) \\n means newline String operation :If you don’t want character prefaced by \\ to be interpreted as special characters, you can use raw string by adding an r before the first quote. 12345&gt;&gt;&gt; print('C:\\some\\name')C:\\someame&gt;&gt;&gt; print(r'C:\\some\\name')C:\\some\\name using triple-quotes : ''' or &quot;&quot;&quot; so that the strings literals can span multiple lines. and use \\at the end of the line to avoid that end of lines are automatically included in the string.The following example: 12345print(&quot;&quot;&quot;\\Usage: thingy [OPTIONS] -h Display this usage message -H hostname Hostname to connect to&quot;&quot;&quot;) 123Usage: thingy [OPTIONS] -h Display this usage message -H hostname Hostname to connect to Strings can be concatenated (glued together) with the + operator and repeated with *.Two or more string literals next to each other are automatically concatenated. 1234&gt;&gt;&gt; text = ('Put several strings within parentheses '... 'to have them joined together.')&gt;&gt;&gt; text'Put several strings within parentheses to have them joined together.' This feature is only work with two literals, not with variables or expressions. The string indices alse can be negative number,to counting from the right.negetive indices start from -1 slicing slicing is used to obtain the substringThere follwing examples : 12345&gt;&gt;&gt; word = 'Python'&gt;&gt;&gt; word[0:2] # characters from position 0 (included) to 2 (excluded)'Py'&gt;&gt;&gt; word[2:5] # characters from position 2 (included) to 5 (excluded)'tho' The start is always included, and end always excluded.This make sure that s[:i] + s[i:] always equal to s. Note : an omitted first index defaults to zero. Python strings are immutable, so assigning to an indexed position in the string result in an error. List :Lists can contain different types, but usually the items all have the same type.List also can be indexed and sliced.(same as string) 123456&gt;&gt;&gt; squares[0] # indexing returns the item1&gt;&gt;&gt; squares[-1]25&gt;&gt;&gt; squares[-3:] # slicing returns a new list[9, 16, 25] List also support operations like concatenation. 12&gt;&gt;&gt; squares + [36, 49, 64, 81, 100][1, 4, 9, 16, 25, 36, 49, 64, 81, 100] Unlike string, list is a mutable type, it is possible to change their content.You can also add new items at the end of the list, by using the append() method (we will see more about methods later): 1234&gt;&gt;&gt; cubes.append(216) # add the cube of 6&gt;&gt;&gt; cubes.append(7 ** 3) # and the cube of 7&gt;&gt;&gt; cubes[1, 8, 27, 64, 125, 216, 343] Assignment to slices is also possible, and this can even change the size of the list or clear it entirely: 123456789101112131415&gt;&gt;&gt; letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']&gt;&gt;&gt; letters['a', 'b', 'c', 'd', 'e', 'f', 'g']&gt;&gt;&gt; # replace some values&gt;&gt;&gt; letters[2:5] = ['C', 'D', 'E']&gt;&gt;&gt; letters['a', 'b', 'C', 'D', 'E', 'f', 'g']&gt;&gt;&gt; # now remove them&gt;&gt;&gt; letters[2:5] = []&gt;&gt;&gt; letters['a', 'b', 'f', 'g']&gt;&gt;&gt; # clear the list by replacing all the elements with an empty list&gt;&gt;&gt; letters[:] = []&gt;&gt;&gt; letters[] build-in function len() also applies to lists.nest list is also allowed. Contains in whileThe condition may also be a string or list value, in fact any sequence; anything with a non-zero length is true, empty sequences are false. Indentation is Python’s way of grouping statements. The keyword argument end can be used to avoid the newline after the output, or end the output with a different string: 123456&gt;&gt;&gt; a, b = 0, 1&gt;&gt;&gt; while a &lt; 1000:... print(a, end=',')... a, b = b, a+b...0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987, More Control Flow Toolsif StatementsThe else part is optional.The keyword ‘elif’ is short for ‘else if’,and is useful to avoid excessive indentation.An if … elif … elif … sequence is a substitute for the switch or case statements found in other languages. for StatementsPython’s for statement iterates over the items of any sequence (a list or a string), in the order that they appear in the sequence. For example (no pun intended): 12345678&gt;&gt;&gt; # Measure some strings:... words = ['cat', 'window', 'defenestrate']&gt;&gt;&gt; for w in words:... print(w, len(w))...cat 3window 6defenestrate 12 The range() Functionthe built-in function range() can make the sequence of numbers.These following example: 12345678&gt;&gt;&gt; for i in range(5):... print(i)...01234 It is possible to let the range start at another number, or to specify a different increment: 12345678range(5, 10) 5, 6, 7, 8, 9range(0, 10, 3) 0, 3, 6, 9range(-10, -100, -30) -10, -40, -70 A strange thing happens if you just print a range: 12&gt;&gt;&gt; print(range(10))range(0, 10) Here is the solution: 12&gt;&gt;&gt; list(range(4))[0, 1, 2, 3] break and continue statements and else Clauses on Loops:break and continue are like in C++. 1234567891011121314151617&gt;&gt;&gt; for n in range(2, 10):... for x in range(2, n):... if n % x == 0:... print(n, 'equals', x, '*', n//x)... break... else:... # loop fell through without finding a factor... print(n, 'is a prime number')...2 is a prime number3 is a prime number4 equals 2 * 25 is a prime number6 equals 2 * 37 is a prime number8 equals 2 * 49 equals 3 * 3 In this code, the else is belongs to the for loop, not the if statement.The loop’s else clause runs when no break occurs. pass Statement :It can be used when a statement is required syntactically but the program requires no action.pass can be used is as a place-holder for a function or conditional body when you are working on new code Defining Functions :Other names can also point to that same function object and can also be used to access the function: 12345&gt;&gt;&gt; fib&lt;function fib at 10042ed0&gt;&gt;&gt;&gt; f = fib&gt;&gt;&gt; f(100)0 1 1 2 3 5 8 13 21 34 55 89 The example for the defining function: 1234567891011def ask_ok(prompt, retries=4, reminder='Please try again!'): while True: ok = input(prompt) if ok in ('y', 'ye', 'yes'): return True if ok in ('n', 'no', 'nop', 'nope'): return False retries = retries - 1 if retries &lt; 0: raise ValueError('invalid user response') print(reminder) This function can be called in several ways:giving only the mandatory argument: ask_ok(‘Do you really want to quit?’)giving one of the optional arguments: ask_ok(‘OK to overwrite the file?’, 2)or even giving all arguments: ask_ok(‘OK to overwrite the file?’, 2, ‘Come on, only yes or no!’) Python语法点拾遗1234567import表示引入某一个模块。import [... ] as (...) 表示引入一个 [...] 模块并且重命名为 (...)。from [...] import (...) 表示从[...]模块中引入(...)函数。from [...] import (...) as {...}表示从[...]模块中引入(...)函数并且重命名为 {...}。","link":"/55956"},{"title":"Spring Boot入门","text":"一、String Boot入门1、Spring Boot简介 简化spring应用开发的一个框架；整个Spring技术栈的一个大整合；J2EE开发的一站式解决方案； 2、微服务2014，martin fowler微服务：架构风格（服务微化）一个应用应该是一组小型服务；可以通过HTTP的方式进行互通； 每一个功能元素最终都是一个可独立替换和独立升级的软件单元； 环境约束-jdk1.8-maven3.3.9-IDEA-Spring Boot 1.5.9","link":"/12868"},{"title":"git入门","text":"（坑）待填","link":"/10811"},{"title":"刷题柱","text":"一个小小的刷题柱记录刷过的题 kuangbin刷题柱Dungeon Master（5.23）bfs，细节在于搜索到点之后入队时就进行标记已经搜索到了。不然会反复入队导致超时。 Find The Multiple（5.25）一个技巧，在dfs中如果不想让递归回到上一层之后继续执行的话，不要把dfs的返回类型设为void，而是设为bool，让多层的dfs返回到上一层就遇到一个if，就保证找到答案之后就会返回，不会寻找到多个值。常常用于有spj的搜索题。 Prime Path（8.1）水题，素数筛 + bfs。 Shuffle’m Up（8.2）水题，字符串模拟。注意：字符串为空的时候不要进行下标赋值，会出现问题，用s.push_back向空字符串中放置字符，否则会出现下标可以访问字符但是整体字符串为空的情况发生。 Pots（8.2）BFS，寻找最小变换次数即最小步数。比较特殊的是这个需要保存操作的步骤，可以用一个三维vector来保存每一次操作的动作编号，然后在到达状态之后依次输出即可。 Fire Game（8.3）离谱的是FZU挂掉了，没办法评测，样例都过了， 复习了一下如何求联通块的个数和双起点BFS。经验：下次做题前看一下uoj在那个网站提交的标志是不是红色。。。 分类刷题柱队列蚯蚓（5.4）https://ac.nowcoder.com/acm/problem/16430 这道题的解法是维护三个单调队列，由题可知蚯蚓切完的性质仍然满足蚯蚓的长度是依次递减的，由于是按照比例切的，那么切的是相同比例的蚯蚓放到一个队列中，由于靠前切的蚯蚓一定切出来的也是比之后切出来的蚯蚓长，所以当前的最长的蚯蚓只需从这三个队列中找到队头即可。 Cow Line（5.5）https://ac.nowcoder.com/acm/problem/24876 这道题就是一个简单的双端队列的模拟，题中数据的范围是模拟可以接受的，看出来题考的数据结构是双端队列就行了，维护两边的进队和出队即可。 Team Queuehttps://ac.nowcoder.com/acm/problem/50966 又是一道模拟题，团队队列只需用团队编号作为大队伍的标志，然后再委会每一个团队队列的内部次序即可。用一个queue和一个queue数组和一个map即可，细节还行，难度适中。出现的问题是数组越界了。最后发现标志该团队是否入大队列的bool数组并不是必要的。可以用检查该团队队列是否为空来代替。 长跑（5.6）https://ac.nowcoder.com/acm/problem/14570 是道队列bfs，从起点开始搜索，如果当前节点加上maxn可以到达并且钱够的商店就入队，然后如果碰到终点就退出。就是一道朴素的bfs，但是如果看不出来的还是有点迷惑的。 道路铺设（5.8）https://ac.nowcoder.com/acm/problem/21222 再次做到NOIP2018提高组的题，感慨万千。隐约记得在考场上发现是前两天做过的原题的兴奋的心情了。当时的我先发现是差分，处理出差分数组之后经过观察是差分数组为正值的所有值的和即为答案，当时并没有经过严谨的证明，隐约感觉正值和负值之间一定会相互抵消。今天重新写到，当时的感觉重新涌上心头。 其实就是一道水题，并不是优先队列，差分之后将正值加到一块即可。可以进行一个简单的证明，一个数列的差分数组的所有元素的和一定为0，那么想要将这个差分数组的正数变为0，那么每一个正数都要和负数相对应结合。其中一个问题是如果确定进行变化的一对差分中间没有0，其实这也好证明，因为每一个正数会找到最近的一个负数进行中和，那么可以保证在对更远的负数进行中和的时候，比较最近的负数已经进行了中和，级这个比较大的数通过和附近的数进行中和，已经和周围的数的大小基本相同，所以不会出现跨过一个比较小的数然后进行更行的情况发生。第二个问题是，会不会出现前面的正数不能将一个比较大的负数使用完就直接跳到后面的正数了，显然也是不会的，因为这个数列是一个正整数列。 栈好串（5.7）https://ac.nowcoder.com/acm/problem/21874 一个栈的水题。 吐泡泡https://ac.nowcoder.com/acm/problem/15029 一个栈的应用，水题。 表达式计算4（5.8）https://ac.nowcoder.com/acm/problem/50999 栈的经典应用，表达式求值。这是一个中缀表达式求值。维护两个栈，一个栈存数字，一个栈存符号，数字进栈没有什么要求，如果有一个符号要进栈的话，先把比该符号优先级高的在符号栈中的符号都先弹出栈，符号两边的数字进行运算。这样就保证了每一个运算都是优先级高的先运算。模拟的过程会比较繁琐，而且注意栈如果为空的话调用栈的.top()会报错，所以把原来的表达式的最外层加一对括号来保护。 括号画家https://ac.nowcoder.com/acm/problem/50998 括号匹配，寻找最长合法括号匹配串。由于如果出现不合法的情况，那么之前的合法的长度就不能加到后面的括号序列上了。所以只需维护一个括号匹配栈即可，如果出现了不合法的情况就将最长串和目前的最长串进行一个更新即可，最后答案中的长度就是最长的合法括号字串的长度。 并查集奶酪（5.8）https://ac.nowcoder.com/acm/problem/16417 经典并查集例题，怎么写都能过的无极数据友好的题，只用将两两洞进行测距然后看距离满足，如果满足就直接将两个洞用并查集连在一起。然后看离地下比较近的洞和离上面比较近的洞是否联通即可。这道题应该也可以用其他测联通的方法写出来。 关押罪犯https://ac.nowcoder.com/acm/problem/16591 并查集的经典应用，一个非常好的思路是：我们将并查集的f数组进行拓展一下来表示更多的状态，来简化一些比较困难的逻辑表示。我们将f数组拓展一倍，i表示一个监狱i+n表示另一个监狱。我们对于每一对罪犯，都默认将他们装到不同的两个监狱中即a和b+n，a+n和b，然后检查他们在相同的监狱中是否出现冲突。这个做法其实是将一个状态拆成了比较好表示的两个状态。将逻辑上很复杂才能检测的问题变成一些很简单能判断的问题。这种方法叫做建立虚点。 虚点的建立可以拓展表示一个点的多个状态。 食物链（5.9）https://ac.nowcoder.com/acm/problem/16884 这题本质上应该是然用带权的并查集来写，但是有一种比较好写的方法是开虚点。用三倍的n的数组来表示每一个点的三个不同性质，对不同性质之间进行操作，这样就减小了处理复杂问题的难度。 棋盘问题（5.15）http://poj.org/problem?id=1321 一道经典的搜索题，用dfs进行搜索，一个控制层数，一个控制放了几个棋子。注意dfs中需要将每一层的情况都列出来。 刷题打卡墙5.8： 5道。挺麻的，又开始觉得自己是个fw了 5.15：1道题，被张宇说的网络流刺激到了，又滚来刷题了。 5.23：1道题，kuangbin的题单质量就是高，把之前的一道题改对了，还是浮躁，张文军教练的话，很有道理。 5.24：1道题，今天晚上有cf的#722的div2的比赛。但是进晚了怕掉分没打，写了一下t1，水体一道。 5.25：1道题，kuangbin的搜索专题。","link":"/58203"},{"title":"博弈论入门","text":"几种经典博弈的总结 巴什博弈：经典的巴什博奕模型： 只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个，最后取光者得胜。 解决思路：当n=m+1时，由于一次最多只能取m个，所以无论先取者拿走多少个，后取者都能够一次拿走剩余的物品，后者取胜，所以当一方面对的局势是n%(m+1)=0时，其面临的是必败的局势。所以当n=（m+1)r+s，（r为任意自然数，s≤m)时,如果先取者要拿走s个物品，如果后取者拿走x（≤m)个，那么先取者再拿走m+1-x个，结果剩下（m+1）（r-1）个，以后保持这样的取法，那么先取者肯定获胜。总之，要保持给对手留下（m+1）的倍数，就能最后获胜。结论：当n%(m+1)=0时，在最优策略下，后手必胜。 变形最后取光的人输…结论：当n%(m+1)=1 时，在最优策略下，后手必胜。 为什么？因为赢得人肯定会先取完(n - 1)个石子。 巴什博奕的简单变形： 只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取a，最多取b个，最后取光者得胜。 威佐夫博弈： 两堆各若干个物品，两个人轮流从任意一堆中取出至少一个或者同时从两堆中取出同样多的物品，规定每次至少取一个，至多不限，最后取光者胜利。 参考博客 12345678inline bool check(int x, int y) { int a = min(x, y), b = max(x, y); double c = (double)abs(b - a); double r = (sqrt(5.0) + 1) / 2; int tmp = int(c * r); if (a == tmp) return 0; //后手必胜 else return 1; //先手必胜 } 尼姆博奕 有N堆石子。A B两个人轮流拿，A先拿。每次只能从一堆中取若干个，可将一堆全取走，但不可不取，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N及每堆石子的数量，问最后谁能赢得比赛。 参考博客 斐波那契博弈 有一堆个数为n的石子，游戏双方轮流取石子，满足： （1）先手不能在第一次把所有的石子取完； （2）之后每次可以取的石子数介于1到对手刚取的石子数的2倍之间（包含1和对手刚取的石子数的2倍）。 约定取走最后一个石子的人为赢家。 结论：当n为Fibonacci数时，先手必败。即存在先手的必败态当且仅当石头个数为Fibonacci数。 公平组合博弈（ICG）每次只能走到必胜点的是必败点，可以走到必败点的是必胜点。","link":"/39273"},{"title":"大学物理复习笔记","text":"大一下学期准备大物考试的小小总结 第16章第1-3节：q = ne 电荷是量子化的 e = 1.62×10 ^ -19 C密立根油滴实验：电荷的量子性。mC uC nC pC10^-3 10^-6 10^-9 10^-12质子的质量：1.6×10^-27电子的质量：9×10^-31 极化：电中性的物体中，正负电荷的中心不重合的现象。 库伦定律： K的值：9×10^9 N·㎡/C^2 同号相斥，异号相吸 场是一种物质，无静止质量 第4节：电场强度：单位： N/C or V/m 是电场中某一点的一个性质 q是场源电荷 两条电场线不会相交，电场线不闭合 电偶极子：电偶极矩：p ⃑ = ql ⃑ 方向从负电荷指向正电荷 薄金属球壳中电场线的分布 第5节：“无限大”带电平面所激发的电场 σ:平面上的电荷面密度。“无限大”带电平面所激发的电场强度与离平面的距离无关，即在平面两侧形成一均匀场. 带有等量异号的平行金属板所产生的电场 σ:平面上的电荷面密度 第6节：导体处于静电平衡时，内部电场为0。静电荷分布在导体表面，尖端电荷密度最高。导体内部没有电场线，电场线垂直与导体表面尖端放电现象。 当腔内无导体时：空腔导体不接地的时候外面的电场不会影响腔内当腔内有导体时：空腔导体接地时外面的电场不会影响腔内 在空腔中的导体位置进行移动的话，对腔内和腔外的电场分布没有影响。 第7节：电通量：通过电场中某一给定平面的电场线的总条数叫做通过该面的电通量（垂直穿过或者斜着穿过对电通量的大小相同）电通量计算公式： 简单来说，就是某块平面的电场强度乘以这块平面的面积。几何意义：通过闭合曲面的电场线的净条数。 高斯定理： 静电场的高斯定理(Gauss’s law) 的表述:在静电场内,任一闭合面的电通量等于这闭合面所包围的电量的代数和(净电荷)除以ε0 .该定理将一任意闭合曲面上的电场和闭合曲面内所包围的净电荷联系起来。静电场是有源场。高斯定理求出来的是电通量，电通量乘以面积得到的是电场强度。 高斯定理在求解场强方面的应用： 均匀带电球面的电场分布，设球面半径为R，球面上所带总电量为q。 电荷均匀分布在一条长直细线上。线上单位长度所带电荷恒定为λ。求距离细线r处电场的大小，假设此处与线的两端相距很远。 求无限大均匀带电平面的电场分布。已知带电平面电荷面密度为σ。 第17章第1节：保守力：力所做的功和始末位置有关，和路径无关。静电场环路定理：静电场强沿任意闭合路径的线积分为零。反映了静电场是保守力场（无旋场）。 凡保守力都有与其相关的势能，静电场是有势场。 势能与做功的关系 电势能只与物体的位置有关，与路径无关。 电场力推出的电势能的公式。 第2节： 当取试验电荷为单位正电荷时，V_a和U_a等值，这表示静电场中某点的电势在数值上等于单位正电荷放在该点处时的电势能，也等于单位正电荷从该点经过任意路径到电势零点时电场力所做的功。 求均匀带电球面的电势分布。设球面半径为R，带电量为Q： 电势分布： 一个带电的导体球外的电场和其上所带电荷都集中在球心时形成的点电荷产生的电场相同。 点电荷的电势： 点电荷的电势能： 注意：电场是矢量，电势是标量电场为零的地方电势可以不为零；电势为零的地方电场也可以不是零。 第3-4节：等势面：将电势相等的场点连成连续的曲面——等势面相邻等势面的电势差为常量，可以得到一系列的等势面 电荷沿等势面移动，电场力不做功。 电势能只与物体的位置有关，与路径无关。 静电平衡下的导体内部和导体表面处处电势相等，整个导体是个等势体，导体表面成为等势面。 第5节：电容器：一种储存电能的原件，由电介质隔开的两块任意形状导体组合而成。两导体称为电容器的极板。 定义式：单位：F(法拉) C 是描述电容器储电本领的物理量 C 取决于电容器两板的形状、大小、相对位置及中间电介质的种类和分布情况； 物理意义：导体每升高单位电势所需的电量。 组成：用真空或绝缘体分开的两个导体。 平行板电容器的推导式。 球形电容器的推导式。 圆柱形电容器的推导式。当极板间距d&lt;&lt; RA时，圆柱形电容器类似于平行板电容器。 电容的串并联： 并联： 串联： 第6节：相对介电常数：相对介电常数是一个量纲为一的数，即有介质时的电容和没有介质时的电容比值。 电介质的介电常数与真空介电常数的比值。电容器存储的电势能 能量密度：单位体积的电势能该能量密度的表达式对任意电场都普遍成立。只要有电场的地方就有能量。 第18章：第1-3节：电流：单位时间通过垂直于电流方向的某一面积的净电量。载流子：自由电子、离子、空穴（正的载流子叫作空穴） 电池的电动势： 普通电池尺寸不同，电池越大，它储存的化学物质的量就越多，相应储存的化学能就越多，但它们都提供相同的电动势（1.5V）大小电池的另外一个区别就是大电池通常能更快的抽运电荷，也就是说大电池能提供更大的电流。 电流可表示为：单位体积内传导电子的数量：n，在体积A vD Δt内的电子数为N = nA vD Δt，电量为： ΔQ=Ne= neA vD Δt， 第4节：欧姆定律： 电阻定义： 单位：欧姆（Ω）1 Ω=1V/A电阻率： 电阻率和温度的关系： 路端电压（V）： 第5节:基尔霍夫节点电流定律：流入一个节点的所有支路的电流之和等于流出这个节点的所有支路的电流之和。任何一个电的连接点即为节点。 基尔霍夫回路电压定律:适用于电路中起始和终止于同一点的任何回路。电势改变的代数和为零。 第6节：串联与并联电路：串联电阻器: 串联电容器: 并联电阻器: 并联电容器： 第8-11节：电路中的功率与能量：功率的单位：J/s=A·V=W 在电阻上的能量可表示为: 电流表和电压表 RC电路：同时包含电阻器和电容器的电路。 第19章：第1-2节：磁感应强度B：单位 (SI)： T(特斯拉) 第3节：垂直于匀强磁场运动的带电粒子：粒子做匀速圆周运动 速度选择器: 质谱仪： 回旋加速器： 第4-5节：粒子作螺旋线向前运动，轨迹是螺旋线： 霍耳效应： 第6节： 注意对无线长载流直导线的B的求法。其中μ0 = 4π 第7节： 第8节： 第9节：一、恒定磁场的高斯定理： 二、安培环路定理：","link":"/4612"},{"title":"微信小程序开发入门","text":"刚开始，先进行一个demo的学习。原文链接：https://blog.csdn.net/lu_embedded/article/details/86181251 项目目录结构微信小程序的基本文件构造和项目目录结构说明如下： . ├── app.js # 小程序的逻辑文件 ├── app.json # 小程序的配置文件 ├── app.wxss # 全局公共样式文件 ├── pages # 存放小程序的各个页面 │ ├── index # index页面 │ │ ├── index.js # 页面逻辑 │ │ ├── index.wxml # 页面结构 │ │ └── index.wxss # 页面样式表 │ └── logs # logs页面 │ ├── logs.js # 页面逻辑 │ ├── logs.json # 页面配置 │ ├── logs.wxml # 页面结构 │ └── logs.wxss # 页面样式表 ├── project.config.json └── utils └── util.js 页头页尾pages 属性用来设置页面路径，它是一个数组，每一项都是字符串来指定小程序由哪些页面组成。数组的第一项代表小程序的初始页面。小程序中新增或减少页面，都需要对 pages 数组进行修改。 window 属性用于设置小程序的状态栏、导航条、标题、窗口背景色。 我们把页头的标题和颜色修改一下，页尾部分我们做一个 tab 栏来切换页面，这个属性叫做 tabBar，代码如下： 1234567891011121314151617181920212223242526272829303132{ &quot;pages&quot;:[ &quot;pages/index/index&quot;, &quot;pages/logs/logs&quot; ], &quot;window&quot;:{ &quot;backgroundTextStyle&quot;:&quot;light&quot;, &quot;navigationBarBackgroundColor&quot;: &quot;#2f2f8f&quot;, &quot;navigationBarTitleText&quot;: &quot;GoZeroWaste&quot;, # 标题 &quot;navigationBarTextStyle&quot;:&quot;white&quot; }, &quot;tabBar&quot;:{ &quot;color&quot;: &quot;#bfc1ab&quot;, &quot;selectedColor&quot;: &quot;#13b11c&quot;, &quot;backgroundColor&quot;: &quot;#1f1f4f&quot;, &quot;list&quot;: [ # 导航栏的两个按钮 { &quot;pagePath&quot;: &quot;pages/index/index&quot;, &quot;iconPath&quot;: &quot;image/icon_component.png&quot;, # 第一个按钮的图标 &quot;selectedIconPath&quot;: &quot;image/icon_component_HL.png&quot;, # 选择第二个按钮后第一个的按钮的图标 &quot;text&quot;: &quot;个人中心&quot; # 按钮的名字 }, { &quot;pagePath&quot;: &quot;pages/details/details&quot;, &quot;iconPath&quot;: &quot;image/icon_API.png&quot;, # 第二个按钮的图标 &quot;selectedIconPath&quot;: &quot;image/icon_API_HL.png&quot;, # 选择第一个按钮后第二个的按钮的图标 &quot;text&quot;: &quot;生活指南&quot; # 按钮的名字 } ] }} （所用到的图片放在项目的 image 目录，你也可以使用自己的图片） 这里用到几个 tabBar 的属性是 color、selectedColor、backgroundColor 和 list，list 是一个数组，主要用于设定导航的路径。 因为导航栏中一个按钮关联的是另一个页面，但是这个页面还没有存在，所以我们需要在app.json文件的list中直接添加，修改app.json文件： 1234567{ &quot;pages&quot;:[ &quot;pages/index/index&quot;, &quot;pages/logs/logs&quot;, &quot;pages/details/details&quot; ], CTRL + S 保存之后，模拟器就会自动刷新，马上可以看到效果。保存刷新之后就会发现，目录结构里自动创建了这一页。 简单起见，我们就在 pages/index 目录下实现 “个人中心” 页面好了。双击打开 index.wxml，初始内容如下： 这里已经有一些代码了，虽然现在可能还看不懂，但我们知道，这就是现在页面的源代码。我们把 “Hello World” 部分注释掉，增加我们希望显示的内容： 12345678910111213141516171819202122232425&lt;!--index.wxml--&gt;&lt;view class=&quot;container&quot;&gt; &lt;view class=&quot;userinfo&quot;&gt; &lt;button wx:if=&quot;{{!hasUserInfo &amp;&amp; canIUse}}&quot; open-type=&quot;getUserInfo&quot; bindgetuserinfo=&quot;getUserInfo&quot;&gt; 获取头像昵称 &lt;/button&gt; &lt;block wx:else&gt; &lt;image bindtap=&quot;bindViewTap&quot; class=&quot;userinfo-avatar&quot; src=&quot;{{userInfo.avatarUrl}}&quot; background-size=&quot;cover&quot;&gt;&lt;/image&gt; &lt;text class=&quot;userinfo-nickname&quot;&gt;{{userInfo.nickName}}&lt;/text&gt; &lt;/block&gt; &lt;/view&gt; &lt;!-- &lt;view class=&quot;usermotto&quot;&gt; &lt;text class=&quot;user-motto&quot;&gt;{{motto}}&lt;/text&gt; &lt;/view&gt; --&gt; &lt;!--注释内容--&gt; &lt;!--页面的三行字--&gt; &lt;view class=&quot;ID_Badge&quot;&gt; &lt;view&gt; &lt;text class=&quot;ID_info&quot;&gt;{{company}}&lt;/text&gt; &lt;/view&gt; &lt;view&gt; &lt;text class='ID_info'&gt;{{position}}&lt;/text&gt; &lt;/view&gt; &lt;view&gt; &lt;text class='ID_info'&gt;{{lesson}}&lt;/text&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 123456发现HTML的几种特性，自己总结的：1.一个标签出现之后会有一个相同的带反斜线的作为结尾，所以每一个标签都是成对出现的比如：&lt;view&gt;&lt;/view&gt; &lt;text&gt;&lt;/text&gt; 2.在一个标签可以修饰一个变量，然后这个变化的量有一个类，用class来说明，比如&lt;view class = &quot;ID_Badge&quot;&gt; &lt;text class = &quot;ID_info&quot;&gt;3.一个变量可以与.js文件中的date中的值相互关联，所以html只作为一个最前面的一个框架的作用，后面的.js文件支撑整个页面逻辑。4.只有html文件和js文件并不行，每一个类都需要在本页面的css文件内进行声明，并且设置这个类的样式属性。5.每一个text或者image的标签必须被一对view标签包围。","link":"/13114"},{"title":"数学建模入门","text":"准备数学建模过程中的一些小小笔记 Matlab学习笔记语法小知识： 同一行中间用逗号分隔，也可以不用逗号，直接用空格 分号可以用来分隔每一行的元素就是说逗号是一行中的数据，分号分割行与行之间。 矩阵E(:)表示矩阵的所有元素，E(:,1)表示第一列，E(1,:)表示第一行。 2:5表示从第2到第5，1:3:10表示从1到10，每次递增3。2:end表示从第二行到最后一行， ~=是不等号 Matlab函数的声明要单独放在一个.m文件中，不能直接放在主函数里面。函数声明格式：function [输出变量] = 函数名称(输入变量） 最后用end结束声明 123456789101112131415161718192021222324252627282930313233343536373839404142% 常用指令操作clc % 清屏clear all % 清除工作区的所有变量hold on hold off % 控制图像是否被刷新% 常用字符串函数char(65) % ascii码对应的字符，Alength(s) % 字符串长度strcmp() % 字符串比较函数strcat() % 将多个字符串合并成一个num2str() % 将数字转换为字符串% 常用数学函数size() % 数组大小，第二个参数也是dim表示矩阵的维度。magic() % 生成一个幻方abs(s) % 求s的ascii码floor() % 取整函数sum() % 求和函数，辅助参数dim表示求和的维度，1表示按列，2表示按行，默认dim=1repmat() % 复制扩展矩阵sort() % 将数组或矩阵排序prod() % 计算矩阵每一列的乘积eig() % 计算矩阵的特征值inv() % 求矩阵的逆矩阵rand() % 产生（0,1）之间均匀分布的伪随机数组成的数组randn() % 生成标准正态分布的伪随机数（均值为0，方差为1）randperm() % 将一序号随机打乱，序号必须是整数normrnd(MU,SIGMA) % 生成服从正态分布的随机数% 常用数据输入输出函数disp() % 向命令行输出字符或数字input() % 从命令行读取数据xlsread('xls_name_string') % Excel表格读取save % 用来将数据保存为.mat文件load % 用来加载之间生成的.mat文件% 常用绘图函数plot(x, y) % 创建2维直线图stem(Y) % 绘制数据序列Y的茎状图meshgrid(a, b) % 生成二维网格contour3(x, y, z) % 三维等值线绘图legend('string1','string2') % 标注绘制的图形的名称xlabel() ylabel() zlabel() % 标注x,y,z轴title() % matlab绘图标题设置set() % 设置图像属性axis() % 对坐标轴进行缩放操作 123% matlab里的一些基本规范% 数值% 字符串 floor函数详解 randperm函数详解 normrnd函数详解 repmat函数详解 size函数详解 magic函数详解 sum函数详解 prod函数详解 eig函数详解 find函数详解 plot命令详解 meshgrid函数详解 contour3函数详解 stem函数详解 hold on 和 hold off 语句详解 legend函数详解 xlabel函数详解 set函数详解 axis函数详解 title函数详解+matlab二维画图基本操作 xlsread函数详解 disp函数详解 input函数详解 save 和 load详解 一、矩阵及数组操作例题： 1234567891011121314151617181920212223% 生成一个3x3和15x8的单位矩阵eye(3, 3)eye(15, 8)% 生成全1矩阵ones(3)ones(15, 8)% 全0矩阵zeros(3)zeros(15, 8)% 均匀分布随机矩阵（[-1, 1]之间）2 * rand(3, 3) - 12 * rand(15, 8) - 1% 正态分布矩阵（均值为1，方差为4）1+sqrt(4)*randn(3,3)% 利用fix及rand函数生成[0,10]上的均匀分布的10x10的整数随机矩阵a，然后统计a中大于等于5的元素的个数。a = fix(10*rand(10,10));b = [a&gt;=5];c = [sum(b)];sum(c')% 在给定的矩阵中删除含有整行内容全为0的行，删除整列内容全为0的列。a = [1 2 0 4;0 0 0 0;5 6 0 8; 9 1 0 2];a(:,find(sum(abs(a'))==0)) = [];a(find(sum(abs(a'))==0),:) = [] % 没看懂，该写法待确认 二、绘图： 123456789101112% 在同一图形窗口画出下列两条曲线图像，并用legend标注：x=0 : 1 : 10;y1=2*x+5;y2=x.^2-3*x+1;plot(x, y1, x, y2);legend('y1','y2')% 画出下列函数的曲面及等高线% z = x^2 + y^2 + sin(xy).[x, y] = meshgrid(0:0.25:4*pi);z=x.^2+y.^2+sin(x*y);contour3(x, y, z);meshc(x, y, z) 三、简单程序设计 123456789101112131415161718192021222324% 求分段函数x=input('请输入x的值：');if x&gt;=-3 &amp;&amp; x &lt; -1 y=(-x^2-4*x-3)/2;elseif x&gt;=-1 &amp;&amp; x&lt;1 y=-x^2+1;elseif x&gt;=1 &amp;&amp; x&lt;=3 y=(-x^2+4*x-3)/2;else y='error'endy% 分数序列求和m = 1;n = 2;sum = 0;for k=1:15 f=n/m; sum=sum+f; t=n; n=m+n; m=t;endsum 一些注意事项: 在变量定义的时候多写注释，注明每个变量的作用。 好的数学建模matlab的代码部分注释都很详细。 可以将代码分成几个部分，这样更加清晰，e.g. 数据清除，导入数据，数据预处理，相关步骤等…. 在很多代码开头会遇到：clear;clc 这两条一起使用，起到“初始化”的作用，防止之前的结果对新脚本文件（后缀名是 .m）产生干扰。 数学建模常见算法学习层次分析法（AHP）一、对于一个问题，先分析系统中各因素之间的关系，建立系统的递阶层次结构（三层图）。 二、然后对于同一层次的各元素关于上一层中某一准则的重要性进行两两比较，构造判断矩阵。 在准则层需要生成每个准则的权重，在方案层需要生成对于每个准则的得分，使用两两对比的方法生成判断矩阵然后就可以计算出每个准则的权重或者方案对不同准则的得分了。 在层次分析法中我们构造的判断矩阵均是正互反矩阵(𝑎ij * 𝑎ji = 1)，若正互反矩阵满足𝑎ij * 𝑎jk = 𝑎ik，则我们称为一致矩阵。在判断矩阵计算准则的权重或者方案对不同准则的得分之前，需要对其进行一致性检验。 三、通过计算一致性指标和一致性比例来评判判断矩阵是否可以接受，计算对于该准则的相对权重。 进行一致性检验的一致矩阵准则的权重的计算或者方案对不同准则的得分的计算，计算权重或者得分有多种方式： 算数平均法求权重 集合平均法求权重 特征值法求权重 计算出所有的方案对不同准则的得分和准则的权重之后就可以计算每个方案的加权得分了。 四、计算各层元素对系统目标的合成权重，并进行排序。 TOPSIS法（优劣解距离法）一、将原始矩阵正向化，将所有的指标转化成极大型指标。 极大型指标 极小型指标 中间型指标 区间型指标 二、正向化矩阵标准化。 消除不同指标量纲的影响，例如名次和分数两个指标导致的量纲不统一的影响。 三、计算得分并归一化 通过公式计算每一个评价对象对不同的评价指标离最小值的距离和到最大最小距离的和的比值来得到评价对象在该评价指标上的得分。 四、带权重的TOPSIS 通过层次分析法可以得到不同的指标的权值，在进行计算得分的时候乘以相应的权值。 插值算法 理解：感觉该算法就是通过已知的一些点来推测拟合出一个函数，并借此函数计算出需要插值的点所对应的值是多少 常见插值方法： 多项式插值 分段插值 三角插值 一、拉格朗日插值法 通过该方法，可以通过n+1个点来找到一个n+1项n次的一个多项式作为插值函数，来估计对应插值点的函数值。 龙格现象：高次插值会产生龙格现象，即在两端处波动极大，产生明显的震荡。在不熟悉曲线的运动趋势的前提下，不要轻易使用高次插值 分段线性插值 分段线性插值法的一种为分段二次插值法，在几何上利用分段抛物线来代替原函数，故分段二次插值法又称为分段抛物线插值法。 但是在分段时使用的插值方法本质还是拉格朗日插值法。 二、牛顿插值法 与拉格朗日插值法相比，牛顿插值法具有继承性。（牛顿插值法每次插值只和前n项的值有关，这样每次只要在原来的函数上添加新的项，就能够产生新的函数）但是牛顿插值也存在龙格现象的问题。 拉格朗日插值法和牛顿插值法两种方法得到的多项式都不能全面的反映被插值函数的形态，比如说在一个或者全部节点上的导数值，或者高阶导数值，这两种插值法都不能满足。 三、埃尔米特（Hermite）插值法 埃尔米特插值法可以保证插值函数在节点处有切线（光滑）使插值函数和被插值函数的密合程度比较好。 分段三次埃尔米特插值法 直接使用Hermite插值得到的多项式的次数也比较高，也会存在龙格现象，因此在实际应用中，往往使用分段三次Hermite插值多项式（PCHIP） 四、三次样条插值法 该插值法同样是区间插值法，是可以保证二阶连续可微的插值法。 这些插值法都在Matlab内部提供了封装好的实现方法，体现为内置的函数。","link":"/35840"},{"title":"数据结构复习","text":"期末的小小总结 文件下载蜂考教案 数据结构期末考试考点第一章 数据结构和算法数据结构 算法 第二章 顺序表线性表逻辑结构，顺序表和链表都属于线性表。 顺序表的结构 第三章 链表单链表的结构 双链表和循环链表 第四章 栈和队列 栈的链式结构 队列的循序储存 头指针指的是头，尾指针指的是元素后面那一个。 第五章 串 矩阵的压缩 第六章 树和二叉树 二叉树 一个有趣的推论： 一个n叉树上叶子节点的个数为：度为n的节点的个数乘以n - 1，加上度为n - 1的节点的个数乘以n - 2……直到加上度为2的节点个数乘以1。得到的结果就是n叉树上叶子节点的个数。 可以进行简单的证明。 树和森林 二叉排序树 为了删去78，用87来代替78。同时将原位置上的78进行删除操作，然后进行调整只有将87放到78的位置上。 哈曼夫树 第八章 图 图的储存 第九章 图的应用最小生成树 拓扑排序 关键路径 第十章 查找 顺序查找 折半查找 散列表 第十一章 排序 插入排序直接插入排序 插入排序是指当循环第i次时，将a[i]插入到前i个有序的序列中去。 希尔排序 交换排序冒泡排序 快速排序 第十二章 排序（2）选择排序简单选择排序 选择排序是指当循环到第i次时，将i之后的序列中第i小（大）的值拍到第i的位置上去。 堆排序 归并排序 基数排序 各种排序算法比较","link":"/11651"},{"title":"树莓派入门","text":"没事找事干 之 我的树莓派~ 树莓派可以干点什么已经完成过的东西： 通过Frp实现外网访问树莓派 安装Jupyter实现python笔记本 使用webmin监控树莓派使用状态（已搁浅） 使用FFmpeg实现B站直播金鱼（已搁浅） Samba实现简易nas aria2实现下载机（已搁浅） 使用FFmpeg和python脚本实现B站直播轮播视频：python脚本的github仓库（欢迎:star:我的仓库） 软件准备在树莓派的所有操作中，我选择了使用全命令行的操作模式。 使用ssh远程连接树莓派，通过指令进行交互。 关于ssh软件的选择，我使用的是MobaXtream这款软件。它最大的好处是可以在连接之后直接通过文件浏览器的方式对服务器的文件进行管理，这使得本机和服务器的文件交换变得更加方便。 关于硬件改装加装风扇由于树莓派需要进行散热，如果采用被动散热在冬天很容易cpu就上到40℃以上了。 所以在添加完外壳的情况下，在树莓派cpu的上方位置加装了一个散热风扇。可以帮助树莓派更好的散热。 注意事项： 我添加的风扇是一个小功率且不可调节转速的风扇。（网络上有一些可以根据树莓派cpu温度进行自动调节的风扇，比较复杂所以就没有折腾） 该风扇通过树莓的GPIO接口进行供电。 风扇长这个样： 供电接口是一个连着的杜邦线母口 这是树莓派的GPIO引脚说明图： 将风扇的两个杜邦线引脚查到4号和6号接口上即可。 需要解决的问题： 我的树莓派上已经更换了3个小风扇了。 这些风扇常常在工作一段时间之后就会发生异响，虽然还在工作，但是噪音会变得很大。这时候我就会选择更换一个新的风扇。 但是产生异响的原因未知。 加装外壳加装外壳十分的简单，将购买的亚克力板外壳中的贴膜全部撕掉，然后一层一层按照顺序放好之后将树莓派放入外壳中，加装螺丝和螺母固定即可。 注意亚克力板的顺序需要配合树莓派的各个接口进行放置。 加装摄像头关于树莓派摄像头的选择，网络上有两种主流的方案，一种是直接通过usb接口连接一个usb摄像头，另一种是通过树莓派上预留的CSI通过排线连接。 后者的连接方法不需要额外下载安装驱动，所以我选择了后者。 注意：树莓派摄像头的安装一定要再关机的情况下进行，否则有可能会烧毁摄像头元件。 下图是树莓派上的CSI口： 将排线连接好后是这个样子： 连接好排线之后要再树莓派上打开摄像头 完成这些设置之后，摄像头就安装完成了。 摄像头的安装对后面实现直播金鱼做了硬件准备 镜像由于树莓派使用arm架构cpu的限制，使得树莓派不能使用一些针对主流x86系统的服务器镜像。好在树莓派官方有一个为树莓派定制的Linux系统，Raspbian。但是在使用这个系统的过程中，我也发现了许多问题。 Raspbian系统已知的问题有： 不完全支持docker。 Centos系统尝试过刷该系统针对树莓派的版本，但是失败了。 ssh连接如果有图像环境（向外有HDMI输出的话）可以通过图形选择打开树莓派的ssh连接，新买的树莓派是默认关闭ssh连接的，如果需要ssh连接，需要先打开。 如果没有图像环境，可以通过以下步骤进行树莓派的ssh连接。 1.开启ssh将树莓派的SD卡通过读卡器连接到pc上，打开SD卡盘符在的boot分区下建立ssh文本文档，注意，该文档没有后缀。（一些教程说可以建立一个ssh文件夹，应该原理是相似的） 2.进行连接即可通过1将树莓派的ssh打开之后，将sd卡装回树莓派，插一根网线到路由器上，然后重新开机后。找到树莓派对应的内网ip。之后直接通过ssh工具（比如mobaxterm）进行连接即可。或者通过win10的命令窗口也可以进行连接。 win10的ssh命令如下： ssh -oPort=22 pi@xxx.xxx.xxx.xxx 默认的ssh端口是22。 默认的用户名是：pi 默认的登录密码是：raspberry 网络配置有线网络配置直接将网线插入树莓派的网线插口即可，路由器会自动分配一个内网ip，从路由器的管理网站上找到树莓派分配的ip之后就可以进行ssh连接了。 无线网络配置已知的有两种方法进行无线网络的配置，一种是修改刷过镜像的sd卡中的树莓派的文件，一种是ssh连接之后通过命令行进行修改。 这里说一下后一种配置。 1.激活WiFi1）启用wifi rfkill unblock wifi 2）激活网卡 sudo ifconfig wlan0 up 2.扫描WiFi sudo iwlist wlan0 scan 3.设置需要连接的wifi名称及密码 sudo nano /etc/wpa_supplicant/wpa_supplicant.conf ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1country=CN network={ ssid=”这里填需要连接的wifi的名称（不要连5G那个）” psk=”这里填需要连接的wifi的密码” key_mgmt=WPA-PSK} 4.重启树莓派 sudo reboot 重启之后即可生效，拔掉网线，只需一根电源线就可以保证树莓派能够连接到网络辣。","link":"/63228"},{"title":"河南大学暑假集训的日常（1）","text":"DAY1(STL) HDU1880魔咒词典（字符串Hash/map/） 水题，两个map即可，细节在于string用cin读还是getline读，然后可以用string的erase来去掉中括号【】 以上的话，是提交卡在队列里时自信打出来的。最后发现是水的是我。。。 用两个map的话交一遍就会发现一定会MLE。。。而且HDU的MLE规则很奇怪，不要尝试参考评测机的内存大小来调数组的大小，没有用的。。以图为证： 是的，我MLE了20多次，都是在尝试调数组的大小。。。。。 正解应该是Hash+挂链法或者寻址法，但是我写的挂链法也还是MLE。。。最后选择了zy选择的vector。但是注意：这个代码也还是可以被卡掉，这个hash并没有处理字符串冲突的情况。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 100010;vector&lt;int&gt; a, b; string s1[maxn];string s2[maxn];string t1, t2;int cnt, n;int gethash(string s) { int res = 0, leng = s.length(); for (int i=0;i&lt;leng;++i) res += res * 237 + s[i]; return res;}int main() { while(cin &gt;&gt; t1 &amp;&amp; t1 != &quot;@END@&quot;) { getchar(); getline(cin, t2); int c1 = gethash(t1); int c2 = gethash(t2); a.push_back(c1); b.push_back(c2); s1[cnt] = t1; s2[cnt++] = t2; } cin &gt;&gt; n;getchar(); for (int i=1;i&lt;=n;++i) { getline(cin, t1); int tmp = gethash(t1); if (t1[0] == '[') { if (find(a.begin(), a.end(), tmp) == a.end()) cout &lt;&lt; &quot;what?&quot; &lt;&lt; endl; else cout &lt;&lt; s2[find(a.begin(), a.end(), tmp) - a.begin()] &lt;&lt; endl; }else { if (find(b.begin(), b.end(), tmp) == b.end()) cout &lt;&lt; &quot;what?&quot; &lt;&lt; endl; else { string s3 = s1[find(b.begin(), b.end(), tmp) - b.begin()]; for (int i=1;i&lt;s3.length()-1;++i) cout &lt;&lt; s3[i]; cout &lt;&lt; endl; } } } return 0;} HDU1276士兵队列训练问题（模拟/约瑟夫环） 用vector完成，简单模拟，水题。 第一遍没有注意输出空格PE了一次，第二遍A了 代码（比较丑陋）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; a, b;int n, m;int vsize() { int leng = a.size(), res = 0; for (int i=1;i&lt;leng;i++) { if (a[i] != -1) res++; } return res;}void work() { int flag = 0, leng; while(vsize() &gt; 3) { leng = a.size(); if (!flag) { for (int i=1;i&lt;leng;++i) if (i % 2 == 0) { a[i] = -1; } }else { for (int i=1;i&lt;leng;++i) if (i % 3 == 0) { a[i] = -1; } } for (vector&lt;int&gt;::iterator it=a.begin();it!=a.end();it++) { if (*it == -1) { a.erase(it); it--; } } flag = flag == 1 ? 0 : 1; }}int main() { cin &gt;&gt; n; for (int i=1;i&lt;=n;++i) { cin &gt;&gt; m; a.clear(); b.clear(); a.push_back(0); for (int j=1;j&lt;=m;++j) a.push_back(j); work(); for (vector&lt;int&gt;::iterator it=a.begin() + 1;it!=a.end();it++) { if (*it != -1) b.push_back(*it); } for (vector&lt;int&gt;::iterator it=b.begin();it!=b.end();it++) { if (it != b.end() - 1) cout &lt;&lt; *it &lt;&lt; ' '; else cout &lt;&lt; *it; } cout &lt;&lt; endl; } return 0;} 牛客 吐泡泡（栈） 点开之后发现5月的时候写过了。。。看了一下发现记不得自己是怎么做了，估计是要老年痴呆了（确信）简单的栈应用。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;#define rep(i, a, n) for (int i=a;i&lt;=n;++i)#define per(i, n, a) for (int i=n;i&gt;=a;--i)#define enter putchar('\\n')typedef long long ll;using namespace std;string s, ans;stack&lt;char&gt; sk;int len;int main() { while(cin &gt;&gt; s) { ans = &quot;&quot;; len = s.length(); rep(i, 0, len - 1) { if (sk.empty()) { sk.push(s[i]); continue; } else { char temp = sk.top(); if (temp == s[i]) { if (temp == 'o') { sk.pop(); if (sk.size() &amp;&amp; sk.top() == 'O') sk.pop(); else sk.push('O'); } else sk.pop(); }else sk.push(s[i]); } } while(sk.size()) { ans += sk.top(); sk.pop(); } per(i, ans.size() - 1, 0) cout &lt;&lt; ans[i]; enter; } return 0;} DAY2(单调栈、单调队列、ST表)POJ - 3250Bad Hair Day（单调栈） 由题可知将答案求每个羊可以看到多少只右边的羊转化为求每一个羊可以被多少左边的羊看到，然后在纸上模拟一下就可以发现单调栈满足这个过程。单调栈和单调队列难都是在思路的转换，一眼会想不到。 代码（摘了眼镜看形状好奇怪啊。。）： 12345678910111213141516171819#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;stack&lt;ll&gt; st;ll n, ans, tmp;int main() { cin &gt;&gt; n; cin &gt;&gt; tmp; st.push(tmp); for (int i=1;i&lt;n;++i) { cin &gt;&gt; tmp; while(st.size() &amp;&amp; st.top() &lt;= tmp) st.pop(); ans += st.size(); st.push(tmp); } cout &lt;&lt; ans; return 0;} POJ - 2823 Sliding Window（单调队列） 如果我们要得到区间的最大值，那我们可以维护一个队列，在里面存一些我们遇到过的比较大的值，并且保证这个队列是递减的。那么如果我们这时拿到一个新的数据，我们只需要把这个数据放到当前队列的正确的位置然后取队首元素就能找到最大值了。 由于该队列是单调递增的，所以只需要将新的数据和队尾的值进行比较，如果队尾的值比较小，那么直接扔掉，因为我们要得到的是区间的最大值，所以舍去一些比较小并且比较旧的值并没有什么影响。 对于这道题最后需要注意的是处理完数据之后的队首是否在当前数据的窗口中，若不在，那么将旧数据直接舍弃即可。 处理区间的最小值同理。 对于队列维护的模拟可以看这个博客。 这道题还有一些小坑。因为在POJ上，会比较慢，用deque会T掉，可以用数组模拟一个双端队列。然后常数大也会被卡掉，所以要用快读。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;deque&gt;using namespace std;const int maxn = 1e6 +7;int n, k;int a[maxn], b1[maxn], b2[maxn], tot1, tot2, h1, h2, t1, t2;pair&lt;int, int&gt; q1[maxn], q2[maxn];inline int read() { int a=0,f=1; char c=getchar(); while (c&lt;'0'||c&gt;'9') {if (c=='-') f=-1; c=getchar();} while (c&gt;='0'&amp;&amp;c&lt;='9') {a=a*10+c-'0'; c=getchar();} return a*f;}void init() { ios::sync_with_stdio(false); n = read();k=read(); for (int i=1;i&lt;=n;++i) a[i] = read(); h1 = 1, h2 = 1, t1 = 1, t2 = 1;}inline void write(int x){ if(x&gt;9)write(x/10); putchar(x%10+'0');}void solve() { for (int i=1;i&lt;k;++i) { while(h1 &lt; t1 &amp;&amp; q1[t1-1].first &lt;= a[i]) t1--; while(h2 &lt; t2 &amp;&amp; q2[t2-1].first &gt;= a[i]) t2--; q1[t1].second = i;q1[t1++].first = a[i]; q2[t2].second = i;q2[t2++].first = a[i]; } for (int i=k;i&lt;=n;++i) { while(h1 &lt; t1 &amp;&amp; q1[h1].second &lt;= i - k) h1++; while(h2 &lt; t2 &amp;&amp; q2[h2].second &lt;= i - k) h2++; while(h1 &lt; t1 &amp;&amp; q1[t1-1].first &lt;= a[i]) t1--; while(h2 &lt; t2 &amp;&amp; q2[t2-1].first &gt;= a[i]) t2--; q1[t1].second = i;q1[t1++].first = a[i]; q2[t2].second = i;q2[t2++].first = a[i]; b1[++tot1] = q1[h1].first; b2[++tot2] = q2[h2].first; }}void print() { for (int i=1;i&lt;=tot1;++i) if(i!=tot1) printf(&quot;%d &quot;,b2[i]); else printf(&quot;%d\\n&quot;,b2[i]); for (int i=1;i&lt;=tot2;++i) if(i!=tot2) printf(&quot;%d &quot;,b1[i]); else printf(&quot;%d&quot;,b1[i]);}int main() { init(); solve(); print(); return 0;} POJ - 3264 Balanced Lineup（ST表/线段树/树状数组） 这道题是学长讲的ST表的例题，本质是一个RMQ。 ST表，是利用倍增和动态规划的思想处理出的一个查询表，需要用nlogn的时间预处理，得到ST表之后，就可用O(1)的时间查询任意区间内的极值。 ST表的预处理的状态转移方程：d1[i][j]=min(d1[i-1][j],d1[i-1][j+bin[i-1]]); i表示2的i次方，j表示某个点。对于每一个点的所有有意义的2的i次方长度的区间内的极值都需要求出。 ST算法进行查询的核心是在预处理出每个端点本身开始往后的2的i次方的范围内的每一个2区间内的极值后。对于每一次查询，找到满足区间长度r - l + 1所能满足的最大的2的x次方，然后将长度分为两半，以2的x-1次方为区间长度对两个端点的左右进行查询，O（1）的复杂度，然后取这两个值中的极值即为区间的极值。 参考博客：https://blog.csdn.net/Keep_Trying_Go/article/details/116268533https://blog.csdn.net/Hanks_o/article/details/77547380 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;cstring&gt;#define rep(i,a,b) for (int i=a;i&lt;=b;++i)using namespace std;const int maxn = 50010;int n, q; int a[maxn], bin[30], Log[maxn];int d1[30][maxn], d2[30][maxn];void init() { memset(a,0,sizeof(a)); memset(d1,0,sizeof(d1)); memset(d2,0,sizeof(d2)); bin[0] = 1;Log[0] = -1; cin &gt;&gt; n &gt;&gt; q; rep(i,1,n) cin &gt;&gt; a[i]; rep(i,1,20) bin[i] = bin[i - 1] * 2; rep(i,1,50001) Log[i] = Log[i/2] + 1; rep(i,1,n) d1[0][i] = d2[0][i] = a[i]; rep(i,1,Log[n]) { rep(j,1,n) { if(j+bin[i]-1&lt;=n) { d1[i][j]=min(d1[i-1][j],d1[i-1][j+bin[i-1]]); d2[i][j]=max(d2[i-1][j],d2[i-1][j+bin[i-1]]); } } }}void query(int x ,int y) { int t = Log[y-x+1]; int a = max(d2[t][x],d2[t][y-bin[t]+1]); int b = min(d1[t][x],d1[t][y-bin[t]+1]); cout &lt;&lt; a - b &lt;&lt; endl;}int main() { init(); rep(i,1,q) { int a, b; cin &gt;&gt; a &gt;&gt; b; query(a, b); } return 0;} POJ - 2559 Largest Rectangle in a Histogram （单调栈） 单调栈的应用。 对于每一个长方形来说，如果不重复计算的话，这道题的答案就是每个长方形向右画的长方形中面积最大的那一个。 接着想，对于某个长方形，它所能画出的最大高度就是他本身，最大宽度就是他往右的连续的不低于他的长方形的宽度。对于一个高度上升的长方形序列，其中一个长方形所能达到的最大面积就是向右不低于该长方形的所有长方形的宽度和，所以，对于一个还在上升的序列，并不能知道它最右边能够到达的宽度有多少，所以将其加入栈中，如果发现了一个长方形的高度下降，那么这个长方形一定可以作为上升序列中的一些长方形的右边界。此时开始计算，直到序列恢复递增为止。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#define rep(i,a,b) for (int i=a;i&lt;=b;++i)using namespace std;typedef long long ll;const int maxn = 100010;ll n, a[maxn], w[maxn], s[maxn], tail, ans;inline void init() { memset(w, 0, sizeof(w)); memset(a, 0, sizeof(a)); memset(s, 0, sizeof(s)); ans = 0, tail = 0; s[n + 1] = 0; rep(i,1,n) cin &gt;&gt; a[i];}void solve() { rep(i,1,n+1) { if (a[i] &gt; s[tail]) { s[++tail] = a[i]; w[tail] = 1; } else { int width = 0; while(a[i] &lt; s[tail]) { width += w[tail]; ans = max(ans, (ll)width * s[tail]); tail--; } s[++tail] = a[i], w[tail] = width + 1; } }}int main() { while(cin &gt;&gt; n &amp;&amp; n != 0) { init(); solve(); cout &lt;&lt; ans &lt;&lt; endl; } return 0;}","link":"/16332"},{"title":"河南大学暑假集训的日常（2）","text":"DAY3（并查集） HDU - 1213 How Many Tables（并查集） 简单题。 代码： 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;const int maxn = 11000;int T, n, m, a, b;int f[maxn];int ans() { int res = 0; for (int i=1;i&lt;=n;++i) if (f[i] == i) res++; return res;}int find(int x) {return (f[x] == x) ? x : f[x] = find(f[x]);} int main() { cin &gt;&gt; T; for (int i=1;i&lt;=T;++i) { cin &gt;&gt; n &gt;&gt; m; for (int i=1;i&lt;=n;++i) f[i] = i; for (int i=1;i&lt;=m;++i) { cin &gt;&gt; a &gt;&gt; b; int x = find(a), y = find(b); f[y] = x; } printf(&quot;%d\\n&quot;, ans()); } return 0;} HDU - 3038 How Many Answers Are Wrong（带边权并查集） 该题是一道时带边权的并查集。 对于每一个节点，不仅要维护它的祖先节点（若该节点上向右的区间有值的话右端点所对应的节点）的编号，还要维护该节点到它祖先节点的距离。 距离可以为负数，在计算区间的时候减去距离就行了。在对一组区间的数据检测是否合法的时候，检测两个端点是否可以通过某一种方式通过某一种路径联通，即两节点的祖先节点是否为同一节点。如果联通，那么就可以通过这两个节点到其祖先节点的距离来计算出这两个节点之间的距离了。 对于节点到其祖先节点的距离的维护，可以通过递归寻找祖先节点的过程中更新。在每一次寻找的过程中，如果该节点不是最终的祖先节点的话，那么将该节点到祖先节点的距离加上其父节点到祖先节点的距离。 对于新插入的节点，需要维护两节点的根节点的距离关系，可以通过画出向量的方式较为清楚的表达出来： 带边权并查集参考博客 代码： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int maxn = 200010;int f[maxn], d[maxn];int n, m;int find(int x) { if (x != f[x]) { int t = f[x]; f[x] = find(f[x]); d[x] += d[t];//这句话会在find函数进行递归的过程中进行更新路径上的距离值。 } return f[x];}int main() { while(cin &gt;&gt; n &gt;&gt; m) { memset(d, 0, sizeof(d)); for (int i=0;i&lt;=maxn-2;++i) f[i] = i; int l, r, v, ans = 0; for (int i=1;i&lt;=m;++i) { scanf(&quot;%d%d%d&quot;, &amp;l,&amp;r,&amp;v); l--; int fl = find(l); int fr = find(r); if (fl == fr) { if (d[r] - d[l] != v) ans++; }//这个位置没有加大括号WA了好几发，但是我现在还是不知道这里为啥需要加大括号。。。 //这个括号到这我在HDU上WA了10+发 else { f[fr] = fl; d[fr] = d[l] + v - d[r]; } } printf(&quot;%d\\n&quot;,ans); } return 0;} POJ - 2492A Bug’s Life（种类并查集/拓展域并查集） 开两倍的f数组，x+n表示与x不相同的种类，（这种方法也叫作拆点）每一对虫子只需要保证性别不同即可，即x和y+n是联通的x+n和y也是联通的，但是x和y并不联通。如果在同一种类一侧出现了连接，即为产生了矛盾。 代码： 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 2010;int T, n, m, x, y;bool flag = true;int f[maxn &lt;&lt; 1];int find(int x) {return f[x] == x ? x : f[x] = find(f[x]);}inline bool check(int x, int y) { int px = find(x), py = find(y); return px == py;}inline void unino(int x, int y) { int px = find(x), py = find(y); f[py] = px;}int main() { cin &gt;&gt; T; for (int i=1;i&lt;=T;++i) { scanf(&quot;%d%d&quot;, &amp;n,&amp;m); flag = true; for (int i=1;i&lt;=n*2;++i) f[i] = i; for (int i=1;i&lt;=m;++i) { scanf(&quot;%d%d&quot;, &amp;x,&amp;y); if (!flag) continue; if (check(x, y) || check(x+n, y+n)) flag = false; else { unino(x, y+n); unino(x+n, y); } } if (!flag) printf(&quot;Scenario #%d:\\nSuspicious bugs found!\\n\\n&quot;, i); else printf(&quot;Scenario #%d:\\nNo suspicious bugs found!\\n\\n&quot;, i); } return 0;} POJ - 1988 Cube Stacking（带边权并查集） 这道题同样也是带边权的并查集，有点像银河英雄传说这道题。每一个节点需要维护的值有到底部的距离和该栈的元素个数。核心部分还是在合并时权值的处理。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int n = 50010;int m, x, y;int f[n], d[n], h[n];inline void init() { cin &gt;&gt; m; for (int i=1;i&lt;n;++i) { f[i] = i; h[i] = 1; d[i] = 0; }}int find(int x) { if (x != f[x]) { int t = f[x]; f[x] = find(f[x]); d[x] += d[t]; } return f[x];}int main() { init(); string od; for (int i=1;i&lt;=m;++i) { cin &gt;&gt; od; if (od[0] == 'C') { cin &gt;&gt; x; find(x); printf(&quot;%d\\n&quot;, d[x]); }else { cin &gt;&gt; x &gt;&gt; y; int px = find(x); int py = find(y); if (px != py) { f[px] = py; d[px] = h[py]; h[py] += h[px]; } } } return 0;} POJ - 1182食物链（拓展域并查集） 经典的拓展域并查集。 拓展域并查集：首先对与最简单的并查集来说，如果两个是同一类，那么就p[pa]=pb对吧，但是对于两个相互排斥类的怎么办呢，这就涉及到拓展与并查集了，首先想法就是建立两个并查集，但是怎么把两个并查集联系起来呢？拓展个体。 这里的拓展个体是什么意思呢，一个个体我们要拆成多个，比方说两个集合存在队立关系，那么对于一个个体a，我们假设存在一个个体a+n ，a和a+n这两个是处于对立关系的，所以当我们说a和b对立的时候，意思就是在说，a+n和b在同一并查集，b+n和a在同一并查集，当我们说，a和b是同类的时候，那么也就是说a和b属于一个并查集，且a+n和b+n属于一个并查集。 开三倍的数组，除了本身的域之外拓展的两个域表示域和本身的关系。分别表示天敌和捕食。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#define rep(i, a, n) for (ll i=a;i&lt;=n;++i)#define per(i, n, a) for (ll i=n;i&gt;=a;--i)#define IOS std::ios::sync_with_stdio(false)#define enter putchar('\\n')typedef long long ll;using namespace std;const int maxn = 50010;int n, k, f[maxn * 3];int d, x, y, ans;int getfa(int x) {return (f[x] == x) ? x : f[x] = getfa(f[x]);}inline void un(int x, int y) { int a = getfa(x); int b = getfa(y); if (a != b) f[b] = a;}void work(int d, int x, int y) { if (x &gt; n || y &gt; n) {ans++;return;} if (d == 1) { if (getfa(x + n) == getfa(y) || getfa(x + 2 * n) == getfa(y)) {ans++;return;} un(x, y); un(x + n, y + n); un(x + 2 * n, y + 2 * n); } if (d == 2) { if (getfa(x) == getfa(y) || getfa(x + 2 * n) == getfa(y)) {ans++;return;} un(x + n, y); un(y + 2 * n, x); un(y + n, x + 2 * n); }}int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;k); rep(i, 1, n*3) f[i] = i; rep(i, 1, k) { scanf(&quot;%d%d%d&quot;, &amp;d, &amp;x, &amp;y); work(d, x, y); } printf(&quot;%d\\n&quot;, ans); return 0;} DAY4（树状数组）POJ - 3468A Simple Problem with Integers（线段树/树状数组） 一个简单的区间修改和区间求和的板子题。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;typedef long long ll;const int maxn = 1e5 + 7;struct SegmentTree { ll l, r; ll dat, add; #define l(x) tree[x].l #define r(x) tree[x].r #define dat(x) tree[x].dat #define add(x) tree[x].add}tree[maxn &lt;&lt; 2];ll a[maxn &lt;&lt; 1];ll n, m;inline ll Read() { ll x=0,f=1;char ch=getchar(); while(ch&gt;'9'||ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();} return x*f;}inline void update(ll p) {dat(p) = dat(p&lt;&lt;1) + dat(p&lt;&lt;1|1);}void build(ll p, ll l, ll r) { l(p) = l; r(p) = r; if (l == r) {dat(p) = a[l]; return;} ll mid = (l + r) &gt;&gt; 1; build(p&lt;&lt;1, l, mid); build(p&lt;&lt;1|1, mid+1, r); update(p);}void spread(ll p) { if (add(p)) { add(p&lt;&lt;1) += add(p); add(p&lt;&lt;1|1) += add(p); dat(p&lt;&lt;1) += add(p) * (r(p&lt;&lt;1) - l(p&lt;&lt;1) + 1); dat(p&lt;&lt;1|1) += add(p) * (r(p&lt;&lt;1|1) - l(p&lt;&lt;1|1) + 1); add(p) = 0; }}void change(ll p, ll l, ll r, ll d) { if (l &lt;= l(p) &amp;&amp; r &gt;= r(p)) { dat(p) += d * (r(p) - l(p) + 1); add(p) += d; return; } spread(p); ll mid = (l(p) + r(p)) &gt;&gt; 1; if (l &lt;= mid) change(p&lt;&lt;1, l, r, d); if (r &gt; mid) change(p&lt;&lt;1|1, l, r, d); update(p);}ll ask(int p, int l, int r) { if (l &lt;= l(p) &amp;&amp; r &gt;= r(p)) return dat(p); spread(p); ll mid = (l(p) + r(p)) &gt;&gt; 1; ll res = 0; if (l &lt;= mid) res += ask(p&lt;&lt;1, l, r); if (r &gt; mid) res += ask(p&lt;&lt;1|1, l, r); return res;}inline void init() { n = Read(); m = Read(); for (register int i=1;i&lt;=n;++i) a[i] = Read(); build(1, 1, n);}inline void work() { ll l, r, d; char op; while(m--) { cin &gt;&gt; op; if (op == 'C') { l = Read(); r = Read(); d = Read(); change(1, l, r, d); } if (op == 'Q') { l = Read(); r = Read(); printf(&quot;%lld\\n&quot;, ask(1, l, r)); } }}int main() { init(); work(); return 0;} HDU - 1166敌兵布阵（树状数组） 单点修改区间求和的树状数组板子题。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;typedef long long ll;using namespace std;const int maxn = 50010;int T, n, l, r;int a[maxn], c[maxn];string od;inline int Read() { int x=0,f=1;char ch=getchar(); while(ch&gt;'9'||ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();} return x*f;}inline int ask(int x, int res = 0) {for (; x&gt;=1; x-=(x&amp;-x)) res += c[x];return res;}inline void update(int x, int v) {for (; x&lt;=n; x+=(x&amp;-x)) c[x] += v;}inline int query(int l, int r) {return ask(r) - ask(l - 1);}inline void init() { n = Read(); memset(c, 0, sizeof(c)); memset(a, 0, sizeof(a)); for (int i=1;i&lt;=n;++i) { a[i] = Read(); update(i, a[i]); }}int main() { T = Read(); for (int i=1;i&lt;=T;++i) { init(); printf(&quot;Case %d:\\n&quot;, i); while(cin &gt;&gt; od &amp;&amp; od != &quot;End&quot;) { l = Read(); r = Read(); if (od == &quot;Add&quot;) update(l, r); if (od == &quot;Sub&quot;) update(l, -r); if (od == &quot;Query&quot;) printf(&quot;%d\\n&quot;, query(l, r)); } } return 0;} HDU - 1394Minimum Inversion Number（逆序对/树状数组） 树状数组求逆序对数的改进版，需要在题中所给的序列生成的一系列序列中找到逆序对数最小的那一组。 关于求一个数列的逆序对数，可以用树状数组来维护一个数字前面比自己大的数的个数。树状数组可以方便的在线求前缀和，所以说可以用树状数组来完成这道题。 树状数组求逆序对参考博客 代码： 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#define int llusing namespace std;typedef long long ll;const int maxn = 5010;int n, a[maxn &lt;&lt; 2], f[maxn &lt;&lt; 2];int tmp, ans;inline int lowbit(int x) {return -x&amp;x;}void update(int x, int v) {for (; x&lt;=n; x+=lowbit(x))f[x] += v;}int ask(int x, int res = 0) {for (; x&gt;=1;x-=lowbit(x)) res += f[x];return res;}signed main() { while(scanf(&quot;%d&quot;, &amp;n) != EOF) { memset(a, 0, sizeof(a)); memset(f, 0, sizeof(f)); tmp = ans = 0; for (int i=1;i&lt;=n;++i) { scanf(&quot;%d&quot;, &amp;a[i]); a[i]++; update(a[i], 1); tmp += (i - ask(a[i])); }//该过程是求一个序列的逆序对的方法 ans = tmp; for (int i=1;i&lt;n;++i) { tmp += (n - 2 * a[i] + 1); ans = min(ans, tmp); }//这一段是解决如何求出每一个元素后移之后的序列逆序对数 printf(&quot;%d\\n&quot;, ans); } return 0;} HDU - 2795Billboard（线段树） 这道题的实现其实不太难，难点是如何建树。 由题可知，我们可以在广告牌的高度上建树，然后对于每一个新的广告，查找最靠下的可以满足当前广告牌的位置插入，实际上就是维护了一个区间的最大值，来进行判断当前广告是否可以放到该区间中。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;typedef long long ll;const ll maxn = 500010;ll n, h, w;ll a[maxn * 4];inline void update(ll p) {a[p] = max(a[p &lt;&lt; 1], a[p &lt;&lt; 1 | 1]);}void build(ll p, ll l, ll r) { if (l == r) { a[p] = w; return; } ll mid = (l + r) &gt;&gt; 1; build(p &lt;&lt; 1, l, mid); build(p &lt;&lt; 1 | 1, mid + 1, r); update(p);}ll ask(ll x, ll l, ll r, ll p) { if (l == r) { a[p] -= x; return l; } ll mid = (l + r) &gt;&gt; 1; ll res = 0; if (a[p&lt;&lt;1] &gt;= x) res = ask(x, l, mid, p&lt;&lt;1); else res = ask(x, mid + 1, r, p&lt;&lt;1|1); update(p); return res;}int main() { while(scanf(&quot;%d%d%d&quot;, &amp;h, &amp;w, &amp;n) != EOF) { memset(a, 0, sizeof(a)); h = min(h,n); build(1,1,h); ll x = 0; for (int i=1;i&lt;=n;++i) { scanf(&quot;%d&quot;, &amp;x); if (a[1] &lt; x) printf(&quot;-1\\n&quot;); else printf(&quot;%d\\n&quot;, ask(x, 1, h, 1)); } } return 0;} POJ - 2777Count Color（线段树+状态压缩） 用位运算来保存颜色的状态，加上懒惰标记，然后update维护父子节点的信息会不太一样。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#define int llusing namespace std;typedef long long ll;const int maxn = 500010;int n, t, m, l, r, c;int a[maxn &lt;&lt; 2], f[maxn &lt;&lt; 2];char od[5];void update(int p) {a[p] = a[p*2] | a[p*2+1];}void spread(int p) {a[p*2+1] = a[p*2] = f[p*2+1] = f[p*2] = f[p];f[p] = 0;} void change(int p, int l, int r, int x, int y, int c) { if (x &lt;= l &amp;&amp; r &lt;= y) { f[p] = a[p] = 1 &lt;&lt; c; return; } int mid = (l + r) &gt;&gt; 1; if (f[p]) spread(p); if (x &lt;= mid) change(p*2, l, mid, x, y, c); if (y &gt; mid) change(p*2+1, mid + 1, r, x, y, c); update(p); }int ask(int p, int l, int r, int x, int y) { if (x &lt;= l &amp;&amp; r &lt;= y) return a[p]; ll mid = (l + r) &gt;&gt; 1; if (f[p]) spread(p); ll res = 0; if (x &lt;= mid) res |= ask(p&lt;&lt;1, l, mid, x, y); if (y &gt; mid) res |= ask(p&lt;&lt;1|1, mid + 1, r, x, y); return res;}int cnt(int x) { int ans = 0; while(x) ans++, x -= -x&amp;x; return ans;}signed main() { scanf(&quot;%lld%lld%lld&quot;, &amp;n,&amp;t,&amp;m); change(1, 1, n, 1, n, 1); for (int i=1;i&lt;=m;++i) { scanf(&quot;%s%lld%lld&quot;, od, &amp;l, &amp;r); if (l &gt; r) l ^= r ^= l ^= l; if (od[0] == 'C') { scanf(&quot;%lld&quot;, &amp;c); change(1, 1, n, l, r, c); }else printf(&quot;%lld\\n&quot;, cnt(ask(1, 1, n, l, r))); } return 0;}","link":"/8528"},{"title":"河南大学暑假集训的日常（3）","text":"DAY5（线段树） HDU - 1394 Minimum Inversion Number（树状数组/线段树） 和昨天的题撞了，用树状数组求数列的逆序对。 代码： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#define TobinMEng caicai#define int llusing namespace std;typedef long long ll;const int maxn = 5010;int n, a[maxn &lt;&lt; 2], f[maxn &lt;&lt; 2];int tmp, ans;inline int lowbit(int x) {return -x&amp;x;}void update(int x, int v) {for (; x&lt;=n; x+=lowbit(x))f[x] += v;}int ask(int x, int res = 0) {for (; x&gt;=1;x-=lowbit(x)) res += f[x];return res;}signed main() { while(scanf(&quot;%d&quot;, &amp;n) != EOF) { memset(a, 0, sizeof(a)); memset(f, 0, sizeof(f)); tmp = ans = 0; for (int i=1;i&lt;=n;++i) { scanf(&quot;%d&quot;, &amp;a[i]); a[i]++; update(a[i], 1); tmp += (i - ask(a[i])); } ans = tmp; for (int i=1;i&lt;n;++i) { tmp += (n - 2 * a[i] + 1); ans = min(ans, tmp); } printf(&quot;%d\\n&quot;, ans); } return 0;} HDU - 1698 Just a Hook（线段树） 是一个将区间覆盖修改为一个相同的数并维护区间的和的一个线段树板子题。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#define int long longusing namespace std;const int maxn = 200010;int n, m, T, l, r, v;struct SegmentTree { int l, r; int dat, add; #define l(p) tree[p].l #define r(p) tree[p].r #define dat(p) tree[p].dat #define add(p) tree[p].add}tree[maxn &lt;&lt; 2];inline int Read() { int x=0,f=1;char ch=getchar(); while(ch&gt;'9'||ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();} return x*f;}inline void update(int p) {dat(p) = dat(p &lt;&lt; 1) + dat((p &lt;&lt; 1) | 1);}inline void spread(int p) { if (add(p)) { add(p &lt;&lt; 1) = add(p); add((p &lt;&lt; 1) | 1) = add(p); dat(p &lt;&lt; 1) = add(p) * (r(p &lt;&lt; 1) - l(p &lt;&lt; 1) + 1); dat((p &lt;&lt; 1) | 1) = add(p) * (r((p &lt;&lt; 1) | 1) - l((p &lt;&lt; 1) | 1) + 1); add(p) = 0; }}void build(int p, int l, int r) { l(p) = l; r(p) = r; add(p) = 0; if (l == r) {dat(p) = 1;return;} int mid = (l + r) &gt;&gt; 1; build(p &lt;&lt; 1, l, mid); build((p &lt;&lt; 1) | 1, mid + 1, r); update(p);}void change(int p, int l, int r, int v) { if (l &lt;= l(p) &amp;&amp; r(p) &lt;= r) { dat(p) = v * (r(p) - l(p) + 1);//对于区间覆盖修改的值和区间加减修改的值是有区别的。 add(p) = v; return; } spread(p); int mid = (l(p) + r(p)) &gt;&gt; 1; if (l &lt;= mid) change(p &lt;&lt; 1, l, r, v); if (r &gt; mid) change((p &lt;&lt; 1) | 1, l, r, v); update(p);}signed main() { T = Read(); for (int t=1;t&lt;=T;++t) { n = Read(); m = Read(); build(1, 1, n); for (int i=1;i&lt;=m;++i) { l = Read(); r = Read(); v = Read(); change(1, l, r, v); } printf(&quot;Case %lld: The total value of the hook is %lld.\\n&quot;, t, dat(1)); }} HDU - 1754 I Hate It （线段树） 单点修改+区间最值线段树模板 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 2000010;int n, m, l, r;int a[maxn];char od[5];struct node { int l, r; int dat, add; #define l(x) tree[x].l #define r(x) tree[x].r #define dat(x) tree[x].dat}tree[maxn &lt;&lt; 2];inline int Read() { int x=0,f=1;char ch=getchar(); while(ch&gt;'9'||ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();} return x*f;}inline void update(int p) {dat(p) = max(dat(p&lt;&lt;1), dat(p&lt;&lt;1|1));}void build(int p, int l, int r) { l(p) = l; r(p) = r; if (l == r) {dat(p) = a[l];return;} int mid = (l + r) &gt;&gt; 1; build(p &lt;&lt; 1, l, mid); build(p &lt;&lt; 1 | 1, mid + 1, r); update(p);}void init() { for (int i=1;i&lt;=n;++i) a[i] = Read(); build(1, 1, n);}void change(int p, int x, int v) { if (l(p) == r(p)) { dat(p) = v; return; } int mid = (l(p) + r(p)) &gt;&gt; 1; if (x &lt;= mid) change(p &lt;&lt; 1, x, v); if (x &gt; mid) change(p &lt;&lt; 1 | 1, x, v); update(p);}int ask(int p, int l, int r) { if (l &lt;= l(p) &amp;&amp; r(p) &lt;= r) return dat(p); int mid = (l(p) + r(p)) &gt;&gt; 1; int res = 0; if (l &lt;= mid) res = max(res, ask(p &lt;&lt; 1, l, r)); if (r &gt; mid) res = max(res, ask(p &lt;&lt; 1 | 1, l, r)); return res;}int main() { while(scanf(&quot;%d%d&quot;, &amp;n,&amp;m) != EOF) { init(); for (int i=1;i&lt;=m;++i) { scanf(&quot;%s&quot;, od); l = Read(); r = Read(); if (od[0] == 'Q') printf(&quot;%d\\n&quot;, ask(1, l, r)); else change(1, l, r); } } return 0;} HDU - 1166 敌兵布阵（树状数组） 一个简单的树状数组，区间加减，区间求和 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;typedef long long ll;using namespace std;const int maxn = 50010;int T, n, l, r;int a[maxn], c[maxn];string od;inline int Read() { int x=0,f=1;char ch=getchar(); while(ch&gt;'9'||ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();} return x*f;}inline int ask(int x, int res = 0) {for (; x&gt;=1; x-=(x&amp;-x)) res += c[x];return res;}inline void update(int x, int v) {for (; x&lt;=n; x+=(x&amp;-x)) c[x] += v;}inline int query(int l, int r) {return ask(r) - ask(l - 1);}inline void init() { n = Read(); memset(c, 0, sizeof(c)); memset(a, 0, sizeof(a)); for (int i=1;i&lt;=n;++i) { a[i] = Read(); update(i, a[i]); }}int main() { T = Read(); for (int i=1;i&lt;=T;++i) { init(); printf(&quot;Case %d:\\n&quot;, i); while(cin &gt;&gt; od &amp;&amp; od != &quot;End&quot;) { l = Read(); r = Read(); if (od == &quot;Add&quot;) update(l, r); if (od == &quot;Sub&quot;) update(l, -r); if (od == &quot;Query&quot;) printf(&quot;%d\\n&quot;, query(l, r)); } } return 0;} DAY6（DP入门）LibreOJ - 10147 石子合并（区间DP） 经典区间DP。 数组复制到2n保证成环，枚举区间长度，然后遍历每一个区间，每一个区间由该区间中间分开成的两个区间转移过来，f[i][j]表示i到j区间上进行合并的最大或者最小消耗是多少。转移方程为f1[l][r] = min(f1[l][r], f1[l][k] + f1[k+1][r]); f1[l][r] += sum[r] - sum[l-1]; 代码： 1234567891011121314151617181920212223242526272829303132333435363738# include &lt;iostream&gt;# include &lt;cstring&gt;# include &lt;cstdio&gt;# include &lt;algorithm&gt;using namespace std;const int INF = 99999999;int f1[205][205], f2[205][205], a[205], sum[205];int n, ans1 = INF, ans2 = 0;int main() { scanf(&quot;%d&quot;, &amp;n); for (int i=1;i&lt;=n;++i) { scanf(&quot;%d&quot;, &amp;a[i]); a[i+n] = a[i]; } memset(f1, 0x3f, sizeof(f1)); for (int i=1;i&lt;=n*2;++i) { f1[i][i] = 0; sum[i] = sum[i-1] + a[i]; } for (int len=2;len&lt;=n;++len) { for (int l=1;l&lt;=n*2-len+1;++l) { int r = l + len - 1; for (int k=l;k&lt;r;++k) { f1[l][r] = min(f1[l][r], f1[l][k] + f1[k+1][r]); f2[l][r] = max(f2[l][r], f2[l][k] + f2[k+1][r]); } f1[l][r] += sum[r] - sum[l-1]; f2[l][r] += sum[r] - sum[l-1]; } } for (int i=1;i&lt;=n;++i) { ans1 = min(ans1, f1[i][i+n-1]); ans2 = max(ans2, f2[i][i+n-1]); } printf(&quot;%d\\n%d\\n&quot;, ans1, ans2); return 0;} HDU - 1257 最少拦截系统（LIS） 最长上升子序列的板子题。 该题要求一个序列的最长不下降子序列的个数，可以转化为求一个序列的最长上升子序列的长度。该写法时间复杂度O(n^2)。有nlogn的写法，暂时不想去复习:) 代码： 12345678910111213141516171819202122232425#include&lt;iostream&gt; #include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;const ll maxn = 30010; ll a[maxn], d[maxn];ll n, ans;int main() { while(~scanf(&quot;%d&quot;, &amp;n)) { ans = 0; for (int i=1;i&lt;=n;++i) scanf(&quot;%d&quot;, &amp;a[i]); for (int i=1;i&lt;=n;++i) { d[i] = 1; for (int j=1;j&lt;i;++j) { if (a[j] &lt; a[i]) d[i] = max(d[j] + 1, d[i]); ans = max(ans, d[i]); } } printf(&quot;%d\\n&quot;, ans); } return 0;} HDU - 1176 Bone Collector（01背包） 经典01背包板子题。 代码： 123456789101112131415161718192021222324252627#include&lt;iostream&gt; #include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;const ll maxn = 1010;ll T, n, v;ll w[maxn], c[maxn], d[maxn];int main() { scanf(&quot;%lld&quot;, &amp;T); while(T--) { scanf(&quot;%lld%lld&quot;, &amp;n, &amp;v); memset(w, 0, sizeof(w)); memset(c, 0, sizeof(c)); memset(d, 0, sizeof(d)); for (int i=1;i&lt;=n;++i) scanf(&quot;%lld&quot;, &amp;c[i]); for (int i=1;i&lt;=n;++i) scanf(&quot;%lld&quot;, &amp;w[i]); for (int i=1;i&lt;=n;++i) { for (int j=v;j&gt;=w[i];--j) { d[j] = max(d[j], d[j-w[i]]+c[i]); } } printf(&quot;%lld\\n&quot;, d[v]); } return 0;} HDU - 2084 数塔（DP） 经典入门DP 代码： 123456789101112131415161718192021222324252627#include&lt;iostream&gt; #include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;int n, T;int a[110][110];int d[110][110];void work() { memset(a, 0, sizeof(a)); memset(d, 0, sizeof(d)); scanf(&quot;%d&quot;, &amp;n); for (int i=1;i&lt;=n;++i) { for (int j=1;j&lt;=i;++j) { scanf(&quot;%d&quot;, &amp;a[i][j]); d[i][j] = max(d[i-1][j-1] + a[i][j], d[i-1][j] + a[i][j]); } } int ans = 0; for (int i=1;i&lt;=n;++i) ans = max(ans, d[n][i]); printf(&quot;%d\\n&quot;, ans);}int main() { scanf(&quot;%d&quot;, &amp;T); while(T--) work(); return 0;}","link":"/56657"},{"title":"河南大学暑假集训的日常（4）","text":"DAY7（DP进阶） POJ - 2342 Anniversary party（树形DP） 入门树形DP。 用vector将边存下来，然后将一个点作为树的根节点进行dp，d[x][0]表示编号为x的员工不参加的愉悦值，d[x][1]表示编号为x的员工参加的愉悦值。v节点表示x节点所连的边，转移方程为：d[x][1] += d[v][0]; d[x][0] += max(d[v][1], d[v][0]); 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#define endl '\\n'using namespace std;typedef long long ll;const ll maxn = 6010;ll n, u, v;ll d[maxn][2];bool vis[maxn];vector&lt;int&gt; son[maxn];void dfs(int x) { vis[x] = 1; for (int i=0;i&lt;son[x].size();++i) { int v = son[x][i]; if (!vis[v]) { dfs(v); d[x][1] += d[v][0]; d[x][0] += max(d[v][1], d[v][0]); } }}int main() { while(cin &gt;&gt; n) { memset(d, 0, sizeof(d)); memset(vis, 0, sizeof(vis)); for (int i=1;i&lt;=n;++i) { cin &gt;&gt; d[i][1]; d[i][0] = 0; son[i].clear(); } while(cin &gt;&gt; u &gt;&gt; v &amp;&amp; !(u == 0 &amp;&amp; v == 0)) { son[u].push_back(v); son[v].push_back(u); } dfs(1); cout &lt;&lt; max(d[1][0], d[1][1]) &lt;&lt; endl; } return 0;} LibreOJ - 10156 战略游戏（树形DP） 和上一道题很像，d[x][0]表示x站点处没有哨兵所需要的消耗，d[x][1]表示x站点处有哨兵所需要的消耗。转移方程做了一点小小的改动： d[x][0] += d[v][1]; d[x][1] += min(d[v][1], d[v][0]); 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#define endl '\\n'using namespace std;typedef long long ll;const ll maxn = 6010;ll n, u, v, k;ll d[maxn][2];bool vis[maxn];vector&lt;int&gt; son[maxn];void dfs(int x) { vis[x] = 1; for (int i=0;i&lt;son[x].size();++i) { int v = son[x][i]; if (!vis[v]) { dfs(v); d[x][0] += d[v][1]; d[x][1] += min(d[v][1], d[v][0]); } }}int main() { while(cin &gt;&gt; n) { memset(d, 0, sizeof(d)); memset(vis, 0, sizeof(vis)); for (int i=1;i&lt;=n;++i) { cin &gt;&gt; u &gt;&gt; k; d[u][1] = 1; d[u][0] = 0; for (int i=1;i&lt;=k;++i) { cin &gt;&gt; v; son[u].push_back(v); son[v].push_back(u); } } dfs(0); cout &lt;&lt; min(d[0][0], d[0][1]) &lt;&lt; endl; } return 0;}","link":"/43344"},{"title":"深度学习初探","text":"暑假学习深度学习课程的一些小小总结 二分分类什么是Logistic 回归？logistic 回归函数：来对一组输入做一个 0 ~ 1 的概率判断。 x为输入的特征向量，得到的回归函数值为 sigma(w^(T) * x + b) ，参数为w和b，是一个在0和1中间的一个概率。sigma(z) 是 1 / 1 + e ^ (- z) 。 损失函数：lost(y^, y) = - ( y log y^ + (1 - y) log(1 - y^) ) （其中y^为y的预测值）。越小越好。 成本函数：J(w, b) = 1 / m * Σ lost(y^, y) = -1 / m * Σ(y log y^ + (1 - y)log(1 - y^)) 。为m组损失函数的平均值，越小越好。 梯度下降法：w := w - αd(J(w, b)) / d(w) ，b := b - αd(J(w, b)) / d(b) 。α是学习率。 梯度就是函数对变量的偏导。 正向传播：用参数计算出函数的值 反向传播：利用函数来计算每一个参数的导数 对Logistic 回归的一组数据进行梯度下降法： Logistic 回归的Python实现对Logistic 回归的m组数据进行一次梯度下降法： 123456789101112131415J = 0; dw1 = 0; dw2 = 0; db = 0;for i = 1 to m z(i) = wx(i)+b; a(i) = sigmoid(z(i)); J += -[y(i)log(a(i))+(1-y(i)）log(1-a(i)); dz(i) = a(i)-y(i); dw1 += x1(i)dz(i); dw2 += x2(i)dz(i); db += dz(i);J /= m;dw1 /= m;dw2 /= m;db /= m;w = w - alpha * dwb = b - alpha * db 如何减少循环的次数？使用向量化来减少显式For循环。 12345678910111213141516171819import numpy as np #导入numpy库a = np.array([1,2,3,4]) #创建一个数据aprint(a)import time #导入时间库a = np.random.rand(1000000)b = np.random.rand(1000000) #通过round随机得到两个一百万维度的数组tic = time.time() #现在测量一下当前时间#向量化的版本c = np.dot(a,b) #对a，b进行矩阵乘法toc = time.time()print(“Vectorized version:” + str(1000*(toc-tic)) +”ms”) #打印一下向量化的版本的时间#继续增加非向量化的版本c = 0tic = time.time()for i in range(1000000): c += a[i]*b[i]toc = time.time()print(c)print(“For loop:” + str(1000*(toc-tic)) + “ms”)#打印for循环的版本的时间 通过使用numpy中的函数来进行向量运算从而减少显式For循环。 可以使用向量化完全消除显式的For循环： 1234567Z = np.dot(w.T, x)+bA = σ(Z)dZ = A − Ydw = 1 / m ∗ X ∗ dZ.Tdb = 1 / m ∗ np.sum(dZ)w = w − α ∗ dwb = b − α ∗ db 现在我们利用前五个公式完成了前向和后向传播，也实现了对所有训练样本进行预测和求导，再利用后两个公式，梯度下降更新参数。我们的目的是不使用for循环，所以我们就通过一次迭代实现一次梯度下降，但如果你希望多次迭代进行梯度下降，那么仍然需要for循环，放在最外层。不过我们还是觉得一次迭代就进行一次梯度下降，避免使用任何循环比较舒服一些。 学习进度：吴恩达深度学习课程第一课前两周课（24节） 浅层神经网络什么是双层神经网络？神经网络的大致组成：输入层，隐藏层，输出层。 logistic 回归只有输入层和输出层。 双层神经网络的两层是指隐藏层和输出层，输入层不算。（也可以叫单隐层神经网络） 上图是一个双层神经网络的示意图。 对比一般的Logistic 回归，对于一组输入来说，双层神经网络有多个a在第一层的输出到第二层去。在输出层中，输入是隐藏层中运算得到的a值，输出是经过Logistic 回归得到的最终值。 上图是隐藏层中一个神经元的具体构造。 同时我们也希望可以将这个双层神经网络进行向量化从而来简化我们的运算。 如何将双层神经网络进行向量化？ 该图将一组数据进行了向量化，通过上图的运算，可以更快地得出一组数据经过一次双层神经网络处理的结果。 如图的操作可以将多组数据进行向量化运算，即，经过一次操作对多组输入进行一次双层神行网络处理。 如何选择激活函数？常见的激活分类有：σ函数，tanh函数，ReUL函数，Leaky Relu函数。 对于tanh函数，是由σ函数向下平移和伸缩后得到的。相比于σ函数，数据的平均值更接近0，这会使下一层学习简单一点。 选用适合的激活函数可以加快机器学习的速度，常用的Relu函数的优点如下： 第一，在 z 的区间变动很大的情况下，激活函数的导数或者激活函数的斜率都会远大于0，在程序实现就是一个if-else语句，而sigmoid函数需要进行浮点四则运算，在实践中，使用ReLu激活函数神经网络通常会比使用sigmoid或者tanh激活函数学习的更快。 第二，sigmoid和tanh函数的导数在正负饱和区的梯度都会接近于0，这会造成梯度弥散，而Relu和Leaky ReLu函数大于0部分都为常数，不会产生梯度弥散现象。(同时应该注意到的是，Relu进入负半区的时候，梯度为0，神经元此时不会训练，产生所谓的稀疏性，而Leaky ReLu不会有这问题) z 在ReLu的梯度一半都是0，但是，有足够的隐藏层使得z值大于0，所以对大多数的训练数据来说学习过程仍然可以很快。 概括一下不同激活函数的过程和结论： sigmoid激活函数：除了输出层是一个二分类问题基本不会用它。 tanh激活函数：tanh是非常优秀的，几乎适合所有场合。 ReLu激活函数：最常用的默认函数，，如果不确定用哪个激活函数，就使用ReLu或者Leaky ReLu。公式 a = max( 0.01 z , z ) 为什么常数是0.01？当然，可以为学习算法选择不同的参数。（注意ReLu函数是非线性的） 注意：在选择激活函数的时候，要选择非线性函数，因为多层线性函数的组合得到的结果还是线性的，那么神经网络只是把输入线性组合再输出。只有在做机器学习中的回归问题的时候才可能会选择线性函数作为激活函数。 激活函数的导数对于常见的几种激活函数的导数： sigmoid函数 **σ(x) = a 的导数为 **a (1 - a) tanh函数 tanh(x) = a 的导数为 1 - a^2 Relu函数 max(0, x) = a 的导数在 x &lt; 0 的时候为0， 在 x &gt; 0 的时候为1，在 x = 0 的时候没有定义，一般手动定义为 0 或者 1 。 Leaky Relu函数 max(0,01x, x) = a 的导数在 x &lt; 0 的时候为 0,01 ， 在 x &gt; 0 的时候为1，在 x = 0 的时候没有定义，一般手动定义为 0 或者 1 。 双层神经网络的梯度下降法（反向传播的实现）由以上学习可知双层神经网络的正向传播就是按照所给的基本公式进行计算，而反向传播可以在每一轮中对模型中的参数进行调整。 反向传播与普通Logistic回归不同的地方在于计算第一层的dz时的差别。 这里np.sum是python的numpy命令，axis=1表示水平相加求和，keepdims是防止python输出那些古怪的秩数 ( n , )，加上这个确保矩阵 db[ 2 ] 这个向量输出的维度为 ( n , 1 ) 这样标准的形式。 随机初始化为什么在Logistic回归中不能将W数组的初始化定为0？ 因为这样的话在第一层中的神经元就会计算出相同的结果，这样","link":"/25262"},{"title":"竞赛算法复习笔记","text":"树与图邻接表用head数组为表头，使用ver和edge数组分别存储边的终点和权值，用next数组模拟链表指针。 在一个图中添加一个从x到y边的权值为z的有向边： 123456int head[maxn &lt;&lt; 2], ver[maxn], edge[maxn], next[maxn &lt;&lt; 2];int tot;//tot表示边的编号 inline void adde(int x, int y, int z) { ver[++tot] = y; next[tot] = head[x]; //这句话表示原来x指向的所有边都挂到tot这条新的边的后面。 head[x] = tot; edge[tot] = z;//这句话表示在x原来指向的tot边的前面插入了新来的这个边。 } 图从x访问所有x相连的点。 12345void serch() { for (int i = head[x]; i; i = next[i]) { //从x的最后输入的那条边开始，便利所有x为出发点的边。next数组是为指出x出发的每一条边之间的关系。 }} 图从x的一个深度优先遍历。 12345678910bool v[maxn];void dfs(int x) { v[x] = 1; for (int i=head[x]; i; i = next[i]) { int y = ver[i]; if (v[y]) continue; dfs(y); }}//这个搜索的时间复杂度是O(n+m)。 树的dfs序。 12345678910void int(x) { a[++m] = x; v[x] = 1; for (int i = head[x]; i; i = next[i]) { int y = ver[i]; if(v[y]) continue; dfs(y); } a[++m] = x;} 树的深度。 1234567891011int d[maxn];void dfs(int x) { v[x] = 1; for(int i = head[x]; i; i = next[i]) { int y = ver[i]; if(v[y]) continue; d[y] = d[x] + 1; dfs(y); }}//d[i]中储存的是编号为i的节点从根节点往下的深度。 树的重心。 定义：设max_part(x)表示再删除节点x后产生的子树中，最大的一颗的大小。是max_part函数取到最小值的节点p就成为整棵树的重心。下面的代码我们可以统计出size数组，并且找到这棵树的重心。 1234567891011121314151617int size[maxn];void dfs(int x) { v[x] = 1; size[x] = 1; int max_part = 0;//删掉子树x之后分成的若干个子树中最大的那个的大小 for (int i=head[x];i;i=next[i]) { int y = ver[i]; if (v[y]) continue; dfs(y); size[x] += size[y];//从子节点向上更新 max_part = max(max_part, size[y]);//x的子节点中最大的那个节点的size } max_part = max(max_part, n - size[x]);//现在max_part中储存的是删掉x之后形成的若干个子树中最大的那个大小 if (max_part &lt; ans) { ans = max_part; pos = x;//pos中储存的就是这个树的重心的节点号。 } } 图的连通块的划分 1234567891011121314int cnt;void dfs(int x) { v[x] = cnt; for (int i=head[x];i;i=next[i]) { int y = ver[i]; if (v[y]) continue; dfs(y); }}for (int i=1;i&lt;=n;++i) { if(v[i]) continue; cnt++; dfs(i);}//cnt值相同的节点在同一个连通块中，cnt值表示连通块的个数。 图的广度优先遍历按照层级进行遍历。 1234567891011121314void bfs() { memset(d, 0, sizeof(d));//d中存储的是每一个节点的深度。 queue&lt;int&gt; q; q.push(1);d[1] = 1; while(q.size()) { int x = q.front(); q.pop(); for (int i=head[x];i;i=next[i]) { int y = ver[i]; if (d[y]) continue; d[y] = d[x] + 1; q.push(y); } }} 拓扑排序这个算法可以判断是否存在环：如果cnt和n不相等的话，那么存在环，因为环中的每一个点的入度都不可能为0。 12345678910111213141516171819202122232425262728293031int deg[maxn];void add(int x, int y, int z) { ver[++tot] = y; next[tot] = head[x]; head[x] = tot; edge[tot] = z; deg[y]++;}void topsort() { queue&lt;int&gt; q; for (int i=1;i&lt;=n;++i) if (deg[i] == 0) q.push(i);//如果点的入度为0那么将这个点入队。 while(q.size()) { int x = q.front(); q.pop(); a[++cnt] = x;//将入度为0的那个点输出。 for (int i=head[x];i;i=next[i]) { int y = ver[i]; if (--deg[y] == 0) q.push(y); } }}int main() { cin &gt;&gt; n &gt;&gt; m; for (int i=1;i&lt;=m;++i) { int x, y; cin &gt;&gt; x &gt;&gt; y; adde(x, y, 0); } topsort(); for (int i=1;i&lt;=cnt;++i) { cout &lt;&lt; a[i] &lt;&lt; ' '; }}","link":"/50622"},{"title":"第八届“图灵杯”NEUQ-ACM程序设计竞赛个人赛（同步赛）总结 + 补题","text":"第八届“图灵杯”NEUQ-ACM程序设计竞赛个人赛（同步赛）总结 + 补题 A题 切蛋糕题目链接 ：https://ac.nowcoder.com/acm/contest/11746/A基本思路是将1/k进行二进制拆分，比如说对于k=5，1 / 5 的二进制为 0.001100110011，则应存在5份大小为0.001的蛋糕，5份大小为0.0001的蛋糕，以此类推。（看到2的几次方相加就应该想到二进制拆分）代码不会写Orz，还不会实现，先留着之后补。 B题 小宝的幸运数组题目链接 ：https://ac.nowcoder.com/acm/contest/11746/B题目的思路大概是一个同余的相互跳的一个搜索之类的东西，很巧妙。 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 10;typedef long long ll;ll T, n, k, ans, sum, t;ll head[maxn];int main() { for (scanf(&quot;%ld&quot;, &amp;T);T;T--) {//学来的多组处理 scanf(&quot;%ld%ld&quot;, &amp;n, &amp;k); ans = sum = 0; for (int i=0;i&lt;=k;++i) head[i] = -1;//head[x]表示的是第一次出现总和加到一起的余数为x的时候的a的位置是多少。这样可以一边加一边处理，如果某个数加到总和上之后和之前第一次的余数对应上了，说明这之间的数字的和可以被K整除。 head[0] = 0;//显然对于余数为0来说，不需要有数字加上就行。 for (int i=1;i&lt;=n;++i) { scanf(&quot;%ld&quot;, &amp;t); sum = (sum + t) % k;//维持一个加上当前值然后在k里的一个特征值。 if (head[sum] != -1) ans = max(ans, i - head[sum]);//维护答案 else head[sum] = i;//如果第一次出现的话就保存位置 } ans = ans == 0 ? -1 : ans; printf(&quot;%ld\\n&quot;, ans); } return 0;} C题 上进的凡凡这道题的思路是：一个非降序数组的所有子串都为非降序，只要把给定数组分为若干个非降序部分（每个部分要尽可能长），然后计算子串数，对于长度为n的数组子串数为 n * (n + 1) / 2，遍历然后相加。思路的正确性：一个非降序数组的所有子串都为非降序串。 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100005;typedef long long ll;ll a[maxn];ll sum, n;int main() { ios :: sync_with_stdio(false); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (ll i = 1,t = 1; i &lt;= n; ) { t = i; t++; while (a[t] &gt;= a[t - 1] &amp;&amp; t &lt;= n) t++; ll ans = t - i; sum += ans * (ans + 1)/2; i = t; } cout &lt;&lt; sum &lt;&lt; endl; return 0;} D Seek the Joker I这题是个：巴什博弈（终于要学新东西了啊）。","link":"/23417"},{"title":"算法竞赛技巧总结","text":"一天一个上分小技巧+一天一个爆零小技巧 一天一个上分小技巧： 如果在用评测机做题的话，可以用当n大于某一值时while(1)来判断数据点的范围，如过范围猜中，这时这个测试点就会T掉，反复多交几次就可以判断出测试点的数据大小了 可以将main函数的返回值类型设为signed，signed和int实质上等价，这时如果需要将全文中的int换为long long时会更加的方便。 swap(a,b)等价于a ^= b ^= a ^= b lowbit(x) = -x&amp;x 写图论的题的时候记得考虑分层图 模运算是满足分配率的，即(a + b) % p = (a % p + b % p) % p;对于减法和乘法同样适用。 在结果对一个数取模的时候注意是否出现了负数，负数取模并不会变成正的。 对于非负整数n，当n为偶数时，n xor 1 等于 n + 1，当n为奇数时，n xor 1 等于 n - 1 __builtin_popcount(i)函数可以计算 i 中在二进制表示下1的个数。 一天一个爆零小技巧： 加法运算符的优先级要高于位移，i + j &gt;&gt; 1会优先运算加法，不需要加括号 vector中的size()方法去减一可能会出错。","link":"/18521"},{"title":"观影小记","text":"2021/4/15《卡尔·拉格斐：孤独的时尚大师》 123456789摘录：博物馆成了一个地方的商店，商店成为了一个地方的博物馆。“我只是想拒绝平庸而已。”感想：法国的文艺记录片，镜头很有冲击力，剪辑感觉很有想法，但是看完这个纪录片之后，并没增加我对卡尔·拉格斐的理解或者认识...像是一个宣传片，又像是一个没有主题和内容的谈话节目。关于卡尔·拉格斐：卡尔·拉格斐（1933年9月10日-2019年2月19日，Karl Lagerfeld），出生于德国汉堡市，德国著名服装设计师。人们称他为“时装界的凯撒大帝”或是“老佛爷”。说起卡尔·拉格斐，脑海里的第一反映永远是Chanel的艺术总监招牌式的表情，佩戴着墨镜，手拿抓扇、脑后拖着辫子，就是这永恒的墨镜白发长辫的人却占领时尚圈制高点。他永远像“吃饱人参”一样精力旺盛，精通德、英、法、意文，妙语连珠，他情迷传统，又憧憬未来，被传媒封为“当代文艺复兴的代表”。 《绣春刀》 12感想：适合一个人啃着鸭脖，喝着啤酒和可乐一个人看的电影。本质上和喝着啤酒和可乐看的足球比赛是一个性质，只不过说足球比赛可能更平淡一些，这个电影的节奏会更快那么一丢丢。 《忠犬八公的故事》 12345我发现一个规律，好的经典电影都喜欢以讲回忆或者故事的方式来推动剧情。比如说《泰坦尼克号》或者《阿甘正传》等等。我觉得以回忆的方式来处理故事之间的人物关系是一个很巧妙的方法，时过境迁，回到现实之后经历过回忆中的故事的主人公留给人们更多的想象了。感想：这部电影是一个好的故事，很完整，很动人。仔细想想还能想出一些故事之外的道理。","link":"/56512"},{"title":"郑州轻工工业20级新生赛","text":"今天是3月14号。 分数：10道题，A了6道题。 今天的题还算比较友好，因为是郑州轻工工业的新生选拔赛，所以题目都比较基础。算是第一次比较正式的完整的参加了一次ACM赛制。感受还是很深的。 首先我这一次的比赛开题顺序是有问题的…. 可以看到榜的记录上我第一道AC是在30分钟左右的时候。本来我对于这套题的认识出现了一点偏差，我本来以为这是一套巨难无比的刷我们威风的一套题。所以拿到题之后，看了前3道题之后觉得整体难度挺高的。就误认为a题就是签到题了。（因为其实a题的思路真的挺直接的。）于是我上来就直接开始莽a题了。但是结果其实很悲惨，由于我菜的一批的代码能力。让我没有很顺利的A掉a题。当我第一遍调完a题之后，时间已经来到了30分钟。心情十分郁闷的我看了眼榜单，发现好像签到题在后面，看完题就知道这场名次一定不太好了。于是赶紧过掉了几道签到题。当我跟随榜单的脚步把几道比较简单的题A掉之后。我的名次就逐渐跟上了第一部队。由于这场比赛允许使用纸质资料，所以这场比赛也不完全是由我独立完成的，一道二位前缀和的题我看了书中的代码。所以这也反映出我的知识点掌握能力还处于看到想到思路但是没法很好实现或者实现细节掌握并不是十分熟练的阶段。这是一个现阶段很大的问题。 列一下这次比赛出现问题的知识点： 博弈论 二位前缀和（不熟练） （这是一个赛后总结帖，补题不在这个帖子上） 列一下这次比赛出现的比赛技巧的问题： 没有使用好acm排名榜单的作用。（跟着大佬做题，大佬开题跟着做就行了） 没有完全理解acm排名的规则（先过水题，这样总时间会少一点。而不是上来无脑肝大题） 写一下最近这段时间的计划： 要开始拾起来之前的算法了，可以看到高中剩下来的老本基本上已经快吃完了，高中是竞赛队员的优势已经不是十分明显了。要考虑如何利用高中时的一些学习思路或者学习习惯来制造现阶段的继续领先了，可以看到20级中有一些学习势头很猛的学生，想要保持持续的领先需要开始真正的努力了。 高中的经验告诉我，可以按照算法竞赛的知识树的顺序进行学习，而且由于大部分的知识其实已经学习过一遍，所以记忆中是有对这些知识点难易程度的排序的。可以知道哪样的学习安排更加适合我。 同时，高中的经验告诉我，要有学长或者自己组专项题组进行专门的强化训练，由于高中阶段的算法竞赛是进行停课集训，所以刷题是在大段的时间中进行的，那样的刷题是连续的，对于知识点的理解也有利于加强。但是在大学首先没有了打断整块的时间进行算法训练，而且也没有了聚在一起的机房的队友可以有一个很好的氛围来督促自己学习算法。集中学习的要素由高中的集中起来，变成了大学的分散来到每一天的零碎时间中。这是对时间安排的更进一步的要求。 我想起来了我在高三时在当时机房一个已经去西安电子科技大学的很厉害的学长，他的id我记得是cdcq。他在高中阶段算法竞赛十分的优秀，拿到了NOI的全国赛铜牌，在高三时放下了竞赛，拾起了文化课。最终去到了西安电子科技大学。在他入学后依然保持着博客的更新，但是我当时十分好奇，在高中阶段十分厉害，常常做并且出省选题的他为什么突然开始写起了基础题，开始写最最基本的板子。在当时的我认为那些板子是我都能看懂的题，这和我对他经常写一些十分复杂的题的印象产生了极大的差异，而且这样的博文持续了很长一段时间，我当时心里想：太可惜了，这么强的一个选手，竟然废掉了。直到现在，我才真正的明白，这是一种什么样的感受。算法竞赛，作为一种竞赛，需要保持长久持续的训练。一旦有一段时间的训练空白期，那将是致命的。他将会毁掉一个职业选手，他可能还存在着操作的意识，但是由于长时间的没有训练，他将不能完成最基本的东西。我觉得职业的体育选手或者电子竞技选手可以是相通的道理。https://www.cnblogs.com/cdcq/这是他的博客，有空我再看看，想一下如何度过这个时期。这将关系我如何更好的走下去。 这其实也在提醒我，把自己当成一个普通的大一竞赛学生，不要有特殊的心理。这种心理会导致眼高手低。会导致不能很好的进步。这是一个很大的阻碍。不要再有优越的心理了，新生的水平其实也已经达到一个水平了，不要到最后自己泯然众人矣。静下心来学习东西吧。 克服自己的心理障碍，现在总有一种感觉，觉得好像学这些已经学习过的东西没有什么意思。但是这部分东西已经忘记，复杂的东西由于这不牢的基础导致并写不了。这是一个恶性循环，而解决这个循环的方法就是沉下来开始学习东西，把那些已经学过的东西再复习一遍，以至于可以熟练掌握。而不是在眼高手低的飘。 这就是这场比赛的总结，所思所想。希望的最后结果要不负我最初的选择吧。","link":"/29692"},{"title":"高数下复习笔记","text":"高数下考试内容的一个小小总结 课本同济大学高等数学第七版下册 高数下总结的知识脑图","link":"/59815"},{"title":"MySql数据库入门","text":"本文包括了MySql数据库SQL语言学习和数据库考试复习笔记两部分 MySql数据库SQL语言学习Create命令12345678910111213141516171819202122232425262728#创建一个数据库create database [database_name]; #创建一个表create table [table_name] ( &lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt; ] [，&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt;] ] … [，&lt;表级完整性约束条件&gt; ] ); #创建一个视图create view &lt;视图名&gt; [(&lt;列名&gt; [，&lt;列名&gt;]…)]asselect [查询内容][WITH CHECK OPTION]；/*子查询不允许含有 order by 和 distinct 语句。视图只是一个表结构，不储存数据。使用视图和使用表的语法基本相同。WITH CHECK OPTION 语句使得插入操作只能插入满足视图的限制条件的元组。*/#创建登录用户 create user [user_name] identified by [user_password]#创建一个普通用户#创建数据库角色create role 'R1'; Grant 命令1234567891011121314#授予某个用户权限Grant &lt;权限&gt;[,&lt;权限&gt;]...[on &lt;对象类型&gt; &lt;对象名&gt;] #对象可以是一个表或者是一个视图，或者是一个数据库to &lt;用户&gt;[,&lt;用户&gt;]with grant option.#with grant option子句表示该权限可以进行传播，否则不能。#grant权限时可以用all表示所有的权限，或者也可以是select等具体的权限。#在进行授权的时候可以具体到某一个列比如说: Grant update(cname) on ...#to的后面也可是一个角色。#将某个角色授予某个用户Grant 'role_name' to [user_name];#这样可以批量修改一类用户的权限。 Revoke命令1234567#收回某个用户的权限Revoke &lt;权限&gt;[,&lt;权限&gt;]...[on&lt;对象类型&gt;&lt;对象名&gt;]From &lt;用户&gt;[,&lt;用户&gt;]...#Revoke权限时可以用all表示收回所有的权限，或者也可以是select等具体的权限。#From的后面也可是一个角色。 Alter命令12345678910111213141516#Alter命令是在建好表后修改表结构时使用的语句。alter table [table_name] add [column_name] [数据类型] [完整性约束] #在表中添加一个新列alter table [table_name] add foreign key([column_name]) references [table_name]([column_name])#在表中添加一外键alter table [table_name] modify column [column_name] &lt;数据类型&gt; [完整性约束]；#修改表中的一列alter table [table_name] drop column [column_name]#删除表中的一列alter table [table_name] drop primary key;#删除表的主键alter table [table_name] drop foreign key [key_name];#删除表的一个外键 Drop命令1234567#Drop命令是删除表或者数据库结构时使用的语句。drop database [database_name]; # 删除一个数据库drop table [table_name]; # 删除一个数据库中的表#注意：如果有外键，不能删除表，应该先删除外键或者先删除外键连接的表。#删除登录用户drop user [user_name] Insert命令12345678910111213141516171819#插入一条元组insert into [table_name]([column_name1], [column_name2] ...)values([column_name1_value], [column_name2_value] ...);#如果table_name后面属性列为空，则默认为定义表时的属性和顺序。#在table_name后面的属性可以自定义顺序。#插入的属性值可以是default, null或者具体的值。#插入子查询的结果insert into [table_name]([column_name1], [column_name2] ...)select ...from ...where ...#插入多条元组insert into [table_name]([column_name1], [column_name2] ...)values([column_name1_value], [column_name2_value] ...),([column_name1_value], [column_name2_value] ...),([column_name1_value], [column_name2_value] ...),... ; Update命令12345#带子查询的修改语句（修改满足条件的元组）update [table_name] set [column_name1] = [column_name1_value]，[column_name2] = [column_name2_value]，where [column_name] = [column_name_value]#在修改值时注意实体完整性和参照完整性。#主码不允许修改，用户定义的完整性，NOT NULL约束，UNIQUE约束，值域约束 Select命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#一个查询语句的基本结构select [all/distinct] &lt;目标列表达式1&gt;, &lt;目标列表达式2&gt;, ... from &lt;table_name1&gt;, &lt;table_name2&gt;, ...where &lt;条件表达式&gt;group by &lt;column_name1&gt; having &lt;条件表达式&gt;order by &lt;column_name1&gt; [asc/desc] limit (num)/*选择表中的若干列*/#如果选中所有的属性列那么用*来表示#DISTINCT关键词消除取值重复的行，如果没有指定，则缺省为ALL #如果要将属性列更名的话在需要更名的列后面加上 as 新名字#在查询语句中还可以自定义表名，方法为 from [table_name] as [new_name]#在定义别名的时候可以省略 as ，但是不建议。#目标列表达式可以为：/*算术表达式 2016 - Sage字符串常量 '出生年份：'函数 year(curdate()) //表示当前的年份列别名 sno as 学号*//*常用的查询条件:比较运算符：=，&gt;，&lt;，&gt;=，&lt;=，!=，&lt;&gt;，!&gt;，!&lt;；确定范围： BETWEEN &lt;..&gt; AND &lt;..&gt;， NOT BETWEEN &lt;..&gt; AND &lt;..&gt;确定集合: IN(...)， NOT IN(...)字符匹配： LIKE ''， NOT LIKE ''通配符： % 任意长度的字符 _ 一个长度的字符 / 将后面紧跟的一个符号转义成正常符号空值： IS NULL， IS NOT NULL多重条件（逻辑运算）: AND，OR，NOT 可以用括号改变优先级*//*ORDER BY子句*/#可以按照一个或者多个属性进行排序#升序：ASC；降序：DESC；缺省值为升序#当排序列含空值时#ASC：排序列为空值的元组最后显示#DESC：排序列为空值的元组最先显示 #e.g. ORDER BY Grade DESC；#e.g. ORDER BY Sdept，Sage DESC； #limit后面跟的数字为输出表中的前几行。/*自然连接*/SELECT Student.*，SC.*FROM Student，SCWHERE Student.Sno = SC.Sno；#将student和sc表将sno相同的元组自然连接然后输出/*聚集函数*/#聚集函数：/*计数 COUNT（[ DISTINCT | ALL ] *） COUNT（[ DISTINCT | ALL ] &lt;列名&gt;）//这两个值在all条件下是相等的计算总和 SUM（[ DISTINCT | ALL ] &lt;列名&gt;） 计算平均值 AVG（[ DISTINCT | ALL ] &lt;列名&gt;）最大最小值 MAX（[ DISTINCT | ALL ] &lt;列名&gt;） MIN（[ DISTINCT | ALL ] &lt;列名&gt;）*//*GROUP BY子句*/#细化聚集函数的作用对象/* 未对查询结果分组，聚集函数将作用于整个查询结果 对查询结果分组后，聚集函数将分别作用于每个组 作用对象是查询的中间结果表 按指定的一列或多列值分组，值相等的为一组*//*Having子句*/#Having短语作用于组，从中选择满足条件的组#Where子句作用于基表或者视图，从中选择满足条件的元组/*ORDER BY子句*/#将结果进行排序之后再输出/*ASC 升序（小的在前面）DESC 降序（大的在前面）缺省为升序order by 后面可以跟多个列名，按照顺序进行排序。*/#当排序存在空值时/*ASC 空值的元组最后显示DESC 空值的元组最先显示*//*limit子句*/#只输出排序结果中的前num个元组。#limit 3 的意思是输出前三行，limit 1,3 的意思是输出2道4行#表中的元组的序号是从0开始的/*Percent子句（！该知识点没有细讲，考试不考）*//*select top &lt;n&gt; percent ...from ...where ...表示输出前半分之n的数据，如果结果不够一条的话会向上取整为一条。*//*into子句（！该知识点没有细讲，考试不考）*//*select * into [table_name] from ...where ...表示将查询结果保存到table_name的表中。*/ Select查询进阶12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/*连接查询*/#将两个表进行自然连接select *from A, bwhere A.a = B.a;#将三个表进行自然连接select *from A, B, Cwhere A.a = B.a and A.a = C.a;#将一个表进行自身连接select A.a, A.pa, B.pafrom table1 as A, table1 as Bwhere A.pa = B.a;/*[例35]查询每一门课的间接先修课（即先修课的先修课），输出：课程号、先修课的课程号、先修课的先修课的课程号。*//*SELECT FIRST.Cno, FIRST.Cpno, SECOND.CpnoFROM Course As FIRST，Course As SECONDWHERE FIRST.Cpno = SECOND.Cno；*/#两个表用inner join来写自然连接select *from A inner join B on (A.a = A.b)where ...#两个表用left outer join来写左外连接select *from A left outer join B on(A.a = B.a)where ...#两个表用right outer join来写右外连接select *from A right outer join B on(A.a = B.a)where ...#嵌套查询/*将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询*/#不相关子查询select *from A where a in ( select a from B where ...);#相关子查询select *from A where a in ( select a from B where A.b = B.b and ... );/*可以进行多层嵌套，当可以确定内层返回为单值的话，in可以用=或者&lt;，&gt;等代替。*/#带有ANY和ALL谓词的子查询select *from Awhere a &gt;= ANY( select a from B where ...);/*ANY表示查询结果中的某个值，ALL表示查询结果中的所有值*/#带有EXISTS谓词的子查询/*存在谓词谓词的查询不返回任何数据，只产生逻辑真值或者逻辑假值，若内层查询为空则返回假，若内层查询为非空则返回为真。EXISTS内层只要有结果，外层对应的记录就输出。NOT EXISTS内层只要没有结果，外层就被输出。*/select *from Awhere exists ( select * from B where ...)#集合查询：交并差查询#Union, Intersect, Except。/**/ Delete命令12345#带查询的删除（删除满足条件的元组）delete from [table_name]where ...#where中的语句格式和select的where一样。 其他常用命令1234567show databases;select database();use [database_name];DESC [table_name];#查看该表的结构select user();#查看当前用户select * from mysql.user #查看所有用户#用户授权 数据类型123456intsmallintchar([num])varchar([num])#变长字符串dateenum(a, b, ...) #枚举类型，值只能是枚举集合中的一个元素 常用约束条件123456789101112131415161718default [val] # 默认值unique # 唯一性约束not null # 非空值约束primary key([column_name],...) # 主码约束foreign key([column_name]) references [table_name]([column_name]) # 外键约束chekc([条件]) # 用户定义auto_increment # 序号自动加一constraint [constraint_name] &lt;限制条件&gt; # 为后面的限制条件起一个名字on delete no action cascade set null#在外键被参照的元组的属性进行删除时进行参照的元组的属性值的变化情况on update no action cascade set null#针对外键被参照的元组的属性进行更新值时进行参照的元组的属性值的变化情况 常用列函数12345Count() #统计某一列的元组数量，某一列的Count运算结果和Count(*)的结果是相等的。Sum() Avg()Max()Min() 数据库考试复习笔记知识点：三类经典的数据模型是：1.层次模型，2.网状模型和3.关系模型。 数据库的保护措施有1.安全性控制，2.完整性控制，3.并发控制和4.数据库恢复等。 事务的四个性质是：1.原子性，2.一致性，3.隔离性，4.持久性。 并发控制的主要方法是封锁，封锁有两种类型：即1.排它锁（X锁，写锁），2.共享锁（S锁，读锁）。 故障恢复的基本手段有：1.数据转储，2.登记日志文件。 数据库设计的步骤有：1.需求分析，2.概念结构设计，3.逻辑结构设计，4.物理设计，5.数据库实施，6.数据库的运行和维护。 并发控制带来的三种数据不一致是：1.丢失数据，2.不可重复读，3.读脏数据。 数据模型的三要素：1.数据结构，2.数据操作和3.数据完整性。数据结构是对数据系统的静态特性的描述，数据操作是对数据库系统的动态特性的描述。 数据库系统的故障：1.系统故障，2.事务故障，3.介质故障，4.计算机病毒。 当局部E-R图合成为全局E-R图时，可能出现冲突：1.属性冲突，2.结构冲突，3.命名冲突。 传统的关系运算：1.交，2.并，3.差，4.笛卡尔积。 专门的关系运算：1.选择，2.投影，3.连接，4.除。 基本运算是：1、并，2、差，3、选择，4、投影，5、乘积（笛卡尔积） 数据库的完整性是指：1.正确性，2.相容性 ， 3.有效性。 一个关系模式的定义主要包括：1、关系名，2、属性名、3、属性类型、4、属性长度、5、关键字。 关系数据库中基于数学上两类运算是1、关系代数、2、关系演算。 数据库是长期存储在计算机内，有1.组织的，2.可共享的数据集合。 数据库管理系统的主要功能有1.数据定义功能，2.数据库的组织存储和管理，3.数据操纵功能，4.数据库的运行管理和5.数据库的建立及维护等。 SQL语言具有1、数据定义、2、数据操纵、3、数据控制的作用。 SQL语言具有两种使用方式，分别为1、交互式SQL和2、嵌入式SQL。 参照完整性是指在基本表中，外码可以是1、空值或者2、另一个关系主码的有效值。 数据冗余可能导致的问题有：1、浪费存储空间及修改麻烦，2.潜在的数据不一致性。 安全性控制的一般方法有：1、用户标识鉴定、2、存取控制、3、审计、4、数据加密。 存取权限包括两方面的内容：1、要存取的数据对象，2、对数据对象进行操作的类型。 DBMS存取控制极值主要包括两部分：1、自主存取控制，2、强制存取控制。 在关系数据库规范化理论中，在执行分解时，必须遵守规范化原则：1、保持原有的依赖关系，和2、无损连接性。 易错点：数据库在磁盘上的基本组织形式是文件。 数据库的概念模型独立于具体的机器和DBMS。 数据库是存储在计算机内有结构的数据的集合。 在数据库中，产生数据不一致的根本原因是：数据冗余。 数据库系统的最大特点是：数据的三级模式和二级映像。 实体与之对应的数据库术语为记录。 层次模型不能直接表示多对多的关系。 数据库奠基人E.F从1970年起发表过多篇论文，主要论述的是关系数据模型。 关系运算中花费时间可能最长的运算是：除 SQL语言是非过程化语言。 SQL是结构化查询语言。 在SQL sever 中删除触发器用 DROP。 关系规范化理论是设计逻辑结构的指南和工具。 对于非规范化的模式，经过使属性域变为简单域转变为1NF，将1NF经过消除非主属性对主关键字的部分依赖转变为2NF，将2NF经过消除非主属性对主关键字的传递依赖转变为3NF。 数据流程图（DFD）是用于描述结构化方法中需求分析阶段的工具。 在数据库设计中，把数据需求携程文档，他是各类数据描述的集合，包括数据项，数据结构，数据流，数据存储和数据加工过程等的表述，通常称为数据字典。 若数据库中质保函成功事务提交的结果，则此数据库就称为处于一致状态。 数据库恢复是将数据库从错误状态恢复到某一已知正确的状态的功能。 数据库系统是利用存储在外村上其他地方的冗余数据来重建被破坏的数据库，他主要有两种：1.后援副本，2、日志文件。 死锁不是并发操作带来的数据不一致性的问题。 事务是用户定义的一个数据库操作序列。 简答：试述视图的作用？ 视图能够简化用户的操作。（1 分） 视图使用户能以多种角度看待同一数据。（1 分） 视图对重构数据库提供了一定程度的逻辑独立性。（1 分） 视图能够对机密数据提供安全保护。（1 分） 登记日志文件时必须遵循什么原则？登记日志文件时必须遵循两条原则： 登记的次序严格按并发事务执行的时间次序。（1 分） 必须先写日志文件，后写数据库。（2 分） 简述系统故障时的数据库恢复策略： 正像扫描日志文件，找出在故障发生前已经提交的事务，将其事务标识记入 REDO队列。同时找出故障发生时尚未完成的事务，将其事务标识记入 UNDO队列。 对 UNDO队列中的各个事务进行撤销处理。 对REDO队列中的各个事务进行重做处理。(错一个扣1.5分，全错不得分) 简述等值连接与自然连接的区别和联系： 连接运算符是“=”的连接运算称为等值连接。它是从关系 R 与 S 的广 义笛卡尔积中选取 A，B 属性值相等的那些元组。自然连接是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是相同的属性组，并且在结果中把重复的属性列去掉。 说明视图与基本表的区别和联系？ 视图是从一个或几个基本表导出的表，它与基本表不同，是一个虚表，数据库中只存放视图的定义，而不存放视图对应的数据，这些数据存放在原来的基本表中，当基本表中的数据发生变化，从视图中查询出的数据也就随之改变。视图一经定义就可以像基本表一样被查询、删除，也可以在一个视图之上再定义新的视图，但是对视图的更新操作有限制 简述事务的特性。 事务具有四个特性，即 ACID 特性： 原子性：事务中包括的所有操作要么都做，要么都不做。 一致性：事务必须使数据库从一个一致性状态变到另一个一致性状态。 隔离性：一个事务内部的操作及使用的数据对并发的其他事务是隔离的。 持续性：事务一旦提交，对数据库的改变是永久的。 试述数据、数据库、数据库管理系统、数据库系统的概念。 数据：描述事物的符号记录。（1 分）数据库：长期存储在计算机内的、有组织的、可共享的数据集合。（1 分）数据库管理系统：是位于用户与操作系统之间的具有数据定义、数据操纵、数据库的运行管理、数据库的建立和维护功能的一层数据管理软件。（1 分）数据库系统：在计算机系统中引入数据库后的系统，一般由数据库、数据库管理系统(及其开发工具)、应用系统、数据库管理员和用户构成。","link":"/51347"},{"title":"Linux系统操作入门","text":"记录学习Linux的一些总结，包括学习鸟哥的Linux私房菜的笔记 其他图形模式与文字模式的切换方式Linux预设提供了六个命令窗口终端机让我们来登录。 默认我们登录的就是第一个窗口，也就是tty1，这个六个窗口分别为tty1,tty2 … tty6，你可以按下Ctrl + Alt + F1 ~ F6 来切换它们。 如果你安装了图形界面，默认情况下是进入图形界面的，此时你就可以按Ctrl + Alt + F1 ~ F6来进入其中一个命令窗口界面。 当你进入命令窗口界面后再返回图形界面只要按下Ctrl + Alt + F7 就回来了。 Linux 关机在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。 正确的关机流程为：sync &gt; shutdown &gt; reboot &gt; halt 关机指令为：shutdown ，你可以man shutdown 来看一下帮助文档。 例如你可以运行如下命令关机： 12345678910111213141516171819sync 将数据由内存同步到硬盘中。shutdown 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：shutdown –h 10 ‘This server will shutdown after 10 mins’ 这个命令告诉大家，计算机将在10分钟后关机，并且会显示在登陆用户的当前屏幕中。shutdown –h now 立马关机shutdown –h 20:25 系统会在今天20:25关机shutdown –h +10 十分钟后关机shutdown –r now 系统立马重启shutdown –r +10 系统十分钟后重启reboot 就是重启，等同于 shutdown –r nowhalt 关闭系统，等同于shutdown –h now 和 poweroff 最后总结一下，不管是重启系统还是关闭系统，首先要运行 sync 命令，把内存中的数据写到磁盘中。 关机的命令有 shutdown –h now halt poweroff 和 init 0 , 重启系统的命令有 shutdown –r now reboot init 6。 处理目录的常用命令接下来我们就来看几个常见的处理目录的命令吧： ls（英文全拼：list files）: 列出目录及文件名 cd（英文全拼：change directory）：切换目录 pwd（英文全拼：print work directory）：显示目前的目录 mkdir（英文全拼：make directory）：创建一个新的目录 rmdir（英文全拼：remove directory）：删除一个空的目录 cp（英文全拼：copy file）: 复制文件或目录 rm（英文全拼：remove）: 删除文件或目录 mv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称 你可以使用 man [命令] 来查看各个命令的使用文档，如 ：man cp。 ls (列出目录)在Linux系统当中， ls 命令可能是最常被运行的。 语法： 123[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称[root@www ~]# ls [--color={never,auto,always}] 目录名称[root@www ~]# ls [--full-time] 目录名称 选项与参数： -a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用) -d ：仅列出目录本身，而不是列出目录内的文件数据(常用) -l ：长数据串列出，包含文件的属性与权限等等数据；(常用) 将家目录下的所有文件列出来(含属性与隐藏档) 1[root@www ~]# ls -al ~ cd (切换目录)cd是Change Directory的缩写，这是用来变换工作目录的命令。 语法： 123456789101112131415 cd [相对路径或绝对路径]#使用 mkdir 命令创建 runoob 目录[root@www ~]# mkdir runoob#使用绝对路径切换到 runoob 目录[root@www ~]# cd /root/runoob/#使用相对路径切换到 runoob 目录[root@www ~]# cd ./runoob/# 表示回到自己的家目录，亦即是 /root 这个目录[root@www runoob]# cd ~# 表示去到目前的上一级目录，亦即是 /root 的上一级目录的意思；[root@www ~]# cd .. pwd (显示目前所在的目录)pwd 是 Print Working Directory 的缩写，也就是显示目前所在目录的命令。 1[root@www ~]# pwd [-P] 选项与参数： -P ：显示出确实的路径，而非使用连结 (link) 路径。 实例：单纯显示出目前的工作目录： 12[root@www ~]# pwd/root &lt;== 显示出目录啦～ 实例显示出实际的工作目录，而非连结档本身的目录名而已。 123456789[root@www ~]# cd /var/mail &lt;==注意，/var/mail是一个连结档[root@www mail]# pwd/var/mail &lt;==列出目前的工作目录[root@www mail]# pwd -P/var/spool/mail &lt;==怎么回事？有没有加 -P 差很多～[root@www mail]# ls -ld /var/maillrwxrwxrwx 1 root root 10 Sep 4 17:54 /var/mail -&gt; spool/mail# 看到这里应该知道为啥了吧？因为 /var/mail 是连结档，连结到 /var/spool/mail # 所以，加上 pwd -P 的选项后，会不以连结档的数据显示，而是显示正确的完整路径啊！ mkdir (创建新目录)如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。 语法： 1mkdir [-mp] 目录名称 选项与参数： -m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～ -p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！ 实例：请到/tmp底下尝试创建数个新目录看看： 123456[root@www ~]# cd /tmp[root@www tmp]# mkdir test &lt;==创建一名为 test 的新目录[root@www tmp]# mkdir test1/test2/test3/test4mkdir: cannot create directory `test1/test2/test3/test4': No such file or directory &lt;== 没办法直接创建此目录啊！[root@www tmp]# mkdir -p test1/test2/test3/test4 加了这个 -p 的选项，可以自行帮你创建多层目录！ 实例：创建权限为 rwx–x–x 的目录。 12345[root@www tmp]# mkdir -m 711 test2[root@www tmp]# ls -ldrwxr-xr-x 3 root root 4096 Jul 18 12:50 testdrwxr-xr-x 3 root root 4096 Jul 18 12:53 test1drwx--x--x 2 root root 4096 Jul 18 12:54 test2 上面的权限部分，如果没有加上 -m 来强制配置属性，系统会使用默认属性。 如果我们使用 -m ，如上例我们给予 -m 711 来给予新的目录 drwx–x–x 的权限。 rmdir (删除空的目录)语法： 1rmdir [-p] 目录名称 选项与参数： -p ：连同上一级『空的』目录也一起删除 删除 runoob 目录 1[root@www tmp]# rmdir runoob/ 将 mkdir 实例中创建的目录(/tmp 底下)删除掉！ 12345678910[root@www tmp]# ls -l &lt;==看看有多少目录存在？drwxr-xr-x 3 root root 4096 Jul 18 12:50 testdrwxr-xr-x 3 root root 4096 Jul 18 12:53 test1drwx--x--x 2 root root 4096 Jul 18 12:54 test2[root@www tmp]# rmdir test &lt;==可直接删除掉，没问题[root@www tmp]# rmdir test1 &lt;==因为尚有内容，所以无法删除！rmdir: `test1': Directory not empty[root@www tmp]# rmdir -p test1/test2/test3/test4[root@www tmp]# ls -l &lt;==您看看，底下的输出中test与test1不见了！drwx--x--x 2 root root 4096 Jul 18 12:54 test2 利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 一次删除。 不过要注意的是，这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录。 cp (复制文件或目录)cp 即拷贝文件和目录。 语法: 12[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)[root@www ~]# cp [options] source1 source2 source3 .... directory 选项与参数： -a：相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用) -d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身； -f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次； -i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用) -l：进行硬式连结(hard link)的连结档创建，而非复制文件本身； -p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)； -r：递归持续复制，用於目录的复制行为；(常用) -s：复制成为符号连结档 (symbolic link)，亦即『捷径』文件； -u：若 destination 比 source 旧才升级 destination ！ 用 root 身份，将 root 目录下的 .bashrc 复制到 /tmp 下，并命名为 bashrc 123[root@www ~]# cp ~/.bashrc /tmp/bashrc[root@www ~]# cp -i ~/.bashrc /tmp/bashrccp: overwrite `/tmp/bashrc'? n &lt;==n不覆盖，y为覆盖 鸟哥的Linux私房菜第四章文章链接 Ctrl + Shift + F1 ~ F6 切换6个终端 date 显示当前时间 locale 显示当前支持的语系 cal 显示日历 ​ cal + 年份 显示该年份的日历 bc 简单的计算器小程序 ​ bc仅支持+ - * / ^ %运算 nano 一个很简单的文本编辑程序，后面加上文件名即可进行编辑。 Ctrl + C 强制退出 Ctrl + D 表示EOF或者exit Tab 按两下自动补全 sync 将内存中的内容转存在硬盘中 ​ 在关机之前记得多使用几次这个命令，防止内容的丢失 shutdown 为关机指令 reboot 为重启指令 第五章文章链接 用户分为自己，自己所在群组，其他人三种。 su - 切换为root账户，密码为安装系统时创建的账户的密码 ls -al 显示当前文件夹下的所有文件 第一个字符可能为d，-，l，b，c。分别表示文件夹，文件，连接档（类似windows里面的快捷方式），周边设备（随机存储设备），键盘鼠标（一次性存储设备） 后面三个字母一组表示每类用户的权限，r表示可读，w表示可写，x表示可执行。三组分别为：拥有者，群组内成员，非本人且没有加入本群组之外的账户。 一串字母之后的一个数字是连接数，后面的两个分别是拥有者和拥有者所加入的群组。最后名字前面的是最后修改的时间，在前面一个数字是该文件的大小bytes。 如果一个目录d的权限没有x的话就不能进入该目录。 root无视所有的规则。 ls - l 查看最近修改的记录 chgrp 更改指定文件的群组。e.g. chgrp users test.txt chown 更改指定文件的拥有者，e.g. chown bin test.txt e.g. chown root:root test.txt cp 对指定文件进行拷贝。e.g. cp test.txt test2.txt chmod 更改文件的权限，r的权限对应的值是4，w是2，x是1，对于每个类型的用户的权限就是这些权值相加。e.g. chmod 777 test.txt ​ 很巧妙的是，这个值唯一对应一种权限的组合。 chmod 的另一种方法e.g. chmod u=rwx,go=rx test.txt u表示拥有者，g表示群组，o表示其他人，a表示所有类型。 文件是否能执行和后缀名无关，和是否有x的权限有关。文件的w权限是指可以修改文件的内容，但是不包括删除该文件。 在有w权限的文件夹下是可以删除没有w权限的文件。 常见的后缀名有：*.sh表示为脚本或者批处理文件，*Z *.tar *.tar.gz *.zip *.tgz表示压缩包文件 *.html *.php表示网络相关的文件。文件是否可以执行和后缀名没有关系，只和这个文件的x权限有关。 Linux的文件系统依据：FHS 网页中有一些关于Linux根目录下目录的主要含义的解释。 目录树的简单示意图。 绝对路径和相对路径：以根目录/开头的路径都是绝对路径，反之则为相对路径，相对路径是指当前所在路径的相对位置来定义的。 . ./都表示当前目录 .. ../都表示上一级目录 使用 uname -r 查看核心版本 使用 uname -a 查看操作系统的版本 第六章文章链接 Linux中根目录中也有./和../目录，并且 ./ 目录和 ../目录是同一个目录。 cd 表示切换目录。几个比较特殊的目录在上面的图片上都可以看出。 pwd表示显示当前的目录。pwd -P表示显示文档的实际地址，对于一些快捷方式的地址会发生区别。 mkdir表示建立一个新目录。e.g. mkdir -p test1/test2/test3/test4会依次建立目录 e.g. mkdir -m711 test2会建立一个test2目录并且权限为711。 ​ 一般情况下建立目录需要一层一层建立，加上-p选项可以将所有的目录都按照顺序依次建立起来，而且如果本来目录存在的情况下，系统不会提示错误信息。（不建议，如果出错很麻烦）。 rmdir删除空目录。e.g. rmdir -p test1/test2/test3/test4该命令只能一层一层删除目录，加上-p可以一次性全部删除，该命令删除的目录中必须不能有别的文档或者目录，如果想要带里面的文件一起删除的话可以使用rm -r test命令来删除，（不过比较危险）。 输入exit或者按Ctrl + D可以退出已经登录的root账户 echo $PATH可以显示当前用户的PATH路径都有哪些。在使用指令的时候会优先在PATH的路径下寻找可执行文件，如果有多个重名文件的话会优先使用先搜索到的文件。 PATH=&quot;${PATH}:/root&quot;可以将/root加入到PATH路径中。 ​ 为了安全起见不要将 . 加入PATH中。 在Bash Shell中ls -l 可以简写为ll cp表示copy，即对文件进行复制和粘贴。 ​ 其中-i选项表示如果出现覆盖先进行询问。-a表示复制的文件的群组和时间都和原文件一样。-l表示创建一个实体链接。-s表示创建一个符号链接，即产生了源文件的一个捷径。-d表示如果复制的文件为一个捷径文件的话复制该捷径，因为cp直接复制一个捷径的话会复制源文件。cp指令可以将多个资料一次复制到一个目录中去，但是最前面一定是目录。 rm表示remove，即移除目录或者文档。 ​ 其中大部分的发行版Linux都默认rm带上了-i参数，-r很危险，同时不要将文件起名为-aaa-这种类型，因为如果这时想要删除这个文件的时候，就会报错，因为会优先检测出-a这个选项，所以文件起名一般不要用-开头。 mv表示move，即移动文件或者目录。 ​ 可以使用mv来对一个文件进行更名的操作。 cat用来显示文档内的内容。-n选项用来带行号输出，-A用来显示所有的特殊字符和正常字符。 tac是cat命令的反着输出的版本，从最后一行到第一行输出。 nl命令用来带行号输出文件的内容。-b a选项用来将空白行也带上行号。-b a -n rz用来将空白行带上行号之后再前面补零。-b a -n rz -w 3用来将空白行带上行号之后再前面补零,并且规定零加上数字一共宽度为三。 more命令用来可以翻页的查看一个文档。 进入more一个文档之后的一些操作如上图。对文档内的字符串进行/查找之后按n查看下一个查找到的字符串。 less命令也是可以翻页查看一个文档，功能比more更加的强大。 head命令用来取出前面的几行。 在不加上-n选项的时候默认输出一个文件的前10行，加上-n选项可以自定义输出文件的前几行，值得注意的是，如果-n后面跟的是一个负数，表示的是这些行不输出，比如-n -100表示前100行不输出，从100行之后的所有行全部输出。 tail命令用来取出文件的后面几行。 -n的使用和head大致相同，一个比较好玩的是 -n +100表示100行之后的所有行都输出。-f选项用来持续检测这个文件，如果一个文件一直在进行写入操作，那么会持续的输出这个文件新加入的行，直到按下Ctrl + C后结束检测。 head和tail的组合使用可以输出11 ~ 20 行：head -n 20 /etc/man_db.conf | tail -n 10 |表示将前面执行的结果交给后面接着执行。 在上面的基础上再加上cat可以输出正确的11~20行的行号：cat -n /etc/man_db.conf | head -n 20 | tail -n 10 od命令是针对那些非文字文档的一个命令。 对于一些 data file 或者 binary file 可以使用od命令使这些文件以ASCII码的形式输出出来。 我们可以利用这个命令来对已有的字符串输出对应的八进制ASCII码：echo password | od -t oCc 使用ls的--time选项来查看每个文件的不同类型的时间。 使用touch命令可以：1.建立一个空白的文档。2.将一个文档的时间修改为某一个特定的时间。 umask命令可以查看当前用户创建的文档或者目录的预设权限。 输入umask输出的一串数字从第二个到第四个分别表示user，group，other三种用户被拿掉的权限的权值的和。比如4表示读，2表示写，5表示读和执行。 命令umask 002表示将该用户创建文件的预设权限设置为仅为other的用户不能写。 一般root用户将umask设置为022，因为是出于安全的考虑。 chattr命令表示设置文件或者目录的隐藏属性 chattr +i attrtest表示给attrtest文件加上锁定的隐藏属性，用chattr -i attrtest来取消该隐藏属性。 lsattr命令用来查看一个文件或者目录的隐藏属性。 SUID（Set UID）是一个特殊的权限，可以让非root用户暂时使用root命令。 SUID是在原本user的x权限的位置上标为s，此时权限表示为SUID。 下图为SUID的限制于功能： 而且需要注意的是SUID只可以用在binary program上，并不能用于shell script。 SGID（Set GID）是指在群组的x权限的位置上标为s的一个权限。 SGID对于可执行文件的限制于功能为下图： SGID对于目录的限制于功能为下图： SBIT 只能对目录有作用。 4，2, 1分别表示这三个隐藏权限的权值。在chmod的第一个值中表示该文件的隐藏权限属性值。使用：chmod 4755 test可以设置test的隐藏权限。 上图是使用文字的方式添加文件的隐藏属性。 fail命令来查看改文件的基本资料，是ASCII文件还是date文件或者可执行文件的一些细节。 which命令用来寻找命令的完整路径。 which会根据PATH的路径来依次寻找命令所在的地址。 whereis命令是用于在一些特定目录中寻找档案名。 locate命令用来通过关键字在自建的数据库中搜索带有该关键字的文件。 locate使用的是由已建立的資料庫 /var/lib/mlocate/里面的资料所搜到的，该数据库默认每天更新一次，所以如果没有更新的话就可能搜索不到，这时就可以进行手动更新。 updatedb命令会搜索硬盘中的文档的名称并且更新资料库中的档案。 find命令用来查找文件。","link":"/11830"},{"title":"SSM入门","text":"Java_SSM入门 参考课程：黑马程序员2022最新SSM框架教程 Spring学习预备为什么要学 使用Spring技术JavaEE开发，企业开发技术选型命中率&gt;90% 专业角度 简化开发，降低企业级开发的复杂性 框架整合，高效整合其他技术，提高企业级应用开发与运行效率 学什么 简化开发 IoC AOP 事务处理 框架整合 MyBatis MyBatis-plus Struts Struts2 Hibernate …… 怎么学 学习Spring框架设计思想 学习基础操作，思考操作与思想之间的联系 学习案例，熟练应用操作的同时，体会思想 初识Spring 官网：https://spring.io/ Spring形成了一种开发生态圈，Spring提供了若干个项目，每个项目用于完成特定的功能 Spring Framework Spring Boot Spring Cloud Spring发展史 Spring FrameworkSpring Framework系统架构 Spring Framework是Spring生态圈中最基础的项目，是其他项目的根基 Spring Framework系统架构图： Data Access：数据访问 Data Integration：数据集成 Web：Web开发 AOP：面向切面编程 Aspects：AOP思想实现 Core Container：核心容器 Test：单元测试与集成测试 Spring Framework学习路线 第一部分：核心容器 核心概念（Ioc/DI） 容器基本操作 第二部分：整合 整合数据层技术MyBatis 第三部分：AOP 核心概念 AOP基础操作 AOP实用开发 第四部分：事务 事务实用开发 核心容器的核心概念 代码书写现状 耦合度偏高 解决方案 使用对象时，在程序中不要主动使用new产生对象，转换为由外部提供对象 IoC（Inversion of Control）控制翻转 对象的创建控制权由程序转移到外部，这种思想称为控制反转 目的：解耦 Spring技术对Ioc思想进行了实现 Spring提供了一个容器，称为Ioc容器，用来充当Ioc思想中的“外部” Ioc容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在IoC中统称为Bean DI（Dependency Injection）依赖注入 在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入 目标：充分解耦 使用IoC容器管理bean（IoC） 在IoC容器内将有依赖关系的bean进行关系绑定（DI） 最终效果 使用对象时不仅可以直接从IoC容器中获取，并且获取到的bean已经绑定了所有的依赖关系 IoC入门案例思路分析 管理什么？（Service与Dao） 如何将被管理的对象告知IoC容器？（配置） 被管理的对象交给IoC容器，如何获取到IoC容器？（接口） IoC容器得到后，如何从容器中获取bean？（接口方法） 使用Spring导入哪些坐标？（pom.xml） IoC入门案例（XML版） 导入Spring坐标 定义Spring管理的类（接口） 创建Spring配置文件，配置对应类作为Spring管理的bean注意：bean定义时id属性在同一个上下文中不能重复 初始化IoC容器（Spring核心容器/Spring容器），通过容器获取bean DI入门案例思路分析 基于IoC管理bean Service中使用new形式创建的Dao对象是否保留？（否） Service中需要的Dao对象如何进入到Service中？（提供方法） Service与Dao间的关系如何描述？（配置） DI入门案例（XML版） 删除使用new 的形式创建对象的代码 提供依赖对象对应的setter方法 配置service与dao之间的关系 bean基础配置bean别名配置 bean作用范围配置 为什么bean默认为单例？ 适合交给容器管理的bean 表现层对象 业务层对象 数据层对象 工具对象 不适合交给容器进行管理的bean 封装实体的域对象 bean实例化 bean本质上就是对象，创建bean使用构造方法完成 实例化bean的三种方式——构造方法（常用） 实例化bean的三种方式——静态工厂（了解） 实例化bean的三种方式——实例工厂 实例化bean的第四种方式——FactoryBean（实用） bean的生命周期 生命周期：从创建到消亡的完整过程 bean生命周期：bean从创建到销毁的整体过程 bean生命周期控制：在bean创建后到销毁前做一些事情 bean生命周期控制 bean生命周期控制——接口控制（了解） bean生命周期 初始化容器 创建对象（内存分配） 执行构造方法 执行属性注入（set操作） 执行bean初始化方法 使用bean 执行业务操作 关闭/销毁容器 执行bean销毁方法 bean销毁时机 容器关闭前触发bean的销毁 关闭容器方式： 手工关闭容器 ConfigurableApplicationContext接口close（）方法 注册关闭钩子，在虚拟机退出前先关闭容器再退出虚拟机 ConfigurableApplicationContext接口registerShutdownHook（）操作 依赖注入方式 思考：向一个类中传递数据的方式有几种 普通方法（set方法） 构造方法 思考：依赖注入描述了在容器中建立bean与bean之间依赖关系的过程，如果bean运行需要的是数字或字符串呢？ 引用类型 简单类型（基本类型与String） 依赖注入方式 setter注入 简单类型 引用类型 构造器注入 简单类型 引用类型 setter注入——引用类型 setter注入——简单类型 构造器注入——引用类型（了解） 构造器注入——简单类型（了解） 构造器注入——参数适配（了解） 依赖注入方式选择 前置依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现 可选依赖使用setter注入进行，灵活性强 Spring框架倡导使用构造器，第三方框架内部大多采用构造器注入的形式进行数据初始化，相对严谨 如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入 实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入 自己开发的模块推荐使用setter注入 依赖自动装配 IoC容器根据bean所依赖的资源在容器中自动查找并注入到bean中的过程称为自动装配 自动装配方式 按类型（常用） 按名称 按构造方法 不启用自动装配 配种中使用bean标签autowire属性设置自动装配的类型 自动装配用于引用类型依赖注入，不能对简单类型进行操作 使用按类型装配时（byType）必须保障容器中相同类型的bean唯一，推荐使用 使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用 自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效 集合注入 注入数组对象 注入List对象（重点） 注入Set对象 注入Map对象（重点） 注入Properties对象（重点） 第三方资源配置管理 加载properties文件 容器创建容器 获取bean 容器类层次结构图 BeanFactory初始化 核心容器总结 BeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载 ApplicationContext接口是Spring容器的核心接口，初始化是bean立即加载 ApplicationContext接口提供基础的bean操作相关方法，通过其他接口拓展其功能 ApplicationContext接口常用初始化类 ClassPathXMLApplicationContext FileSystemXMLApplicationContext bean相关123456789101112&lt;bean id=&quot;bookDao&quot; name=&quot;dao bookDaoImpl daoImpl&quot; class=&quot;com.dicemy.dao.impl.BookDaoImpl&quot; scope=&quot;singleton&quot; init-method=&quot;init&quot; destroy-method=&quot;destory&quot; autowire=&quot;byType&quot; factory-method=&quot;getInstance&quot; factory-bean=&quot;com.dicemy.factory.BookDaoFactory&quot; lazy-init=&quot;true&quot; /&gt; 依赖注入相关123456789101112131415&lt;bean id=&quot;bookService&quot; class=&quot;com.dicemy.service.impl.BookServiceImpl&quot;&gt; &lt;constructor-arg name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt; &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;constructor-arg name=&quot;msg&quot; value=&quot;WARN&quot;/&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; index=&quot;3&quot; value=&quot;WARN&quot;/&gt; &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;property name=&quot;msg&quot; value=&quot;WARN&quot;/&gt; &lt;property name=&quot;names&quot;&gt; &lt;list&gt; &lt;value&gt;dicemy&lt;/value&gt; &lt;ref bean=&quot;dataSource&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 注解开发注解开发定义bean 使用@Component定义bean 核心配置文件中通过组件扫描加载bean Spring提供@Component注解的三个衍生注解 @Controller：用于表现层bean定义 @Service：用于业务层bean定义 @Respository：用于数据层bean定义 纯注解开发 Spring3.0升级了纯注解开发模式，使用Java类替代配置文件，开启了Spring快速开发通道 Java类替代了Spring核心配置文件 @Configuration注解用于设定当前类为配置类 @ComponentScan注解用于设定扫描路径，此注解只能添加一次，多个数据请用数组格式 读取Spring核心配置文件初始化容器独享切换为读取Java配置类初始化容器对象 bean作用范围 使用@Scope定义bean作用范围 bean生命周期 使用@PostConstruct、@PreDestroy定义bean生命周期 依赖注入 使用@Autowired注解开启自动装配模式（按类型） 注意：自动装配基于反射设计创建对象并暴力反射对应属性为私有属性初始化数据，因此无需提供setter方法 注意：自动装配建议使用无参构造方法创建对象（默认），如果不提供对应构造方法，请提供唯一的构造方法 使用@Qualifier注解开启指定名称创配bean 注意：@Qualifier注解无法单独使用，必须配合@Autowired注解使用 使用@Value实现简单类型注入 加载properties文件 使用@PropertySource注解加载properties文件 注意：路径仅支持单一文件配置，多文件请使用数组格式配置，不允许使用通配符* 第三方bean管理 使用@Bean配置第三方bean 使用独立的配置类管理第三方bean 使用@Import注解手动加入配置类到核心配置，此注解只能添加一次，多个数据请用数组格式 将独立的配置类加入核心配置 方式二：扫描式 使用@ComponentScan注解扫描配置类所在的包，加载对应的配置类信息 第三方bean依赖注入 简单类型依赖注入 引用类型依赖注入 引用类型注入只需要为bean定义方法设置形参即可，容器会根据类型自动装配对象 注解开发总结XML配置与注解配置比较 Spring整合MyBatis 将MyBatis的配置文件转换为一个MyBatisConfig类，并且造一个sqlSessionFactory的Bean，完成配置和dataSource的注入 为了完成MyBatis的配置，还需要声明mapper在哪里，所以使用一个方法生成mapperScannerConfigurer类。 此时，当运行时，sqlSessionFactory会自动产生，并且会自动实现dao层中的接口，并将实现好的dao自动注入到写好的对应的Service类中，此时在主程序中只需获取一个Service的实例，即可执行相应的方法了。 Spring整合JUnit 使用Spring整合Junit专用的类加载器 AOP简介 AOP（Aspect Oriented Programming）面向切面编程，一种编程范式，指导开发者如何组织程序结构 OOP（Object Oriented Programming）面向对象编程 作用：在不惊动原始设计的基础上为其进行功能增强 Spring理念：无入侵式/无侵入式 连接点（JoinPoint）：程序执行过程中的任意位置，粒度为执行方法、抛出异常、设置变量等 在SpringAOP中，理解为方法的执行 切入点（Pointcut）：匹配连接点的式子 在SpringAOP中，一个切入点可以只描述一个具体方法，也可以匹配多个方法 一个具体方法：com.dicemy.dao包下的BookDao接口中的无型材无返回值的save方法 匹配多个方法：所有的save方法，所有的get开头的方法，所有以Dao结尾的接口中的任意方法，所有带有一个参数的方法 通知（Advice）：在切入点处执行的操作，也就是共性功能 在SpringAOP中，功能最终以方法的形式呈现 通知类：定义通知的类 切面（Aspect）：描述通知与切入点的对应关系 AOP入门案例 AOP入门案例（注解版） 导入aop相关坐标 定义dao接口实现类 定义通知类，制作通知 定义切入点 绑定切入点与通知关系，并制定通知添加到原式连接点的具体执行位置 定义通知类受Spring容器管理，并定义当前类为切面类 开启Spring对AOP注解驱动支持","link":"/33655"},{"title":"TobinMEng的代码模板大合集","text":"代码模板。 巨长的代码模板。 拿来了高中的代码模板然后持续更新。 图论图图的储存和插入12345int head[maxn], ver[maxm], Next[maxm], edge[maxm], tot;inline void adde(int x, int y, int v) { Next[++tot] = head[x]; head[x] = tot; ver[tot] = y; edge[tot] = v;} 连通块的划分（图的染色）1234567891011121314void dfs(int x) { color[x] = cnt; for (int i=head[x]; i; i=Next[i]) { int y = ver[i]; if (color[y]) continue; dfs(y); }}for (int i=1;i&lt;=n;++i) { if (!color[i]) { cnt++; dfs(i); }} BFS遍历一个树/图123456789101112131415void bfs() { queue&lt;int&gt; q; memset(d, 0, sizeof(d));//如果搜索的是一棵树的话， 那么d数组指的是节点x在树中的深度。如果是一张图的话， d数组指的是x的层次， （从起点1走到x所要经历的最少点数）。 q.push(1); d[1] = 1; while(q.size()) { int x = q.front(); q.pop(); for (int i=head[x]; i; i=Next[i]) { int y = ver[i]; if (d[y]) continue; d[y] = d[x] + 1; q.push(y); } }}//bfs有两个重要的性质， 1.在访问过所有的第i层节点之后，才会开始访问i+1层节点2.任意时刻，队列里只会出现i层的节点和i+1层的节点，并且所有的第i层节点都在第i+1层节点之前。（简单来说就是满足“两端性”和“单调性”）//并且dfs的时间复杂度和bfs的时间复杂度是相同的， 都为O(n+e)的时间复杂度，只不过限制两个算法的一个是堆栈大小， 一个是队列的大小 Dijkstra简单的正确性证明 123456789101112131415161718void Dijkstra(int x) { priority_queue&lt;pair&lt;ll ll&gt; &gt; q; for (int i=1;i&lt;=n;++i) dis[i] = INF, vis[i] = false; dis[x] = 0; q.push(make_pair(0, x)); while(q.size()) { int x = q.top().second; q.pop(); if (vis[x]) continue; vis[x] = true; for (int i=head[x]; i; i=Next[i]) { int y = ver[i], w = edge[i]; if (dis[y] &gt; dis[x] + w) {//由于是拿出现在堆中最小的点x来更新其相邻的点， 所以写的顺序需要注意 dis[y] = dis[x] + w; q.push(make_pair(-dis[y], y)); } } }}//适用于有向图和无向图中，只适用于边长不为负的图。时间复杂度为O((n+m)log(n)); SPFA 12345678910111213141516171819void SPFA(int x) { queue&lt;int&gt; q; for (int i=1;i&lt;=n;++i) dis[i] = INT, vis[i] = false; dis[x] = 0; q.push(x); vis[x] = true; while (q.size()) { int x = q.front(); q.pop(); vis[x] = false;//vis表示该点是否在队列中 for (int i=head[x];i;i=Next[i]) { int y = ver[i], w = edge[i]; if (dis[y] &gt; dis[x] + w) { dis[y] = dis[x] + w; if (vis[y] == false) { vis[y] = true; q.push(y); } } } }}//适用于有向图和无向图中，可以计算负权图，可以用来判断负环。时间复杂度为O(nm); Floyed123456void Floyed() { for (int k=1;k&lt;=n;++k) for (int i=1;i&lt;=n;++i) for (int j=1;j&lt;=n;++j) dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);}//多源最短路，可以有负权边。适用于大部分的情况。但是时间复杂度高达O(n³)。 Kruskal123456789101112131415161718192021struct node { ll x, y, v; friend bool operator &lt; (const node&amp;a, const node&amp;b) { return a.v &lt; b.v; }}e[maxm];void Kruskal() { for (int i=1;i&lt;=n;++i) f[i] = i; int cnt = 0; sort(e+1, e+1+m); for (int i=1;i&lt;=m;++i) { int a = find(e[i].x), b = find(e[i].y); if (a == b) continue; else { ans += e[i].v; f[b] = a; ++cnt; } if (cnt == n - 1) break; }}//这个是求出最小生成树的所有边的权值和， 其实可以可以在计算所有边的权值和的同时从新建一棵最小生成树 并查集1234567891011void init() { for (int i=1;i&lt;=n;++i) f[i] = i;}//使用并查集的初始化int find(int x) { return (f[x] == x) ? x : f[x] = find(f[x]);}//进行路径压缩的并查集void un(int x, int y) { int a = getf(x), b = getf(y); if (a == b) return; else f[b] = a;} 拓扑排序12345678910111213141516171819void Topsort() { queue&lt;int&gt; q; for (int i=1;i&lt;=n;++i) { if (du[i] == 0) { q.push(i); } }//找到入度为0的点， 入队 while(q.size()) { int x = q.front(); q.pop(); a[++tot] = x; for (int i=head[x]; i; i=Next[i]) { if (--du[ver[i]] == 0) { a[++tot] = ver[i]; q.push(ver[i]); } } }}//有向图中使用，记清楚！必须是有向图。显然的是，在进行完成拓扑排序之后，图中还留下来的东西就是一些环。即tot != n;//算法的应用：1.有向图找环（无向图是不能使用拓扑排序的） 二分图最大匹配1234567891011121314151617181920bool find(int x) { for (int i=1;i&lt;=m;++i) { if (Link[x][i] &amp;&amp; !used[i]) { used[i] = true; if (girl[i] == 0 || find(girl[i])) { girl[i] = x; return true; } } } return false;}//其实就是在寻找增广路的过程int Maxmatch() { int ans = 0; for (int i=1;i&lt;=n;++i) { memset(used, 0, sizeof(used)); if (find(i)) ++ans; } return ans;}//匈牙利算法如果使用邻接矩阵的话可以在O(n³)的时间内找到一个二分图的最大匹配数。空间复杂度是一个邻接矩阵(n²)。 Tarjan求强联通分量12345678910111213141516171819202122232425262728void Tarjan(int x) { dfn[x] = low[x] = ++tim; Stack[++top] = x; vis[x] = true; for (int i=head[x]; i; i=Next[i]) { if (!dfn[ver[i]]) { Tarjan(ver[i]); low[x] = min(low[x], low[ver[i]]); }else if (vis[ver[i]]) { low[x] = min(low[x], dfn[ver[i]]); } } if (dfn[x] == low[x]) { int temp = 0; ++cnt;//一个新的强联通块 do{ temp = Stack[--top]; color[temp] = cnt;//color里存的是第i个点属于第几个联通块 vis[temp] = false; }while(x != temp); }}int main() { for (int i=1;i&lt;=n;++i) { if (!vis[i]) tarjan(i);//因为这张图可能不连通 }} 缩点1234567891011121314151617181920212223242526272829void Tarjan() { dfn[x] = low[x] = ++tim; Stack[++top] = x; vis[x] = true; for (int i=head[x]; i; i=Next[i]) { if (!dfn[ver[i]]) { Tarjan(ver[i]); low[x] = min(low[x], low[ver[i]]); }else if (vis[ver[i]]) { low[x] = min(low[x], dfn[ver[i]]); } } if (low[x] == dfn[x]) { int temp; ++cnt; do { temp = Stack[top--]; color[temp] = cnt; vis[y] = false; }while(x != temp) }}/*缩点，其实就是拿着邻接表，和强连通分量们来建一张新的图，在新的图中，点就是原来的强连通分量，边的具体操作有点复杂，现在具体说一说，大致意思就是：既然点都变成了强连通分量，那么边就应该在他们当中去连接不是吗?那什么和什么连？似乎可以看到，连接同一个强连通分量里的点是没有任何意义的，所以就好办了，跑一遍原邻接表，如果一条边（u，v,w）的u和v不在同一个强连通分量中，那么就在新图中连这条边，就这样点就缩好了。听起来也许有些玄幻，但是它就真真切切的完成了？！*/for (int i=1;i&lt;=m;++i) {//一共m条边 if (color[a[i]] != color[b[i]]) {//如果两条边的两个端点不在一个强连通分量里面， 那么我们在这两个点之间连一条边 adde(color[a[i]], color[b[i]], z[i]); }}//等于用剩下的信息建了一张新图 树LCA树上倍增123456789101112131415161718192021222324252627282930void bfs() { t = log(n)/log(2); queue&lt;int&gt; q; d[s] = 1; q.push(s); while(q.size()) { int x = q.front(); q.pop(); for (int i=head[x]; i; i=Next[i]) { int y = ver[i]; if (d[y]) continue; d[y] = d[x] ＋ 1; f[y][0] = x; for (int j=1;j&lt;=t;++j) { f[y][j] = f[f[y][j-1]][j-1]; } q.push(y); } }}int lca(int x, int y) { if (d[x] &gt; d[y]) swap(x, y); for (int i=t;i&gt;=0;--i) { if (d[f[y][i]] &gt;= d[x]) y = f[y][i]; } if (x == y) return x; for (int i=t;i&gt;=0;--i) { if (f[y][i] != f[x][i]) x = f[x][i], y = f[y][i]; } return f[x][0];} Tarjan算法离线求LCA1234567891011121314151617181920212223242526void init() { int a, b; for (int i=1;i&lt;n;++i) { a = Read(); b = Read(); adde(a, b); adde(b, a); }//一棵树n-1条边 for (int i=1;i&lt;=k;++i) { a = Read(); b = Read(); qadde(a, b); qadde(b, a); }//k个询问 for (int i=1;i&lt;=n;++i) f[i] = i;}void Tarjan(int x) { vis[x] = true; for (int i=head[x]; i; i=Next[i]) { if (vis[ver[i]]) continue; tarjan(ver[i]); f[ver[i]] = x; } for (int i=qhead[x]; i; i=Next[i]) { if (vis[qver[i]]) ans[edge[i]] = getf(qver[i]); }} 树的直径123456789101112void dp(int x) { vis[x] = true; for(int i=head[x]; i; i=Next[i]) { int y = ver[i]; if (vis[y]) continue; dp(y); ans = max(ans, d[x] + d[y] + edge[i]); d[x] = max(d[x], d[y] + edge[i]);//d数组的含义是从x节点出发走向x的子树， 所能到达的最远距离。 //那么树上最长链的距离即为从x到x的子节点yi的距离加上x到x的子节点yj的距离加上d[yi]再加上d[yj]即可 //d[x]中存的是从x走向他的前i个子节点最长的路径， 再加上当前的点到它子节点最长的路径即可得到x所在链的长度， 取一下max即为最长链的长度， 即为树的直径 }} 树的重心123456789101112131415161718void dfs(int x) {//树的重心的定义就是将该点删去之后所形成的最大的子树最小的那个点 vis[x] = true; size[x] = 1;//子树x的大小 int max_part = 0;//删掉子树x后分成的最大子树的大小 for (int i=head[x]; i; i=Next[i]) { int y = ver[i]; if (vis[y]) continue; dfs(y); size[x] += size[y];//从子节点向上更新 max_part = max(maxn_part, size[y]);//x的子节点中最大的那个节点的size } max_part = max(maxn_part, n - size[x]);//现在max_part中储存的是该节点删去之后形成的若干个子树最大的那个的大小 //n - max_part里存的是x向上连接他的父亲节点的那一棵子树的大小。 if (max_part &lt; ans) { ans = max_part; pos = x; }} 树的各点子树的大小12345678910void dfs(int x) { vis[x] = true; size[x] = 1; for (int i=head[x]; i; i=Next[i]) { int y = ver[i]; if (vis[y]) continue; dfs(y); size[x] += size[y]; }} 树的各点的深度1234567891011121314151617181920212223void dfs(int x) { vis[x] = true; for (int i=head[x]; i; i=Next[i) { int y = ver[i]; if (vis[y]) continue; d[y] = d[x] + 1; dfs(y); }}void bfs(int x) { memset(d, 0, sizeof(d)); queue&lt;int&gt; q; d[x] = 1; q.push(x); while(q.size()) { int x = q.front(); q.pop(); for (int i=head[x];i;i=Next[i]) { int y = ver[i]; if (vis[y]) continue; d[y] = d[x] + 1; q.push(y); } }} 数论基础数论求一个数二进制的每个1的位置12345678910int H[37];void bit(int n) { for (int i = 0;i &lt; 36; ++i) H[(1ll &lt;&lt; i) % 37] = i; while(n &gt; 0) { cout &lt;&lt; H[(n &amp; -n) % 37] &lt;&lt; ' '; n -= n &amp; -n; } cout &lt;&lt; endl;}bit(9) // 0 3 Gcd 和 Lcm123456int gcd(int a, int b) { return b? gcd(b, a%b) : a;}int lcm(int a, int b) { return a / gcd(a, b) * b;} 线性筛求素数1234567891011121314ll prime[maxn], Size = 0;bool vis[maxn]; inline void init() { memset(vis, true, sizeof(vis)); memset(prime, 0, sizeof(prime)); vis[1] = false; for (int i=2;i&lt;=n;++i) { if (vis[i]) prime[++Size] = i; for (int j=1;j&lt;=Size&amp;&amp;i*prime[j]&lt;=n;++j) { vis[i*prime[j]] = false; if (i % prime[j] == 0) break; } }}//时间复杂度O(n) 素数判断12345bool is_prime(ll x) { if (x == 2) return true; for(int i=2;i&lt;=sqrt(p);++i) if(x % i == 0) return false; return true;} EXGCD123456789101112void Exgcd(int a, int b, int&amp; d, int&amp; x, int&amp; y) { if (!b) { x = 1; y = 0; d = a; return; } int x1, y1; Exgcd(b, a%b, d, x1, y1); x = y1; y = x1 - (a / b) * y1; } 求逆元1234567891011121314151617//如果p是素数那么可以使用小费马定理int inv(int a, int p) { return power(a, p - 2, p); }//如果p不是素数那么可以使用EXgcdint inv(int a, int p) { int x, y, d; exgcd(a, p, d, x, y); return d == 1 ? (a + p)% p : -1;}//如果返回-1则这个数没有逆元//如果要求出n以内所有在膜p情况下的的逆元,可以线性递推void inv(int n, int p) { inv[1] = 1; for (int i=2;i&lt;=n;++i) { inv[i] = (p - p / i) * inv[p % i] % p; }} 快速幂12345678int power(int a, int b, int p) { int res = 1 % p; for(; b; b &gt;&gt;= 1) { if (b &amp; 1) res = (long long)res * a % p; a =(long long)a * a % p; } return res;} 龟速乘12345678ll Mul(ll a, ll b, ll p) { ll res = 0; for(; b; b &gt;&gt;= 1) { if (b &amp; 1) res = (res % p + a % p) % p; a = (a &lt;&lt; 1) % p; } return res;}//可以防止两数相乘过大炸掉long long 组合数学12345678910void init() { memset(c, 0, sizeof(c)); c[1][0] = c[1][1] = 1; for (int i=2;i&lt;=maxn;++i) { c[i][0] = c[i][i] = 1; for (int j=1;j&lt;i;++j) { c[i][j] =(c[i-1][j] % mod + c[i-1][j-1] % mod)% mod; } }} 矩阵乘法12345678910111213141516171819202122struct Mat { a[maxn][maxn];}A, e;Mat Mul(Mat x, Mat y) { Mat c; for (int i=1;i&lt;=n;++i) for (int j=1;j&lt;=n;++j) c.a[i][j] = 0; for (int k=1;k&lt;=n;++k) for (int i=1;i&lt;=n;++i) for (int j=1;j&lt;=n;++j) c.a[i][j] = c.a[i][j] % mod + (x.a[i][k] * y.a[k][j] % mod) % mod; return c;}Mat power(Mat x, int p) { Mat ans = e; for (; b; b&gt;&gt;=1) { if (b &amp; 1) ans = Mul(ans, a); a = Mul(a, a); } return ans;} 博弈论巴什博奕123456789101112/*只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个，最后取光者得胜。结论： n % (m + 1) == 0 后手必胜 n % (m + 1) != 0 先手必胜*//*只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个，最后取光者得输。结论： n % (m + 1) == 1 后手必胜 n % (m + 1) != 1 先手必胜*/ 威佐夫博奕1234567891011/*有两堆各若干个物品为x,y，两个人轮流从任意一堆中取出至少一个或者同时从两堆中取出同样多的物品，规定每次至少取一个，至多不限，最后取光者胜利。*/inline bool check(int x, int y) { int a = min(x, y), b = max(x, y); double c = (double)abs(b - a); double r = (sqrt(5.0) + 1) / 2;//1.618 int tmp = int(c * r); if (a == tmp) return 0; //后手必胜 else return 1; //先手必胜 } 尼姆博奕12345/*有N堆石子。A B两个人轮流拿，A先拿。每次只能从一堆中取若干个，可将一堆全取走，但不可不取，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N及每堆石子的数量，问最后谁能赢得比赛。结论： n个数字进行异或，如果结果 = 0，后手必胜。如果结果 != 0，先手必胜。*/ 斐波那契博弈1234567/*有一堆个数为n的石子，游戏双方轮流取石子，满足： （1）先手不能在第一次把所有的石子取完； （2）之后每次可以取的石子数介于1到对手刚取的石子数的2倍之间（包含1和对手刚取的石子数的2倍）。 约定取走最后一个石子的人为赢家。结论： 当n为Fibonacci数时，先手必败。即存在先手的必败态当且仅当石头个数为Fibonacci数。 */ 数据结构基本数据结构链表12345678910111213141516171819202122232425262728293031323334inline void init() { a[1].pre = 0; a[1].next = -1; a[0].next = 1; a[0].pre = -1;}inline void insert(int x, int k, int p) { if (p == 1) { a[x].pre = k; a[x].next = a[k].next; a[a[k].next].pre = x; a[k].pre = x; }else { k = a[k].pre; a[x].pre = k; a[x].next = a[k].next; a[a[k].next].pre = x; a[k].next = x; } return;}//在k的前或者后面插入一个值为x的点//p == 1 时表示在k的后面插入了x//p == 0 时表示在k的前面插入了xinline void del(int x) { if (a[x].pre != -1) { a[a[x].pre].next = a[x].next; a[a[x].next].pre = a[x].pre; a[x].pre = -1; }}//一个数的pre为-1表示这个点已经被删除for (int i=a[0].next;i!=-1;i=a[i].next) { //一个链表的遍历} 队列12345678910111213141516171819//STLqueue&lt;int&gt; q;q.push(x);q.pop();int x = q.front();int size = q.size();bool is_empty = q.empty();//手写一个队列inline void init(){ head = 0; tail = 0; memset(q, 0, sizeof(q));}inline void push(int x) {q[++tail] = x;}inline void pop() {head++;}inline int front() {return q[tail];}inline bool empty() {return head &gt;= tail;}inline int size() {return tail - head;} 优先队列12345678910//STLpriority_queue&lt;int&gt; q;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;q.push(x);q.pop();int x = q.top();int size = q.size();bool is_empty = q.empty();//不会手写 栈12345stack&lt;int&gt; s;s.push(x);s.pop();int x = s.top();bool is_empty = s.empty(); 单调队列1 单调栈1 ST表12345678910111213inline int lowbit(int x) {return x &amp; (-x);}inline int query(int l, int r) { int t = log(abs(r - l + 1)) / log(2); return max(f[l][t], f[r - (1 &lt;&lt; t) + 1][t]);}void ST_init(int t = log(n) / log(2) + 1) { rep(i, 1, n) f[i][0] = a[i]; rep(j, 1, t - 1) { rep(i, 1, n - (1 &lt;&lt; j) + 1) { f[i][j] = max(f[i][j - 1], f[i + (1 &lt;&lt; (j - 1))][j - 1]); } }}//RMQ的离线算法，O(nlogn)的预处理，O(1)的查询。 树状数组1234567891011121314151617181920inline void add(int x, int v) { for (; x &lt;= n; x += x &amp; (-x)) c[x] += v;}inline int ask(int x) { int res = 0; for (; x; x -= x &amp; (-x)) res += c[x]; return x;}inline void init() { for (int i=1;i&lt;=n;++i) add(i, a[i]);}inline int sum(int x, int y) { return ask(y) - ask(x - 1);}add(x, v);//单点修改x加上vint sum = sum(a, b)//区间求和， 从a到b的区间//区间修改，区间求和inline void change(int l, int r, ll d) { } 线段树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051struct Segment { int l, r; ll dat, add; #define l(x) tree[x].l #define r(x) tree[x].r #define dat(x) tree[x].dat #define add(x) tree[x].add}tree[maxn &lt;&lt; 2];int a[maxn];inline void update(int p) { dat(p) = dat(p&lt;&lt;1) + dat(p&lt;&lt;1|1);}void build(int p, int l, int r) { l(p) = l; r(p) = r; if (l == r) {dat(p) = a[l];return;} int mid = (l + r) &gt;&gt; 1; build(p&lt;&lt;1, l, mid); build(p&lt;&lt;1|1,mid+1, r); update(p);}void spread(int p) { if (add(p)) { dat(p&lt;&lt;1) += add(p) * (r(p&lt;&lt;1) - l(p&lt;&lt;1) + 1); dat(p&lt;&lt;1|1) += add(p) * (r(p&lt;&lt;1|1) - l(p&lt;&lt;1|1) + 1); add(p&lt;&lt;1) += add(p); add(p&lt;&lt;1|1) += add(p); add(p) = 0; }}void change(int p, int l, int r, int d) { if (l &lt;= l(p) &amp;&amp; r &gt;= r(p)) { dat(p) += (long long)d * (r(p) - l(p) + 1); add(p) += d; return; } spread(p); int mid = (l(p) + r(p)) &gt;&gt; 1; if (l &lt;= mid) change(p&lt;&lt;1, l, r, d); if (r &gt; mid) change(p&lt;&lt;1|1, l, r, d); update(p);}long long ask(int p, int l, int r) { if (l &lt;= l(p) &amp;&amp; r &gt;= r(p)) return dat(p); spread(p); int mid = (l(p) + r(p)) &gt;&gt; 1; long long res = 0; if (l &lt;= mid) res += ask(p&lt;&lt;1, l, r); if (r &gt; mid) res += ask(p&lt;&lt;1|1, l, r); return res;} 分块12345678910111213141516171819202122232425262728293031323334void build() { block = sqrt(n); num = n / block; if (n % block) num++; for (int i=1;i&lt;=num;++i) l[i] = (i - 1) * block + 1, r[i] = i * block; r[num] = n; for (int i=1;i&lt;=n;++i) { a[i] = Read(); belong[i] = (i - 1) / block + 1; sum[belong[i]] += a[i]; }}void add(int x, int y, int d) { for (int i=x;i&lt;=min(x, r[belong[x]]);++i) a[i] += d, sum[belong[i]] += d; if (belong[x] != belong[y]) { for (int i=l[belong[y]];i&lt;=y;++i) a[i] += d, sum[belong[i]] += d; } for (int i=belong[x]+1;i&lt;=belong[y]-1;++i) sum[i] += block * d, tag[i] +=d;}int ask(int x, int y) { ll ans = 0; for (int i=x;i&lt;=min(x, r[belong[x]]);++i) ans += tag[belong[i]] + a[i]; if (belong[x] != belong[y]) { for (int i=l[belong[y]];i&lt;=y;++i) ans += tag[belong[i]] + a[i]; } for (int i=belong[x]+1;i&lt;=belong[y]-1;++i) ans += sum[i]; return ans;} 字符串基本字符串算法Hash表1234567unsigned long long h(char s[]) { int len = strlen(s); unsigned long long ans = 0; for (int i=0;i&lt;len;++i) ans += ans * 131 + (unsigned long long)(s[i] - 'a' + 1); return ans;} KMP123456789101112131415161718192021void prekmp() { m = strlen(b + 1); Next[1] = 0; for (int i=2,j=0;i&lt;=m;++i) { while(j &amp;&amp; b[i] != b[j + 1])j = Next[j]; if (b[i] == b[j + 1]) ++j; Next[i] = j; }}ll kmp() { n = strlen(a + 1); ans = 0; for (int i=1,j=0;i&lt;=n;++i) { while(j &amp;&amp; a[i] != b[j + 1])j = Next[j]; if (a[i] == b[j + 1]) ++j; if (j == m) { ++ans; j = Next[j]; } } return ans;} Manacher1234567891011121314151617181920void init() { int len = strlen(str), j = 1; s[0] = '$', s[1] = '#'; rep(i, 0, len-1) { s[++j] = str[i]; s[++j] = '#'; } s[++j] = '\\0';}int Manacher() { int len = strlen(s); int mx = 0, id = 0, ans = -1; rep(i, 0, len - 1) { if (mx&gt;i) p[i]=min(mx-i, p[2*id-i]);else p[i] = 1; while(i-p[i]&gt;=0&amp;&amp;s[i+p[i]]==s[i-p[i]])p[i]++; if(p[i]+i&gt;mx) mx = p[i]+i, id = i; ans = max(ans, p[i] - 1); } return ans;} 搜索基本搜索算法Dfs12345678void dfs(int x) { if (x &gt; n) { ... return; } ... dfs(x + 1);} Bfs123456789void bfs(int x) { queue&lt;int&gt; q; q.push(x); while(q.size()) { int x = q.front(); ... q.push(...); }} 迭代加深1 其他常见思路二分123456789101112131415161718192021222324//求小于等于x最大的那一个inline bool check(int x) { if (...) return true; else return false;}int work() { int l = 0; r = max_n; while(l &lt; r) { int mid = (l + r + 1) &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; } return l;}//求大于等于x的最小的那一个int work() { int l = 0; r = max_n; while(l &lt; r) { int mid = (l + r) &gt;&gt; 1; if (check(mid)) r = mid; else l = mid + 1; } return l;} 预热模板开新题的模板12345678910111213141516171819#include&lt;bits/stdc++.h&gt;#define rep(i, a, n) for (int i=a;i&lt;=n;++i)#define per(i, n, a) for (int i=n;i&gt;=a;--i)#define endl '\\n'using namespace std;typedef unsigned long long ull;typedef long long ll;const int maxn =inline void write(int x) {if(x &gt; 9) write(x/10);putchar(x % 10 + '0');return;}inline int Read() { int x=0,f=1;char ch=getchar(); while(ch&gt;'9'||ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();} return x*f;}int main() { return 0;} 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;bitset&gt;#include &lt;stack&gt; #define rep(i, a, n) for (int i=a;i&lt;=n;++i)#define per(i, n, a) for (int i=n;i&gt;=a;--i)#define endl '\\n'using namespace std;typedef unsigned long long ull;typedef long long ll;const int maxn = inline void write(int x) {if(x &gt; 9) write(x/10);putchar(x % 10 + '0');return;}inline int Read() { int x=0,f=1;char ch=getchar(); while(ch&gt;'9'||ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();} return x*f;}int main() { return 0;} 关联文件1234inline void send() { freopen(&quot;1.in&quot;, &quot;r&quot;, stdin); freopen(&quot;1.out&quot;, &quot;w&quot;, stdout);} 快读fread123456789ll f[maxn], c[maxn], ans = 0, n, tmp;char buf[1&lt;&lt;15], *fs, *ft;inline char getc(){return(fs==ft&amp;&amp;(ft=(fs=buf)+fread(buf,1,1&lt;&lt;15,stdin),fs==ft))?0:*fs++;}inline ll Read() { ll x=0,f=1;char ch=getc(); while(ch&gt;'9'||ch&lt;'0'){if(ch=='-')f=-1;ch=getc();} while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getc();} return x*f;}","link":"/58095"},{"title":"Web复习笔记","text":"大一上复习Web的小小总结 HTML标题类元素：h1，h2，h3，h4，h5，h6p元素：段落文字br元素：段内换行&amp;nbsp：空格pre元素：预留格式hr元素：水平标记线 div 元素属性：idnameheightwidthpadding 内边距margin 外边距borderdiv是块级元素，独占一行，用于页面的分区（相当于容器） span 元素属性：span是行级标签，宽度会根据内容变化，一行内可以并列多个行级标签。 img 元素属性：src 图像源文件alt 提示文字widthheightborder 表框 a 元素的常用属性：id 超链接的唯一标识name 给超链接命名href 链接目标的url，可以是一个a标签的name或者id来完成页内跳转格式#namehref = “mailto: …” 电子邮箱target 指定链接的目标窗口，取值有_self, _blank, _parent, _top等title 给链接提示文字rel 规定当前文档与目标文档之间的关系 列表元素：ul 无序列表ol 有序列表dl 定义列表 表格常用元素：table 定义表格caption 表格标题th 表格表头tr 行td 表格单元thead 页眉tfoot 页脚colgroup 列的组 table 的常用属性：bgcolor 背景色border 边框宽度cellspacing 单元格之间的大小cellpadding 单元格边框和内容之间的大小width 表格宽度heigth 表格高度 tr 的常用属性：widthheighalign 行的对齐方式（水平）left, right, centervalign 行的对齐方式（垂直）left, right, centerbgcolor 行的底色bordercolor 边框颜色 td 的常用属性：widthheighcolspan 向右通栏的栏数rowspan 向下通栏的栏数alignvalignbgcolorbordercolor audio 和 video 的常用属性：src 音频或者视频的路径width video独有height video独有autoplay 文件是否自动播放controls 文件是否显示控制面板loop 文件循环播放的次数poster video独有，如果视频播放失败，则展示一副替代的图片preload 是否预加载 表单元素：form 供用户输入的表单input 定义输入域textarea 定义文本域label 控制的标签select 选择列表option 下拉列表中的选项button 定义一个按钮 CSS外部样式表内部样式表内嵌样式 外部样式表的引入：在head区内使用link来引入外部的样式表。 内部样式表的使用：在head区内使用style type = “text/css” 来进行样式的定义。 内嵌样式的使用：在body内元素里加入style属性，style属性的内容就是CSS的内嵌样式 选择器：* 通用选择器. 类选择器# id选择器E 标签选择器E F 后代选择器 选择E元素的所有后代F元素E &gt; F 子代选择器 选择E元素下所有的子（第一代）元素FE + F 相邻兄弟选择器 选择紧接在E元素后的F元素E ~ F 通用兄弟选择器 选择E元素后面的所有兄弟元素E, F 群组选择器 E和F都被选择:link 链接伪类选择器 定义了超链接的元素 未被访问过的:visited 链接伪类选择器 定义了超链接元素 已被访问过:active 用户行为伪类选择器 元素被激活（鼠标点击不动时超链接的状态）:hover 用户行为伪类选择器 鼠标悬停在元素上:focus 用户行为伪类选择器 获得焦点 :first-child 匹配父元素的第一个元素:nth-child(n) 匹配父元素的第n个子元素:first-of-type 匹配父元素第一个类型为E的元素E[att] 选择具有属性att的E元素E[att=val] 选择具有属性att并且属性值为val的E元素E[att | = val] 选择属性值是有一个具有val或者以val-开始的属性值。E[att $ = val] 选择具有属性att并且属性值后缀为val的E元素E[att ^ = val] 选择具有属性att并且属性值为以val开头的字符串的E元素 border：border-width 边框的宽度border-colorborder-style 设置边框的样式：none(无边框),hidden(隐藏),soild(实线),double(双线框)border-radius 边框圆角提供两个参数，参数之间用/来分割 background:background-color 设置背景颜色background-image 设置背景图像background-position 设置背景图像的起始位置:background-repeat 背景图像是否重复 text:text-align 设置文本对齐方式：left, right, centervertical-align 设置文本垂直对齐方式text-indent 设置首行缩进line-height 设置行高text-shadow 产生阴影：text-shadow: color（阴影颜色） x-offset（X轴位移） y-offset（Y轴位移） blur-radius（阴影模糊半径） 盒子模型：白色边框和内容会显示出来，剩下的灰色的部分都是空白。 padding 元素边框和内容之间的距离，padding-top等四个margin: 元素周围的空间的距离，margin-top等四个box-shadow 定义元素的盒子阴影 浮动和定位：float: 将元素进行浮动,脱离文档流 属性有：none, left, rightposition: 定位是指将某个元素放在某个位置上 属性有：static(静态定位，默认值，top等属性无效), relative(相对位置，相对正常的位置), absolute(绝对定位，相对于 static 定位以外的第一个父元素进行定位), fixed(固定定位，相对于window固定) JS数据类型NumberString 用单引号和双引号包围BooleanObjectUndefined 未被赋值之前的值Null 没有任何值JS变量区分大小写 JS内置对象Object 对象String 字符串Date 时间对象Array 数组对象 如何去创建一个自定义的对象？ 1.通过对象字面量的方式创建对象：var obj = {}2.通过new object的方式创建对象:var obj = new Object()//创建一个空对象var arr = new Array()/创建一个空数组对象3.通过构造函数的形式创建对象：function Person(){};或者：var Person=function(){};4.通过Object.create()创建 Array常用方法：join() 将数组中的元素通过一个分隔符拼接为一个字符串，默认的分隔符是逗号pop()push()reverse() 翻转 Date常用方法：getDate() 返回月份的第几天getDay() 返回星期几，0是周日getMonth() 返回月份值，0表示1月getFullYear() 返回四位数的年份getHours() 返回小时getMinutes()getSeconds()getMilliseconds() 返回毫秒值getTime() 返回1970年1月1日至今的毫秒总数getTimezoneOffset() setDate() 传递参数为月份的第几天setMonth()setFullYear()setHours()setMinutes()setSeconds()setMilliseconds()setTime() Math常用方法：E 数学常量e的值LN2 2的自然对数值PI 圆周率的值SQRT2 2的平方根rand() 返回0~1之间的随机数ceil() 对参数向上取整floor() 对参数向下取整 JS内置事件：鼠标事件：onclick 鼠标单击（在当前区域按下并且在当前区域内抬起）onmouseover 鼠标滑入onmouseout 鼠标滑出onmousedown 鼠标按下（在当前区域内按下）onmouseup 鼠标按下并释放（在当前区域内抬起即可） 键盘事件：onkeypress 某个键盘上的按键按下并释放onkeydown 某个按键被按下onkeyup 网页相关事件：onload 页面加载时onunload 页面关闭或者重载时onerror 脚本出现错误时onresize 窗口大小发生改变时onscroll 网页滚动条发生变化时onmove 网页窗口移动时 表单相关事件：onblur 失去键盘焦点时onfocus 获得键盘焦点时onreset 表单重置时onsubmit 表单提交时 DOM是一个树形结构，当一个元素被触发时，路径所经过的结点都会收到该事件，这个传播过程的顺序可称为DOM事件流。 事件动态绑定：JS所有事物都是对象，如果获得对象使用：document.getElemenByID(“ID”) 事件监听器：addElementListener(event, function, useCapture)参数event表示监听的事件，不加on，比如click，touchstart等。函数可以是外部函数或者匿名函数。useCapture选择true表示捕获，false表示冒泡。 DOM DOM是一个树 DOM方法访问元素节点：getElementById(“”)getElementByName(“”) 通过name属性值来查找getElementByTagName(“”) 通过标签名来查找，返回一个对象集合，返回的顺序是它们在文档中的顺序getElementByClassName(“”) 通过样式名来查找 创建，插入节点：createElement() 创建元素节点createTextNode() 创建文本节点createAttribute() 创建属性节点appendChild() 把新的子节点添加到指定节点insertBefore() 在指定的节点前面插入新的子节点 替换，删除节点：removeChild() 删除子节点replaceChild() 替换子节点 获取，设置属性节点：getAttribute() 获取元素节点的属性setAttribute() 可以新增一个属性或者修改原来的属性节点 DOM属性innerHTML innerHTML可与获取或者修改子节点的HTML结构，可以代替createElement()innerText innerText可以获取或者修改节点的文本，nodeValue 规定了节点的值，元素的nodeValue是undefined或者Null；文本节点的nodeValue是文本本身；属性节点的nodeValue是属性值。nodeType 返回节点的类型 DOM操作样式style属性 修改样式使用style.属性名class属性 通过className属性读取或者设置类样式 BOM BOM和DOM的关系：DOM中的document对象也是window的子对象使用window对象时可以省略window，例如window.alert()可以略写成alert()。 window对象常用方法prompt() 显示可以输入的对话框confirm() 显示一段消息，以及确认和取消按钮的对话框open() 打开某一个窗口close() 关闭浏览器窗口setInterval() 每隔指定的时间执行代码。clearInterval() 取消setInterval()的设置。setTimeout() 在指定的延迟时间之后来执行代码。clearTimeout() 取消setTimeout()的设置 错题小记以下句子为正确易错的句子： 静态网页都会显示固定的信息 WEB 就是我们说网页，它是一系列技术的复合总称（包括网站的前台布局、后台程序、美工、数据库开发等），我们称它为网页，HTTP (英文Hypertext transfer protocol的缩写) 中文译为超文本传输协议，DNS （英文Domain Name System的缩写）是域名解析系统。这三个都是网页术语。 Web标准是由W3C与其他标准化组织共同制定的，不是各大厂商联合制定的。 XHTML是更严谨纯净的HTML版本 HTTP和HTTPS的差异：简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全。 JavaScript可以做很多事情，但最主流的应用是在Web上创建网页特效或验证信息。 标签就是放在“&lt; &gt;”标签符中表示某个功能的编码命令。 HTML5扩展名：.html和.htm 可以调整图像垂直边距的属性是：vspace HTML5的优势主要体现在兼容、合理、易用三个方面。 cite标签可以创建一个引用，用于对文档引用参考文献的说明，一旦在文档中使用了该标签，被标注的文档内容将以斜体的样式展示在页面中，以区别于段落中的其他字符。 层叠性是指多种CSS样式的叠加。而不是子标签会继承父标签的某些样式。 CSS注释只有一种写法：/* 注释语句 */ 如果使用RGB代码的百分比颜色值，取值为0时也不能省略百分号，必须写为0%。 并不是所有的CSS属性都可以继承。下面的属性就不具有继承性：边框属性，如border、border-top、border-right、border-bottom等外边距属性，如margin、margin-top、margin-bottom、margin-left等内边距属性，如padding、padding-top、padding-right、padding-bottom等背景属性，如background、background-image、background-repeat等定位属性，如position、top、right、bottom、left、z-index 等布局属性，如clear、float、clip、display、overflow等元素宽高属性，如width、height CSS3最突出的优势主要体现在节约成本和提高性能两方面。 临近兄弟选择器使用加号“+”来链接前后两个选择器。 子元素择器主要用来选择某个元素的第一级子元素。 E[att$=value] 属性选择器是指选择名称为E的标签，且该标签定义了att属性，att属性值包含后缀为value的子字符串。 ：not选择器：如果对某个结构标签使用样式，但是想排除这个结构元素下面的子结构元素，让子结构元素不使用这个样式，可以使用:not选择器。 RGBA模式用于设置背景与图片的不透明度。 padding属性不允许使用负值。 无序列表是网页中最常用的列表，之所以称为“无序列表”，是因为其各个列表项之间没有顺序级别之分，通常是并列的，并不存在主导从属的关系。 当不设置list-style-position属性时，列表项目符号位于列表文本以外（默认值）。 在HTML语言中，&lt;th&gt;标签用于设置表格的表头。 在&lt;textarea&gt;表单控件中，cols用来定义多行文本输入框每行中的字符数 autocomplete属性用于指定表单是否有自动完成功能，所谓“自动完成”是指将表单控件输入的内容记录下来，当再次输入时，会将输入的历史记录显示在一个下拉列表里，以实现自动完成输入。 “overflow:visible;”：内容不会被修剪，会呈现在元素框之外（默认值）。 z-index属性取值可为正整数、负整数和0 在网页中，常用的命名方式有“驼峰式命名”和“帕斯卡命名”两种。 在HTML5中嵌入的视频格式主要包括ogg、mpeg4、webm transition-duration属性用于定义完成过渡效果需要花费的时间。 animation-timing-function用来规定动画的速度曲线。 animation-duration属性用于定义整个动画效果完成所需要的时间。 animation-name属性用于定义要应用的动画名称。transition-delay的属性值可以为正整数、负整数和0。当设置为负数时，过渡动作会从该时间点开始，之前的动作被截断；设置为正数时，过渡动作会延迟触发。 在CSS3中，transform属性可以实现网页中元素的变形效果。CSS3变形效果是一系列效果的集合，例如平移、缩放、倾斜和旋转。使用transform属性实现的变形效果，无需加载额外文件，可以极大提高网页开发者的工作效率和页面的执行速度。transform属性的基本语法如下：transform：none|transform-functions;在上面的语法格式中，transform属性的默认值为none，适用于行内元素和块元素，表示元素不进行变形。transform-function用于设置变形，可以是一个或多个变形样式，主要包括translate ()、scale()、skew()和rotate()等，具体说明如下： translate()：移动元素对象，即基于X和Y坐标重新定位元素。 scale()：缩放元素对象，可以使任意元素对象尺寸发生变化，取值包括正数、负数和小数。 skew()：倾斜元素对象，取值为一个度数值。 rotate()：旋转元素对象，取值为一个度数值。 animation属性是一个简写属性，用于在一个属性中设置animation-name、animation-duration、animation-timing-function、animation-delay、animation-iteration-count和animation-direction六个动画属性。其基本语法格式如下：animation: animation-name animation-duration animation-timing-function animation-delay animation-iteration-count animation-direction;在上述语法中，使用animation属性时必须指定animation-name和animation-duration属性，否则动画效果将不会播放。","link":"/48416"},{"title":"数字逻辑复习","text":"期末的小小总结 [TOC] PPT查看与下载 第一章ppt 第二章ppt 第三章ppt 第四章ppt 第五章ppt 第六章ppt 第一章 数字逻辑电路基础两类信号：模拟信号，数字信号。 时间和幅值均连续，模拟信号。时间和幅值均离散，数字信号。 处理数字信号的电路叫做数字电路。 几种简单编码BCD码8421码， 5421码，2421码, 余三码。 有权BCD码：8421码， 5421码，2421码。 5421BCD码和2421BCD码不唯一。 5421BCD码前五个码和后五个码一一对应，仅高位不同。 2421BCD码后五个码以中心对称去反，这样的代码成为自反代码。4和5互为反码，3和6，… 0和9互为反码。 余三码是无权BCD码，是在8421BCD码的基础上加上0011（3）形成的编码。每位数码无确定的位权。 格雷码格雷码是循环码。 奇偶校验码具有检错能力的代码 奇校验：原代码的基础上加上一个码位使得代码中含有1的个数为奇数。 偶校验：原代码的基础上加上一个码位使得代码中含有1的个数为偶数。 通过检查代码中含有的1的奇偶性来判断代码的合法性。 字符数字码ASCII码等 算术运算有符号数的表示方法原码，反码，补码。 一个正数和比他小的负数相加，多出符号位的进位忽略。 两个负数相加，多出符号位的进位忽略。 逻辑运算研究数字电路的基础是逻辑代数，也称布尔代数。 基本逻辑运算逻辑代数中只有三种基本逻辑运算，即“与或非”。 与门和或门可以有多个输入端。 复合逻辑运算 同或和异或互为反函数。 正逻辑和负逻辑正逻辑：高电平有效。 负逻辑：低电平有效。 逻辑代数的基本定律和规则逻辑函数的相等如果两个函数的真值表相等，则这两个函数一定相等。 基本定律 逻辑代数的三条规则 代入规则。将一个等式中的某一变量使用一个逻辑函数式F代替，则等式仍然成立。 由1可证明反演律对n个变量仍然适用。 反演规则。 注意：1.要保持原式的优先顺序。2.原式中不属于单变量上的非号不变。 对偶规则。 注意：1.要保持原式的优先顺序。2.原式中的长短非号不变。3.单变量的对偶式为自己 对偶规则：若有两个逻辑表达式F和G相等，则各自的对偶式F’和G’也相等。 逻辑代数的常用公式 同或和异或： 偶数个变量：同或和异或互为反函数。 奇数个变量：同或和异或相等。 同或功能常常使用异或门来实现。 逻辑函数的标准形式最小项和最大项 2）最小项编号：使该最小项的值为1所对应的等效十进制数。 3）最小项的性质： 变量任取一组值，仅有一个最小项为1，其他最小项为0； n变量的全体最小项之和为1 不同的最小项相与，结果为0 两最小项相邻，相邻最小项相“或”，可以合并成一 项，并可以消去一个变量因子。 已知F的最小项式，则F反的最小项式为F最小项的补集。F对偶式的最小项是F反中和2的n次方减1互补的那一项的值。 已知F的最小项式，则F的最大项的值为F最小项的补集。 2）最大项编号：使该最小项的值为0所对应的等效十进制数。 3）最大项的性质： 变量任取一组值，仅有一个最大项为0，其它最大项为1 n变量的全体最大项之积为0 不同的最大项相或，结果为1 两相邻的最大项相“与”，可以合并成一项，并可以消去一个变量因子 编号下标相同的最小项和最大项互为反函数。 标准与或式和标准或与式任一逻辑函数都可以表达为最小项之和的形式,而且是唯一的 逻辑函数式化简为其它形式可能会用来解决用特定的门电路来绘制电路图的问题。 比如与非门。 逻辑函数式与真值表化为最小项之和的形式，最小项对应的为1。 逻辑函数的化简卡诺图化简法相邻的2的n次方的项进行合并，从相邻数最少的那个开始。每一次合并可以消去n个变量。 圈和圈可以重叠。 用卡诺图求反函数的最简与或式合并卡诺图中的0方格。 可以用来求最简与或非式。 不完全确定的逻辑函数及其化简无关项看为1，然后进行化简，但是在最后写的时候记得写无关项恒等的条件。 第二章 逻辑门电路晶体管的开关特性在数字电路中,常将半导体二极管,三极管和场效应管作为开关元件使用。 半导体二极管的开关特性硅二极管的导通条件及导通时的特点： 大于0.7V导通，小于0.5V截止。 硅二极管的开启和关断时间都很小。 半导体三极管的开关特性 开关时间和导通的深度成正比。 CMOS门电路CMOS反相器：静态功率极小。 本质上就是一个非门。 第三章 组合逻辑电路组合逻辑电路：电路在任一时刻的输出状态仅由该时刻的输入信号决定,与电路在此信号输入之前的状态无关 组合逻辑电路的分析分析方法分析步骤： 通过电路图写出逻辑函数表达式 通过逻辑函数表达式列出真值表。 通过真值表或者表达式分析电路的功能。 组合逻辑电路的设计设计方法设计步骤： 由实际逻辑问题列出真值表 由真值表写出逻辑表达式 化简，变换输出表达式。 画出逻辑图。 组合逻辑电路中的冒险产生冒险的原因由于门电路延迟时间的关系，可能会使逻辑电路产生错误输出。通常把这种现象称为竞争冒险。 电路存在由非门产生的互补信号，且互补信号的状态发生变化时有可能出现冒险现象。 消去冒险的方法 发现并消除互补变量 增加乘积项 第四章 常用组合逻辑功能器件中规模集成电路分别具有特定的逻辑功能,称为功能模块。 自顶向下的模块化设计方法分层设计树 分层方框图 编码器将信息(如数和字符等)转换成符合一定规则的二进制代码 二进制编码器用n位二进制代码对N=2的n次方个特定信息进行编码的逻辑电路。 4线 — 2线编码器（将四个信息编码为一个2位二进制数）（4线中只允许有一个输入有效） 带输出使能端的优先编码器输出使能端: 用于判别电路是否有信号输入（是一个输出信号，当没有任何信号输入时输出1，否则输出0） 优先: 对输入信号按轻重缓急排序,当有多个信号同时输入时,只对优先权高的一个信号进行编码. 该编码器所对应的真值表和逻辑电路图： 二 — 十进制编码器输入: I0 ,I1,I2 … …I9,表示十个要求编码的信号.输出: BCD码. 电路有十根输入线,四根输出线,常称为10线—4线编码器 通用编码器集成电路8线—3线优先编码器74148 1）74148为8线—3线优先编码器，HPRI是最高位优先编码器的说明。2）编码器输入为低电平有效，输出为3位二进制反码。3）EI非表示输入使能端，当EI非为0时电路正常工作，反之则电路禁止工作。（相当于编码器的开关（当输入0时编码器工作））（当电路禁止工作时，输出为111）4）EO非表示选通输出端，当EO非为0时表示电路在工作状态但是没有输入。（用于区分开电路禁止工作时无输入的情况（等于0的时候）） 5）GS非表示扩展输出端，当GS非为0时表示电路在工作状态并且至少存在一个输入。（用于标识电路处于工作状态并且有输入的情况） 使用两块74148来构成一个16线 — 8线编码器： 当II编码器工作时，EI非输入使能端为0将II编码器打开，此时如果存在输入，则EO非为1，同时将EO非接入下一片I编码器的输入使能端。将I编码器关闭。I编码器输出全为1。 当II编码器工作时，如果有输入时，GS非的输出都为0。将GS非输出的0作为编码后的最高位，即0111中的0（低电平有效）。此时按照8线—3线编码器中将II编码器中的输入编码成为一个3位的二进制编码，和I编码器的111相与之后的结果加上最高位的0即为最终的编码。 当I编码器工作时，II编码器的EI非端输入还为0，但是此时的II编码器的输入全为1，即无输入。此时II编码器的EO非输出为0，表示II编码器正在工作但是没有输入。此时输出的EO非输入到I编码器中的EI非中，将I编码器开启进行编码，此时的II编码器的所有输出都为111（低电平有效）。并且II编码器的GS非端的输出为1，即最高位此时为1（低电平有效）。I编码器将输入编码为一个三位二进制数后和II编码器中的111相与，即为最后编码的结果。 10线—4线优先编码器74147 译码器/数据分配器译码是编码的逆过程，作用是将一组码转换为确定信息。 二进制译码器输入：二进制代码，有n个；输出：2n 个特定信息。 LSB：最低有效位 MSB：最高有效位 高电平输出有效的二进制译码器的输出逻辑表达式为Yi = mi（mi为输入变量所对应的最小项） 低电平输出有效的二进制译码器的输出逻辑表达式为Yi非 = mi非（mi为输入变量所对应的最小项） 译码器的使能控制端1）利用使能输入控制端，既能使电路正常工作，也能使电路处于禁止工作状态；2）利用使能输入控制端，能实现译码器容量扩展。 通用译码器集成电路带使能端3线—8线译码器 74138 1）电路输出低电平有效2）G1，G2A，G2B的值分别为100，此时电路才进行工作，否则，电路禁止工作。电路输出均为1。 数据分配器数据分配是将一个数据源输入的数据根据需要送到不同的输出端上去，实现数据分配功能的逻辑电路称为数据分配器。分配器又叫多路复用器。 数据分配器一般用带使能控制端的二进制译码器实现。 用74138作为数据分配器 此时D即为数据源，通过CBA的编码来将D的数据分配到0~7的某一个出口处。 译码器应用举例用译码器实现组合逻辑函数原理: 二进制译码器能产生输入信号的全部最小项,而所有组合逻辑函数均可写成最小项之和的形式 计算机输入/输出接口地址译码电路 数据选择器功能: 从多路输入数据中选择其中的一路送至输出端.数据选择器简称MUX,数据选择器的数据输入端数称为通道数 常用MUX数据选择器的编号有：74150（16个输入），74151（8个输入） 数据选择器应用实例 1）用MUX实现逻辑函数时，MUX必须被选通，即ST非=02）变量和地址端之间的连接必须正确。 算数运算电路算术运算电路的核心为加法器. 基本加法器1）半加器(HA)：仅考虑两个一位二进制数相加,而不考虑低位的进位,称为半加。 2）全加器：在多位数相加时,除考虑本位的两个加数外,还须考虑低 位向本位的进位 3） 串行进位加法器： 高速加法器1）全并行加法器 只存在在理论中。 2）超前进位加法器设计思想: 由两个加数,首先求得各位的进位,然后再经全加器算出结果 根据Gi 、Pi 来求进位信号C 的电路称为超前进位电路（CLA） 超前进位加法器的缺点在于超前进位逻辑的产生，随着位数的增加，Ci会变得很复杂。 超前进位加法器的实现通常以4位为基本模块，以分层结构实现位数为4 的倍数的加法器。由C3完整表达式： 通用加法器集成电路 例题： 减法电路 借位信号实现减2的n次方 的功能: 当A+B反+1 的高位有进位时,该进位信号和2的n次方 相减使最高位为0, 反之为1。 借位信号作为运算结果的符号位。 数值比较器数值比较器用来判断两个二进制数的大小或相等 第五章 时序逻辑电路 时序逻辑电路的特点:电路在任何时候的输出稳定值,不仅与该时刻的输入信号有关,而且与该时刻以前的电路状态有关;电路结构具有反馈回路。 锁存器存储电路由存储器件组成,能存储一位二值信号的器件称为存储单元电路.存储单元电路大多是双稳态电路 普通锁存器RS锁存器 门控RS锁存器在RS锁存器的基础上, 加控制信号,使锁存器状态转换的时间,受控制信号的控制. 门控D锁存器能将呈现在激励输入端的单路数据D存入交叉耦合结构的锁存器单元中. 触发器利用一个称为“时钟”的特殊定时控制信号去限制存储单元状态的改变时间,具有这种特点的存储单元电路称为触发器。 主从触发器主从RS触发器 主从D触发器 主从JK触发器主从JK触发器其实就是将RS触发器中的RS = 0 的约束条件给解除。当R = S = 1时，主从JK触发器将状态值进行翻转。 主从触发器的缺陷 边沿触发器 同步时序电路由于在同步时序电路中，各触发器的动作变化是在CLK脉冲作用下同时发生的，因此，在同步电路的分析中,只要知道了在当前状态下各触发器的输入（即驱动信号）,就能根据触发器的特性方程,求得电路的下一个状态,最终找到电路的状态转换规律。 第六章 常用时序逻辑功能器件第六章就一句话","link":"/16132"},{"title":"离散数学复习","text":"期末的小小总结 文件下载蜂考教案 课时一 命题逻辑的基本概念1、 命题 例如： 5x + 1 &gt; 11 这一语句不为命题。 一个未证明真伪的猜想是一个命题。 2、命题连接词 合取就是且，只有都为真才为真。 析取就是或，有一个为真就是真。 蕴含只有左1右0为假，其余都为真。 关于蕴含的实际意义，如何去理解这个关系可以看一看知乎上的回答： 但是要注意： 另一条回答： 等价就是两个同真同假才为真，其余为假。 将命题符号化时： 注意带有蕴含的命题符号化时，当意思中带有前者只有后者决定时，需要写为后者蕴含前者。 注意一些带有或者的命题的符号化，例如： 3、命题公式及其赋值 命题的合式公式中的每一个可以取真假值的字母叫做一个命题变元。 对于命题变元的任意赋值都为真的命题公式称为重言式或者永真式。 对于命题变元的任意赋值都为假的命题公式称为矛盾式或者永假式。 如果存在一组命题变元的赋值可以使命题为真，则称该命题为可满足式。 课时二 命题逻辑等值演算1、 等值式 A和B中应该含有相同的命题变元。 常见等值式可以帮助命题公式的化简。 常见题型有判断命题公式为重言式或者矛盾式，或者通过等值演算证明两个命题式为等值式。 蕴含等值式和假言易位和归谬论这几个比较常用，感觉用处比较大。 仔细理解分配律，当两个括号进行分配律时可以一步一步做。直接全部展开可能会出错。 2、析取范式与合取范式 重点是：析取范式应该是几个简单合取式的析取，合取范式应该是几个简单析取式的合取。 3、主析取范式与主合取范式 主析取范式的每一个简单合取范式成为最小项，主合取范式的每一个简单析取范式成为最大项。 一个式子的极大项和极小项的标号是从0开始，到2的n次方-1结束。 求一个式子的主析取范式和主合取范式的方式： 1、列该式子的真值表，通过真值表中的成真赋值得到该式子的极小项，从而写出该式子的主析取范式。主合取范式则反之，取真值表中成假赋值的极大项写出主合取式。 2、通过等价演算求出式子的极小项的析取范式，从而得到主析取范式。 3、通过式子已知的主合取范式来求出式子的主析取范式。（两个范式中各项的序号互补） 4、联结词的完备集 箭头向上表示两个命题的与非关系，↑可以和∧类比记忆 箭头向下表示两个命题的或非关系，↓可以和∨类比记忆 联结词完备集分为两类： 1、包含非号¬的集合中除了单独的等价关系↔不能与之构成完备集之外，其他任意若干个关联符都可以和非号构成完备集。 2、至少包含与非或者或非其中一个的联结词集合 例题： 题中的大项指的是极大项。极大项指的是简单析取式。本题答案为永真，永假。 课时三 命题逻辑的推理理论1、推理的相关公式 其中①和②常常用于做一些小的变换，或者引入一些新的条件。 ③和④常常用于一般比较简单的证明的过程中，比较重要。 ⑤⑥⑦三段论使用也是比较多。 ⑧和⑨使用较少。 2、自然推理系统P例题1： 需要记住自然推理系统的推理过程，先通过前提列出所有的条件，然后列出结论。在下面通过证明过程来通过前提的一系列变化得到结论。 在证明的每一条之后都要列出通过那些条件使用那些定理得到。 在将前提引入时，需要在后面加上前提引入这样的语句。 例题2： 先将命题符号化，每一个句号就是一个前提。所以后面跟的的就是结论。 例题3： 若结论中是一个蕴含式的话，结论的前面部分的命题应该作为附加前提引入到证明过程中。 这样使用完所有的前提和结论中的附加前提之后就可以得到最后结论中蕴含式中的后部分。从而得出结论为真的结论。 例子4： 归谬法通过引入结论的否定，使得最后推出的结果和前提矛盾，即推出的结果和前提的一部分合取值为假，从而得出否定的结论错误，这样就可以证明命题必须为真了。 其实这道题通过正常的构造法也可进行证明。 课时四 谓词逻辑基本概念1、谓词逻辑命题符号化 例子1： 例子2： 这两个例子说明在全称量词中两个谓词的关系用蕴含，但是在存在量词中两个谓词的关系用合取。 例子3： 2、谓词逻辑公式及其解释 例子1： 例子2： 说实话，没看懂这题。 看到后面的谓词逻辑的等值演算与推理看懂了。 存在量词去掉的方法就是将论域中的值都带入公式然后将每一种情况全部析取即可。 同理全称量词是每一种情况的全部合取。 这道题也没看懂。 课题五 谓词逻辑等值演算与推理1、 谓词逻辑等值式与置换规则 我觉得应该是自由出现和限制出现搞混了。上面的自由出现的个体变项都应该改成限制出现。 对于①和②中的大部分量词辖域的收缩和扩张基本上都是直接去掉括号即可。但对于含有蕴含的谓词需要去掉括号之后改变量词。 对于3）中的式子来说，需要特殊记忆，注意有③和④公式存在顺序。 全称量词的合取有分配律 存在量词的析取有分配律 量词分配等式中含有合取符号的分配直接去括号即可。 例子1： 感受一下这种方法： 存在量词去掉的方法就是将论域中的值都带入公式然后将每一种情况全部析取即可。 同理全称量词是每一种情况的全部合取。 2、谓词逻辑前束范式 很遗憾，所有的谓词逻辑公式都存在等值的前束范式。 注意：前束范式中量词一定要在最前面，连像非号之类的符号也不应该放在量词前面。 注意2） 3、谓词逻辑的推理理论 我把这些规则称为：魔法。:crystal_ball: ③中的一些推理我觉得理解不了。 例题1： 看懂了，但是脑子说不会。:innocent: 要熟悉量词的增加和删去。其实也是量词的实际含义。 例子2： 实质就是将谓词逻辑变换成命题逻辑，然后通过命题的演绎推理得到一个命题，再将这个命题转换成谓词逻辑。（对于结论中是存在的谓词逻辑比较适用） 例子3： 对于自然语言中含有量词的命题就要考虑适用量词逻辑进行证明。 课时六 集合代数1、集合的基本概念 注意真子集的符号 P(A)和E的含义。 2、集合的运算 对称差就是两个集合的并减去两个集合的交。 3、有穷集的计数 可以类似这种的文氏图帮助计算 例题1： 例题2： 4、集合恒等式 注意要进行德摩根律的特别记忆 即进行差运算和求补集运算时去括号要将交和并进行转换。 重点记忆第一个公式。进行灵活运用 课时七 二元关系1、有序对与笛卡尔积 2、二元关系 3、关系的运算 这里右复合和课本上正好相反。 课时八 二元关系1、关系的性质 对称性是针对关系内的所有有序对，自反性也是针对关系内所有有序对的定义域的元素。 2、关系的闭包 关系的闭包其实就是在原关系的基础上，将原关系的所有自反（对称或传递）有序对加入进关系。所形成的大于等于原关系集合的一个有序对集合。 记住r是自反闭包，s是对称闭包，t是传递闭包。 3、有序关系与划分 等价类是一个集合，里面的元素是A上等价关系中dom是x的所有有序对的ran的值。 集合上的同余关系是一个等价关系 例题1： 划分其实就是一个集合通过一个划分得到了几个元素不重叠且完全使用所有的元素的子集族。 4、偏序关系 最大元和最小元和极大元和极小元可以直接看哈斯图得出。 对于最大元和最小元来说，应该是集合中元素在最上面层（下面层）且没有同层的那个元素，若有同层元素则不存在。 对于极大元和极小元来说，应该是集合中元素在最上面层（下面层）且没有同层的那一层的所有元素，都称为这个集合的极大元和极小元。 同样的上下界和上下确界的寻找也可以看哈斯图来理解： 上界和下届是：子集中最大或最小的那一层，如果是单独一个元素时，包含这个元素的所有上下元素就是这个子集的上下界。 上下确界是：子集中最大或最小的那一层，如果是单独一个元素时，则上下确界存在。界为最大或最小那一层的元素，否则上下确界不存在。 课时九 函数1、函数的定义与性质 例题1： B的A次方称为B上A，是从A到B的函数。 2、函数的复合与反函数 函数其实就是一种特殊的关系，所以函数的复合与反函数其实就是关系的复合和反关系 课时十 代数结构没讲 课时十一 图的基本概念1、图 顶点数称作图的阶，n个顶点的图称作n阶图。 没有边的图叫做零图，1阶零图称作平凡图。注意n阶零图的符号表示为N右下小n 关联次数是边对两个顶点的次数。 桥（割边）：对于无向图,如果删除了一条边,**整个图的联通分量数量变化,**则这条边称为桥树的每一条边都是桥 割点：对于一个无向图，如果删除了一个顶点(顶点邻边也删除),整个图的联通分量数量改变,则称这个顶点为割点。 有向边的两个点都叫端点，有向边有始点和终点。 有向边的出度和入度。出度为d+，入度为d-。 握手定理： 无向图中，顶点的度数之和等于边数的二倍 有向图中，所有顶点的度数之和都等于边数的二倍，所有顶点的入度之和等于所有顶点的出度之和。等于边数 任何图中，奇度顶点的个数是偶数。 Δ（G）指的是图中最大的顶点的度数。 简单图指的是没有重边和自环的图。 无向完全图表示方法为K右下小n 2、通路与回路 3、图的联通性 图中两点是联通的的表示方法为u~v 无向图中任意两点之间都连通这样的图叫做连通图，否则叫做非连通图。 有向图中的联通性： 单向联通的 强联通的 弱联通的 强联通和单向联通都是在有向图中是联通的，只是强联通相当于无向边了，但是单向联通只是两点之间存在一个通路而已。 弱联通在有向图中就不连通，只是把有向边看做无向边之后才联通。 4、图的矩阵表示 第i行第j列表示顶点i与边j的关联次数，若j边是自环，则对应的ij的值为2，若i是j一个顶点，则为1，若j与顶点i不关联，则为0。 有向图的关联矩阵要默认有向图无环。 邻接矩阵表示为A(D)，D为有向图，可以有重边。 重点！ 邻接矩阵的n次幂的结果是从i到j长度为n的通路的个数。如果i等于j则为长度为n的回路的个数。 可达矩阵可以通过多次计算邻接矩阵的不同次幂来得到每两个点之间的联通性从而求得。 课时十二 欧拉图与哈密顿图1、欧拉图 半欧拉图：有欧拉通路无欧拉回路 无向图：连通图 + 无奇度顶点 有向图：强联通 + 入度等于出度 2、哈密顿图 哈密顿图的判定是充分条件不是充要条件。 3、最短路问题 用dijkstra标号法求解最短路。 课时十三 树1、无向树及其性质 2、最小生成树 Kruskal算法 3、根树及其应用 根树其实就是有向树 最优二叉树是Huffman树 例题1： 例题2： 课时十四 平面图1、平面图的基本概念 二部图就是二分图 二分图的判定：图中不含奇环。 k5和k33不是平面图 2、欧拉公式","link":"/12732"},{"title":"JavaWeb","text":"JavaWeb入门 参考课程：Java web从入门到企业实战完整版 Web前置知识Mysql详见本博客中的：MySql数据库入门 补充： DDL：对表结构的操作。 DML：对表内数据的增删改查操作。 DQL：对表内数据的查询操作。 JDBCJDBC简介jdbc就是用java语言操作关系型数据库的一套API。 同一套Java代码，操作不同的关系型数据库。 jdbc是一套Sun公司定义的标准接口 。 在jdbc的标准下，Mysql，Oracle，DB2等数据库公司各自实现了这些接口，这些完成了的接口叫做实现类。这些实现类又叫做各自数据库的“驱动”。其本质是Jar包。 所以我们使用JDBC接口进行编程，但真正执行的是各实现类的Jar包。 JDBC的好处： 各数据库厂商使用相同的接口，JAVA代码不需要根据不同的数据库进行开发。 可随时更换底层数据库，但访问JAVA的代码可以基本不变。 JDBC快速入门 创建工程，导入驱动Jar包 注册驱动 class.forname(“com.mysql.cj.jdbc.Driver”) 获取连接 Connection conn = DriverManager.getConnection(url, username, password) 定义SQL语句 String sql = “…” 获取执行SQL对象 Statement stmt = conn.createStatement(); 执行SQL stmt.executeUpdate(sql); 处理返回结果 System.out.println(“…”) 释放资源 stmt.close(); conn.close(); JDBC API 详解DriverManager 注册驱动Driver类源码中静态代码块调用了registerDriver()进行驱动的注册Mysql 5 之后的驱动包，可以省略注册驱动的步骤自动加载jar包中META-INF/services/java.sql.Driver文件中的驱动类 获取连接getConnection()方法参数：Url：连接路径 语法：jdbc:mysql://ip地址（域名）:端口号/数据库名称?参数键值对1&amp;参数键值对2…示例：jdbc:mysql://127.0.0.1:3306/db1细节：本机mysql服务器可以写为jdbc:mysql:///数据库名称?参数键值对1&amp;参数键值对2… User：Mysql用户名Password：Mysql密码 Connection 获取执行SQL的对象 普通执行SQl对象Statement createStatement() 预编译SQL的执行SQL对象：防止SQL注入PreparedStatement prepareStatement(sql) 执行存储过程的对象CallableStatement prepareCall(sql) 事务管理 Mysql事务管理 JDBC事务管理：ConnectionConnection接口中定义了3个对应的方法 开启事务：setAutoCommit(boolean autoCommit)：true为自动提交事务；false为手动提交事务，即为开启事务。 提交事务：commit() 回滚事务：rollback() Statement Statement作用： 执行SQl语句 执行SQL语句 int executeUpdate(sql)：执行DML，DDL语句 返回值：(1)DML语句影响的行数，(2)DDL语句执行后，执行成功也可能返回0。 ResultSet executeQuery(sql)：执行DQL语句 返回值：ResultSet结果集对象。 ResultSet ResultSet（结果集对象）作用： 封装了DQL查询语句的结果：ResultSet stmt.ResultSet(sql)：执行DQL语句，返回ResultSet对象 获取查询结果 boolean next(): （1）将光标从当前位置向前移动一行（2）判断当前行是否为有效行返回值： true：有效行，当前行有数据 false：无效行，当前行没有数据 xxx getXxx(参数)：获取数据xxx：参数类型；如int getInt（参数）；String getString（参数）参数（重载形式）： int：列的编号，从1开始 String：列的名称 ResultSet案例 需求：查询account账户表数据，封装为Account对象中，并且存储到ArrayList集合中 PreparedStatement PreparedStatement作用： 预编译SQL语句并执行：防止SQL注入问题。 获取PreparedStatement对象SQL语句中的参数值，使用？占位符代替String sql = &quot;select * from user where username = ? and password = ?&quot;;通过Connection对象获取，并传入对应的sql语句PreparedStatement pstmt = conn.prepareStatement(sql); 设置参数值PreparedStatement对象：setXxx(参数1，参数2)：给？赋值。Xxx：数据类型；如setInt(参数1，参数2)参数： 参数1：？的位置编号，从1开始 参数2：？的值 执行SQLexecuteUpdate(); 不需要再传递sql 其实区别是如果传入的是一个String的参数，pstmt会对String内的符号进行转义，防止 = 或者 ‘’ 等符号和查询语句中的符号混淆产生歧义。 SQL注入 SQL注入是通过操作输入来修改事先定义号的SQL语句，用以达到执行代码对服务器进行攻击的方法。 PreparedStatement原理 PreparedStatement好处： 预编译SQL，性能更高 防止SQL注入：将敏感字符进行转义 PreparedStatement预编译功能开启：useServerPrepStmts=true 配置MySQL执行日志（重启mysql服务后生效） 123456log-output=FILEgeneral-log=1general_log_file=&quot;D:\\mysql.log&quot;slow-query-log=1slow_query_log_file=&quot;D:\\mysql_slow.log&quot;long_query_time=2 PreparedStatement原理： 在获取PreparedStatement对象时，将sql语句发送给mysql服务器进行检查，编译（这些步骤很耗时） 执行时就不用再进行这些步骤了，速度更快 如果sql模板一样，则只需要继续你那个一次检查、编译 数据库连接池数据库连接池简介 数据库连接池是个容器，负责分配、管理数据库连接（Connection） 它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个； 释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏 好处 资源重用 提升系统响应速度 避免数据库连接遗漏 数据库连接池实现 标准接口DataSource 官方（SUN）提供的数据库连接池标准接口，由第三方组织实现此接口。 功能：获取连接Connection getConnection() 常见的数据库连接池： DBCP C3P0 Druid Druid（德鲁伊） Druid连接池是阿里巴巴开源的数据库连接池项目 功能强大，性能优秀，是Java语言最好的数据库连接池之一 Druid使用步骤 带入jar包 定义配置文件 加载配置文件 获取数据连接池对象 获取连接 理解：导入Druid的配置文件，然后使用该配置文件来创建一个Druid工厂。通过创建好的这个Druid工厂实例即可直接生成Connection对象。后面的使用方法和前面相同。 Maven Maven是专门用于管理和构建Java项目的工具，它的主要功能有： 提供了一套标准化的项目结构Maven创建的项目所有IDE都可以通用（之前不同的IDE创建的项目目录结构不同，不能通用） 提供了一套标准化的构建流程（编译，测试，打包，发布……） 标准化的构建流程： 编译 测试 打包 发布 Maven提供了一套简单的命令来完成项目构建。 提供了一套依赖管理机制依赖管理其实就是管理你项目所依赖的第三方资源（jar包，插件…） Maven使用标准的坐标配置来管理各种依赖 只需要简单的配置就可以完成依赖管理 Maven简介 Apache Maven 是一个项目管理和构建工具，它基于项目对象模型（POM）的概念，通过一小段描述信息来管理项目的构建、报告和文档。 Maven模型： 项目对象模型 依赖管理模型 插件 仓库分类： 本地仓库：自己计算机上的一个目录 中央仓库：有Maven团队维护的全球唯一的仓库 远程仓库（私服）：一般由公司团队搭建的私有仓库 当项目中使用坐标引入对应依赖jar包后，首先会查找本地仓库中是否有对应的jar包： 如果有，则再项目直接引用。 如果没有，则去中央仓库中下载对应的jar包到本地仓库。 Maven安装配置 配置MAVEN_HOME环境变量 配置本地仓库：修改conf/settings.xml中的&lt;localRepository&gt;为一个指定目录 配置阿里私服：修改conf/settings.xml中的&lt;mirrors&gt;标签，为其添加如下子标签 123456&lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;阿里云公共仓库&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;&lt;/mirror&gt; Maven基本使用Maven常用命令 compile：编译运行完成后会在项目目录下生成target文件存放项目编译后的字节码文件 clean：清理 clean命令是删除相应的编译文件的，在首次执行的时候也会下 载相应的clean插件。 test：测试该命令会自动执行Test中的类并且进行输出 package：打包打包完成后会在target文件中生成一个jar文件。 install：安装 install命令会将本项目的jar文件添加到本地仓库中。 Maven生命周期 Maven构建项目生命周期表述的是一次构建过程经历了多少个事件 Maven对项目构建的生命周期划分为三套 clean：清理工作 default：核心工作，例如编译，测试，打包，安装等 site：产生报告，发布站点等（不常用） 注意：执行test并不会执行clean IDEA配置MavenIDEA配置Maven环境1. 选择IDEA中File--&gt;Settings 2. 搜索maven 3. 设置IDEA使用本地安装的Maven，并修改配置文件路径 Maven坐标详解 什么是坐标？ Maven中的坐标是资源的唯一标识 使用坐标来定义项目或引入项目中需要的依赖 Maven坐标主要组成 groupid：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.dicemy） artifactid：定义当前Maven项目名称（通常是模块名称，例如order-service、goods-service） version：定义当前项目版本号 依赖管理使用坐标导入jar包1. 再pom.xml中编写\\&lt;dependencies&gt;标签 2. 在\\&lt;dependencies&gt;标签中使用\\&lt;dependency&gt;引入坐标 3. 定义坐标的groupid，artifactid，version 4. 点击刷新按钮，使坐标生效 依赖范围 通过设置坐标的依赖范围，可以设置对应jar包的作用范围：编译环境，测试环境，运行环境。 &lt;scope&gt;默认值：compile MyBatisMyBatis什么是MyBatis？ MyBatis是一款优秀的持久层框架，用于简化JDBC开发。 MyBatis本是Apache的一个开源项目iBatis，2010年迁移到了google code，并且改名为MyBatis。2013年11月迁移到Github 。 持久层 负责将数据保存到数据库的那一层代码。 JavaEE三层架构：表现层、业务层、持久层。 框架 框架就是一个半成品软件，是一套可重用的、通用的、软件基础代码模型 在框架的基础之上构建软件编写更加高效、规范、通用、可拓展 JDBC缺点1. 硬编码 - 注册驱动，获取连接 - SQL语句 2. 操作繁琐 - 手动设置参数 - 手动封装结果集 MyBatis简化 硬编码 =》配置文件 操作繁琐 =》自动完成 MyBatis免除了几乎所有的JDBC代码以及设置参数和获取结果集的工作。 MyBatis快速入门1. 创建user表，添加数据 2. 创建模块，导入坐标 3. 编写MyBaits核心配置文件--&gt;替换连接信息，解决硬编码问题 4. 编写SQL映射文件--&gt;统一管理sql语句，解决硬编码问题 5. 编码 1. 定义POJO类 2. 加载核心配置文件，获取SQLSessionFactory对象 3. 获取SqlSession对象，执行SQL语句 4. 释放资源 Mapper代理开发 目的 解决原生方式中的硬编码 简化后期执行SQL 使用Mapper代理方式完成入门案例 定义与SQL映射文件同名的Mapper接口，并且将Mapper接口和SQL映射文件放置在同一目录下 设置SQL映射文件中的namespace属性为Mapper接口全限定名 在Mapper接口中定义方法，方法名就是SQL映射文件中sql语句的id，并保持参数类型和返回值类型一致 编码 通过SqlSession的getMapper方法获取Mapper接口的代理对象 调用对应方法完成sql的执行 细节：如果Mapper接口名称和SQL映射文件名称相同，并在同一目录下，则可以使用包扫描的方式简化SQL映射文件的加载。 理解：每一张表进行查询都需要一个pojo 实体类，作为查询后返回的对象。还需要一个mapper接口类，里面定义用到的所有需要查询或修改的方法的名字，供主方法中调用。最后还需要一个与该mapper配套的xml配置文件，在xml配置文件中写mapper接口类中每一个方法的具体select语句。在主方法中，通过MyBatis的配置文件创建一个SqlSession工厂，然后创建一个新的SqlSession，通过SqlSession的getMapper方法来获取一个Mapper类，并返回一个mapper对象，最后通过mapper对象调用mapper中的查询或操作函数即可。 MyBatis核心配置文件详解 类型别名（tpyeAliases） 123&lt;tpyeAliases&gt; &lt;package name=&quot;com.dicemy.pojo&quot;/&gt;&lt;/tpyeAliases&gt; 细节：配置各个标签时，需要遵守前后顺序。（放到environments前就行） 配置文件完成增删改查完成品牌数据的增删改查操作 要完成的功能列表清单 查询 查询所有数据 查看详情 条件查询 添加 修改 修改全部字段 修改动态字段 删除 删除一个 批量删除 准备环境 数据库表 实体类 测试用例 安装MyBaitsX插件 Web核心 什么是JavaWeb Web：全球广域网，也成为万维网，能够通过浏览器访问的网站。 JavaWeb：是用Java技术来解决相关web互联网领域的技术栈 JavaWeb技术栈 B/S架构：浏览器/服务器架构模式。 好处：易于维护升级 静态资源：HTML，CSS，JS，图片等。负责页面展示 动态资源：Servlet，JSP等。负责逻辑处理 数据库：负责存储数据 HTTP协议：定义通信规则 Web服务器：负责解析HTTP协议，解析请求数据，并发送响应数据。 HTTP 概念：超文本传输协议，规定了浏览器和服务器之间数据传输的规则。 HTTP协议特点：1. 基于TCP协议：面向连接，安全 2. 基于请求-响应模型的：一次请求对应一次响应 3. HTTP协议是无状态的协议：对于事务处理没有记忆能力。每次请求-响应都是独立的。 - 缺点：多次请求间不能共享数据。 - 优点：速度快 HTTP-请求数据格式 请求数据分为3部分： 请求行：请求数据的第一行。其中GET表示请求方法，/表示请求资源路径，HTTP/1.1表示协议版本。 请求头：第二行开始，格式为key：value形式。 请求体：POST请求的最后一部分，存放请求参数。 常见的HTTP请求头： GET请求和POST请求区别： GET请求请求参数在请求行中，没有请求体。POST请求请求参数在请求体中。 GET请求请求参数大小有限制，POST没有 HTTP-响应数据格式 响应数据分为3部分： 响应行：响应数据的第一行。其中HTTP/1.1表示协议版本，200表示响应状态码，OK表示状态码描述。 响应头：第二行开始，格式为key：value形式。 响应体：最后一部分。存放响应数据。 常见的HTTP响应头： Tomcat Web服务器是一个应用程序，对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作，让web开发更加便捷。主要功能是“提供网上信息浏览服务”。 简介 概念：Tomcat是Apache软件基金会一个核心项目，是一个开源免费的轻量级Web服务器，支持Servlet/JSP少量JavaEE规范。 JavaEE：Java企业版。指Java企业级开发的技术规范总和。包含13项技术规范：JDBC，JNDI，EJB，RMI，JSP，Servlet，XML，JMS，Java IDL，JTS，JTA，JavaMail，JAF。 Tomcat也被称为Web容器、Servlet容器。Servlet需要一类于Tomcat才能运行。 总结 Web服务器作用？ 封装HTTP协议操作，简化开发 可以将web项目部署到服务器中，对外提供网上浏览服务 Tomcat是一个轻量级的Web服务器，支持Servlet/JSP少量JavaEE规范，也称为Web容器，Servlet容器 Tomcat-基本使用 在bin目录下有一个start.sh文件，点击即可运行 配置： 修改启动端口号：conf/server.xml HTTP协议默认端口号为80，如果将Tomcat端口号改为80，则将来访问Tomcat时，将不用输入端口号。 启动时可能出现的问题： 端口号冲突：找到对应程序，并将其关掉 启动窗口一闪而过：检查JAVA_HOME是否配置正确 Tomcat-部署项目 Tomcat部署项目: 将项目放置到webapps目录下，即部署完成 一般JavaWeb项目会被打成war包，然后将war包放到webapps目录下，T地方阿斯蒂芬阿斯蒂芬cat会自动解压缩war文件。 IDEA中创建Maven Web项目 Web项目结构： Maven Web项目结构：开发中的项目 部署的JavaWeb项目结构：开发完成，可以部署的项目 编译后的Java字节码文件和resources的资源文件，放到WEB-INF下的classes目录下 pom.xml中依赖坐标对应的jar包，放入WEB-INF下的lib目录下 使用骨架 骨架：项目模板 选择web项目骨架，创建项目 删除pom.xml中多余的坐标 补齐缺失的目录结构 不使用骨架 IDEA中使用Tomcat - 集成本地Tomcat 将本地Tomcat集成到idea中，然后进行项目部署即可 IDEA中使用Tomcat - Tomcat Maven插件 pom.xml添加Tomcat插件 使用Maven Helper 插件快速启动项目，选中项目，右键 Run Maven –&gt; tomcat7:run Servlet Servlet是Java提供的一门动态web资源开发技术 Servlet是JavaEE规范之一，其实就是一个接口，将来我们需要定义Servlet类实现Servlet接口，并由web服务器运行Servlet。 Servlet快速入门1. 创建web项目，导入Servlet依赖坐标 2. 创建：定义一个类，实现Servlet接口，并重写接口中所有方法，并在service方法中输出一句话 3. 配置：在类上使用@WebServlet注解，配置该Servlet的访问路径 4. 访问：启动Tomcat，浏览器输入URL访问该Servlet Servlet执行流程 1. Servlet由谁创建？Servlet方法由谁调用？ - Servlet由web服务器创建，Servlet方法由web服务器调用。 2. 服务器怎么知道Servlet怎么知道Servlet中一定有service方法？ - 因为我们自定义的Servlet，必须实现Servlet接口并复写其方法，而Servlet接口中有servrice方法。 Servlet生命周期 对象的生命周期指一个对象从被创建到销毁的整个过程 Servlet运行在Servlet容器（web服务器）中，其生命周期由容器来管理，分为4个阶段： 加载和实例化：默认情况下，当Servlet第一次被访问时，有容器创建Servlet对象@WebServlet（urlPatterns=”/demo”,loadOnStartUp=1） 负整数：第一次被访问时创建Servlet对象 0或正整数：服务器启动时创建Servlet对象。数字越小优先级越高。 初始化：在Servlet实例化之后，容器将调用Servlet的init（）方法初始化这个对象，完成一些如加载配置文件，创建连接等初始化的工作。该方法只调用一次 请求处理：每次请求Servlet时，Servlet容器都会调用Servlet的service（）方法对请求进行处理。 服务终止：当需要释放内存或容器关闭时，容器就回调用Servlet示例的destory（）方法完成资源的释放。在destory（）方法调用之后，容器会释放这个Servlet示例，该示例随后会被Java的垃圾收集器回收 Servlet方法介绍 初始化方法，在Servlet被创建时执行，只执行一次 1void init(ServletConfig config) 提供服务方法，每次Servlet被访问，都会调用该方法 1void service(ServletRequest req, ServletResponse res) 销毁方法，当Servlet被销毁时，调用该方法。在内存释放或服务器关闭时销毁Servlet 1void destroy() 获取ServletConfig对象 1ServletConfig getServletConfig() 获取Servlet信息 1String getServletInfo() Servlet体系结构 我们将来开发B/S架构的web项目，都是针对HTTP协议，随意我们自定义Servlet，会继承HttpServlet 总结 HttpServlet使用步骤 集成HttpServlet 重写doGet和doPost方法 HttpServlet原理 获取请求方式，并根据不同的请求方式，调用不同的doXxx方法。 Servlet urlPattern配置 Servlet想要被访问，必须配置其访问路径（urlPattern） 一个Servlet，可以配置多个urlPattern@WebServlet(urlPatterns = {“/demo1”, “demo2”}) urlPattern配置规则 精确匹配 目录匹配 拓展名匹配 任意匹配 XML配置方式编写Servlet Servlet从3.0版本后开始支持使用注解配置，3.0版本前只支持XML配置文件的配置方式 步骤： 编写Servlet类 在web.xml中配置该Servlet Request&amp;ResponseRequest（请求）&amp; Response（响应） Request：获取请求数据 Response：设置响应数据 RequestRequest继承体系 1. Tomcat需要解析请求数据，封装为Request对象，并且创建Request对象传递到service方法中 2. 使用Request对象，查阅JavaEE API文档的HttpServletRequest接口 Request获取请求数据获取请求数据 请求数据分为3部分： 请求行：GET /request-demo/req1?username=zhangsan HTTP/1.1 String getMethod（）：获取请求方式：GET String getContextPath（）：获取虚拟目录（项目访问路径）：/request-demo StringBuffer getRequestURL（）：获取URL（统一资源定位符）：http://locallhost:8080/request-demo/req1 String getRequestURI（）：获取URI（统一资源标识符）：/request-demo/req1 String getQueryString（）：获取请求参数（GET方式）：username=zhangsan&amp;password=123 请求头：User-Agent:Mozilla/5.0 Chrome/91.0.4472.106 String getHeader(String name)：根据请求头名称，获取值 请求体：username=superbaby&amp;password=123 ServletInputStream getInputStream()：获取字节输入流 BufferedReader getReader()：获取字符输入流 通用方法获取请求参数 请求参数获取方法： GET方式： 1String getQueryString() POST方式： 1BufferedReader getReader() 通用方法获取参数： Map&lt;String, String[]&gt; getParameterMap()：获取所有参数Map集合 String[] getParameterValues(String name)：根据名称获取参数值（数组） String getParameter(String name)：根据名称获取参数值（单个值） 通过通用方式获取请求参数后，屏蔽了GET和POST的请求方式代码的不同，则代码可以定义为如下格式： 可以使用Servlet模板创建Servlet更高效 请求参数中文乱码处理 请求参数如果存在中文数据，则会乱码 解决方案： POST：设置输入流的编码 1req.setCharacterEncoding(&quot;UTF-8&quot;); 通用方式（GET/POST）：先编码，再解码 1new String(username.getBytes(&quot;ISO-8859- 1&quot;),&quot;UTF-8&quot;); URL编码 将字符串按照编码方式转为二级制 每个字节转为2个16进制数并在前面加上% Request请求转发请求转发 请求转发：一种在服务器内部的资源跳转方式 实现方式: 1req.getRequsetDispatcher(&quot;资源B路径&quot;).forward(req,resp); 请求转发资源间共享数据：使用Request对象 void setAttribute(String name, Object o)：存储数据到request域中 Object getAttribute(String name)：根据key，获取值 void removAttribute(String name)：根据key，删除该键值对 请求转发特点： 浏览器地址栏领不发生变化。 只能转发到当前服务器的内部资源。 一次请求，可以在转发的资源间使用requset共享数据。 ResponseResponse设置响应数据功能介绍 响应数据分为3部分： 响应行：HTTP/1.1 200 Ok void setStatus(int sc)：设置响应状态码 响应头：Content-Type:text/html void setHeader(String name, String value)：设置响应头键值对 响应体：&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; PrintWriter getWriter()：获取字符输出流 ServletOutputStream getOutputStream()：获取字节输出流 Response完成重定向 重定向（Redirect）：一种资源跳转方式 实现方式： 12resp.setStatus(302);resp.setHeader(&quot;location&quot;,&quot;资源B的路径&quot;); 1resp.sendRedirect(&quot;资源B的路径&quot;); 重定向特点： 浏览器地址栏路径发生变化 可以重定向到任意位置的资源（服务器内部、外部均可） 两次请求，不能在多个资源使用request共享数据 路径问题 明确路径谁使用？ 浏览器使用：需要加虚拟目录（项目访问路径） 服务端使用：不需要加虚拟目录 Response响应字符数据 使用： 通过Response对象获取字符输出流 1PrintWriter resp.getWrite(); 写数据 1writer.write(&quot;aaa&quot;); 注意： 该流不需要关闭，随着响应结束，Response对象销毁，由服务器关闭 中文数据乱码：原因通过Response获取的字符输出流默认编码：ISO-8859-1 1resp.setContentType(&quot;text/html;charset=utf-8&quot;); Response响应字节数据 使用： 通过Response对象获取字符输出流 1ServletOutputStream outputStream = resp.getOutputStream(); 写数据 1outputStream.write(字节数据); IOUtils工具类使用 导入坐标 12345&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt; 使用 1IOUtils.copy(输入流，输出流); 代码优化 创建SqlSessionFactory代码优化 123String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); 问题： 代码重复：工具类 SqlSessionFactory工厂只创建一次，不要重复创建：静态代码块 JSP 概念：Java Server Pages， Java服务端页面 一种动态的网页技术，其中既可以定义HTML，JS，CSS等静态内容，还可以定义Java代码的动态内容。 JSP=HTML+Java JSP的作用：简化开发，避免了在Servlet中直接输出HTML标签 JSP本质上就是一个Servlet JSP已逐渐退出历史舞台 EL表达式 表达式语言，用于简化JSP页面内的Java代码 主要功能：获取数据 语法：${exp ression}${brands}：获取域中存储的key为brands的数据 JavaWeb中的四大域对象： Page:当前页面有效 Requeset:当前请求有效 Session:当前会话有效 Application:当前应用有效 JSTL标签 JSP标准标签库，使用标签取代JSP页面上的Java代码 123456&lt;c:if test=&quot;${flag == 1}&quot;&gt; 男&lt;/c:if&gt;&lt;c:if test=&quot;${flag == 2}&quot;&gt; 女&lt;/c:if&gt; MVC模式和三层架构MVC模式 MVC是一种分层开发的模式，其中： M：Model，业务模型，处理业务 V：View，试图，界面展示 C：Controller，控制器，处理请求，调用模型和视图 MVC好处 职责单一，互不影响 有利于分工协作 有利于组建重组 三层架构 数据访问层：对数据库的CRUD基本操作。 业务逻辑层：对业务逻辑进行封装，组合数据访问层层中基本功能，形成复杂的业务逻辑功能。 表现层：接受请求，封装数据，调用业务逻辑层，响应数据。 MVC模式和三层架构的对比 案例查询所有 添加 修改-回显数据 修改-修改数据 会话跟踪技术 会话：用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应。 会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据。 HTTP协议是无状态的，每次浏览器向服务器请求时，服务器都会将该请求视为新的请求，因此我们需要会话跟踪技术来实现会话内数据共享。 实现方式： 客户端会话跟踪技术：Cookie 服务端会话跟踪技术：Session Cookie基本使用 Cookie：客户端会话技术，将数据保存到客户端，以后每次请求都携带Cookie数据进行访问 Cookie基本使用Cookie原理 Cookie的实现是基于HTTP协议的 响应头：set-cookie 请求头：cookie Cookie使用细节 Cookie存活时间 默认情况下，Cookie存储在浏览器内存中，当浏览器关闭，内存释放，则Cookie被销毁 setMaxAge（int seconds）：设置Cookie存活时间 正数：将Cookie写入浏览器所在电脑的硬盘，持久化存储。到时间自动删除 负数：默认值，Cookie在当前浏览器内存中，当浏览器关闭，则Cookie被销毁 零：删除对应Cookie Cookie存储中文 Cookie不能直接存储中文 如需要存储，则需要进行转码：URL编码 Session基本使用 Session：服务端会话跟踪技术，将数据保存到服务端 JavaEE提供HttpSession接口，来实现一次会话的多次请求间数据共享功能 使用： 获取Session对象HttpSession session = request.getSession(); Session对象功能： Void setAttribute（String name， Object o）：存储数据到session域中 Object getAttribute（String name）：根据key，获取值 Void removeAttribute（String name）：根据key，删除该键值对 Session原理 Session是基于Cookie实现的 Session使用细节 Session钝化、活化： 服务器重启后，Session中的数据是否还在？ 钝化：在服务器正常关闭后，Tomcat会自动将Session数据写入硬盘的文件中 活化：再次启动服务器后，从文件中加载数据到Session中 Session销毁： 默认情况下，无操作，30分钟自动销毁 123&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config&gt; 调用Session对象的invalidate（）方法 Cookie和Session小结 Cookie和Session都是来完成一次会话内多次请求间数据共享的 区别： 存储位置：Cookie是将数据存储在客户端，Session将数据存储在服务端。 安全性：Cookie不安全，Session安全。 数据大小：Cookie最大3KB，Session默认30分钟 服务器性能：Cookie不占服务器资源，Session占用服务器资源。 Filter 概念：Filter表示过滤器，是JavaWeb三大组件（Servlet，Filter，Listener）之一。 过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能。 过滤器一般完成一些通用的操作，比如：权限控制，同一编码处理，敏感字符处理等等… Filter快速入门 定义类，实现Filter接口，并重写其所有方法 配置Filter拦截资源的路径：在类上定义@WebFilter注解 在doFilter方法中输出一句话，并放行 Filter执行流程 Filter拦截路径配置 Filter可以根据需求，配置不同的拦截资源路径 拦截具体的资源：/index.jsp：只有访问index.jsp时才会被拦截。 目录拦截：/user/*：访问/user下的所有资源，都会被拦截。 后缀名拦截：*.jsp：访问后缀名为jsp的资源，都会被拦截。 拦截所有：/*：访问所有资源，都会被拦截。 过滤器链 一个Web应用，可以配置多个过滤器，这多个过滤器称为过滤器链 注解配置的Filter，优先级按照过滤器类名（字符串）的自然排序 Listener（用的不多） Listener表示监听器，是JavaWeb三大组件（Servlet，Filter，Listener）之一。 监听器可以监听就是在application，session，request三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件 Listener分类：JavaWeb中提供了8个监听器 AJAX 概念：异步的JavaScript和XML AJAX作用： 与服务器进行数据交换：通过AJAX可以给服务器发送请求，并获取服务器响应的数据。 使用了AJAX和服务器进行通信，就可以使用HTML+AJAX来替换JSP界面了 异步交互：可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术，如：搜索联想，用户名是否可用校验，等等… 同步和异步 AJAX快速入门 编写AjaxServlet，并使用Response输出字符串 创建XMLHttpRequest对象：用于和服务器交换数据 向服务器发送请求 获取服务器响应数据 Axios异步框架 Axios对原生的AJAX进行封装，简化书写 官网：https://www.axios-http.cn/ Axios快速入门 引入axios的js文件 1&lt;script src=&quot;js/axios.min.js&quot;&gt;&lt;/script&gt; 使用axios发送请求，并获取响应结果 123axios.post(&quot;http://localhost:8080/filter-demo/axiosServlet&quot;,&quot;username=zhangsan&quot;).then(function (resp) { alert(resp.data)}) JSON 概念：JavaScript对象表示法。 由于其语法简单，层次结构鲜明，现多用于作为数据载体，在网络中进行数据传输。 JSON基础语法 JSON数据和Java对象转换 请求数据：JSON字符串转为Java对象 响应数据：Java对象转换为JSON字符串 Fastjson是阿里巴巴提供的一个Java语言编写的高性能功能完善的JSON库，是目前Java语言中最快的JSON库，可以实现Java对象和JSON字符串的相互转换。 使用： 导入坐标 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.62&lt;/version&gt;&lt;/dependency&gt; Java对象转JSON 1String jsonStr = JSON.toJSONString(obj); JSON字符串转Java对象 1User user = JSON.parseObject(jsonStr, User.class); Vue Vue是一套前端框架，免除原生JavaScript中的DOM操作，简化书写。 基于MVVM思想，实现数据的双向绑定，将编程的关注点放在数据上。 官网：https://cn.vuejs.org/ Vue快速入门 新建HTML界面，引入Vue.js文件 1&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; 在JS代码区域，创建Vue核心对象，进行数据绑定 12345678new Vue({ el:&quot;#app&quot; data(){ return{ username:&quot;&quot; } }}); 编写视图 1234&lt;div id=&quot;app&quot;&gt; &lt;input name=&quot;username&quot; v-model=&quot;username&quot;&gt; {{username}}&lt;/div&gt; Vue常用指令 V-bind: 1&lt;a v-bind:href=&quot;url&quot;&gt;百度一下&lt;/a&gt; 1234&lt;!-- v-bind可以省略--&gt;&lt;a :href=&quot;url&quot;&gt;百度一下&lt;/a&gt; v-model: 1&lt;input name=&quot;username&quot; v-model=&quot;username&quot;&gt; v-on: html： 123&lt;input type=&quot;button&quot; value=&quot;一个按钮&quot; v-on:click=&quot;show()&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;一个按钮&quot; @click=&quot;show()&quot;&gt; Vue: 12345678new Vue({ el:&quot;#app&quot;, methods:{ show(){ alert(&quot;我被点了&quot;); } }}) Vue生命周期 生命周期的八个阶段：每触发一个生命周期事件，会自动执行一个生命周期方法（钩子） mounted：挂载完成，Vue初始化成功，HTML页面渲染成功。 发送异步请求，加载数据 Element Element是饿了么公司前端开发团队提供的一套基于Vue的网站组件库，用于快速构建网页。 组件：组成网页的部件，例如 超链接、按钮等等 Element快速入门 引入Element的css，js文件和Vue.js 123&lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;&gt;&lt;script src=&quot;WEB-INF/js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://unpkg.com/element-ui/lib/index.js&quot;&gt;&lt;/script&gt; 创建Vue核心对象 12345&lt;script&gt; new Vue({ el:&quot;#app&quot; })&lt;/script&gt; 官网复制Element组件代码 Element布局 Element中有两种布局方式： Layout布局：通过基础的24分栏，迅速简单地创建布局 Container布局容器：用于布局的容器组件，方便快速搭建页面的基本结构 Element组件 在官网上找，然后复制粘贴修改即可。 完结 end.","link":"/60206"},{"title":"Hyperledger fabric开发入门","text":"注意：不要在有生产环境的服务器上进行学习测试，（docker-compose关闭服务的时候会清除服务器上所有正在运行的的docker容器） 参考课程：CSDN_超级账本智能合约与DApp 环境配置目录结构在gopath中创建 mkdir src mkdir bin mkdir pkg 在src中创建mkdir github.com 在github.com中创建mkdir hyperledger docker安装一行命令，完成安装：（安装之后记得要把docker服务启动起来） curl -sSL https://get.daocloud.io/docker | sh service docker start 而且源在国内 docker-compose安装通过curl进行安装： curl -L https://github.com/docker/compose/releases/download/1.7.0/docker-compose-``uname -s ``-``uname -m`` &gt; /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose docker-compose -v go安装与配置参考：http://dicemy.com/29920#Go%E8%AF%AD%E8%A8%80%E5%AE%89%E8%A3%85 一定要注意环境变量的配置 jdk安装 yum list java* yum install -y java-1.8.0-openjdk-devel.x86_64 java -version 下载fabric的docker镜像除了baseos下载0.3.1，其余都下1.0.0，然后标记为latest tools：docker pull hyperledger/fabric-tools:x86_64-1.0.0 ccenv：docker pull hyperledger/fabric-ccenv:x86_64-1.0.0 ca：docker pull hyperledger/fabric-ca:x86_64-1.0.0 orderer：docker pull hyperledger/fabric-orderer:x86_64-1.0.0 peer：docker pull hyperledger/fabric-peer:x86_64-1.0.0 baseos：docker pull hyperledger/fabric-baseos:x86_64-0.3.1 纯命令版： docker pull hyperledger/fabric-tools:x86_64-1.0.0 docker pull hyperledger/fabric-ccenv:x86_64-1.0.0 docker pull hyperledger/fabric-ca:x86_64-1.0.0 docker pull hyperledger/fabric-orderer:x86_64-1.0.0 docker pull hyperledger/fabric-peer:x86_64-1.0.0 docker pull hyperledger/fabric-baseos:x86_64-0.3.1 注意：记得在所有的安装之后进行tag 编辑成latest状态否则会出现问题 docker tag xxxx xxxx:latest docker tag hyperledger/fabric-tools:x86_64-1.0.0 hyperledger/fabric-tools:latest docker tag hyperledger/fabric-ccenv:x86_64-1.0.0 hyperledger/fabric-ccenv:latest docker tag hyperledger/fabric-ca:x86_64-1.0.0 hyperledger/fabric-ca:latest docker tag hyperledger/fabric-orderer:x86_64-1.0.0 hyperledger/fabric-orderer:latest docker tag hyperledger/fabric-peer:x86_64-1.0.0 hyperledger/fabric-peer:latest docker tag hyperledger/fabric-baseos:x86_64-0.3.1 hyperledger/fabric-baseos:latest 下载fabric源码库在hyperledger目录下进行git clone https://github.com/hyperledger/fabric.git git checkout release-1.0 cd /home/gopath/src/github.com/hyperledger/fabric/common/configtx/tool/configtxgen 对工具进行编译。go install --tags=nopkcs11 注意！！！ 奇怪的错误请输入：go env -w GO111MODULE=auto 一定要把这个项目文件的src放在go环境设置下的gopath的文件夹中，输入go env可以查看go安装环境中的gopath文件夹。否则会出现找不到包的报错。 对另一个工具进行编译。cd /home/gopath/src/github.com/hyperledger/fabric/common/tools/cryptogen go install --tags=nopkcs11 编译好的工具如下: 下载fabric-samplescd /home/gopath/src/github.com/hyperledger git clone https://github.com/hyperledger/fabric-samples.git git checkout release-1.0 Hello World1.查看目录 .env：存储一些环境变量 base：储存docker-compose的一些公共服务 byfn.sh：执行脚本 configtx.yaml和crypto-config.yaml：根据之前生成的2个工具，生成相应的配置文件，用来启动网络，放到当前目录的channel-artifacts和crypto-config里面 docker-compose：用于启动网络 scripts：存放测试脚本，做的事：创建通道，加入通道，安装链码，实例化链码，链码交互 2.生成配置./byfn.sh -m generate -i 1.0.0 注意！！！！ 一定要记得吧gopath中的bin目录添加到环境变量中，否则可能无法调用刚才编译好的configtxgen和cryptogen工具 可以通过 export PATH=$PATH:/home/gopath/bin 来临时添加或者使用vim ~/.bash_profile修改PATH 一行，之后使用source ~/.bash_profile生效。 3.启动网络，自动运行测试脚本./byfn.sh -m up -i 1.0.0 4.关闭网络，自动清楚配置和docker进程./byfn.sh -m down -i 1.0.0 Hello World 分析1.查看日志，order和peer分离 peer是按照组织或主体分离的，每一个组织生成ca（存储证书和私钥），msp（存储管理员证书和中间证书），peers（存储每一个peer相关的证书），users（存储每一个用户的证书） 2.查看如下配置genesis.block：整个网络的创世区块 channel.tx：创建的通道的配置 Org1MSPanchors.tx和Org2MSPanchors.tx：两个主体的锚节点配置 3.启动网络，接着分析日志fabric网络启动完毕 指定通道名称，和一些变量，通道创建完成 4个peer加入通道 组织中的锚节点在通道中update成功 链码安装到了peer节点 链码实例化 在peer0上进行查询操作，成功 圈圈的是查询结果，查询成功，查询结果为100 进行修改操作，成功 再次查询，结果为90 查看docker进程 3个链码会生成3个image 查看脚本 可以按脚本中的位置找到链码 实现了Init和Invoke接口，就代表是一个fabric智能合约 Init：首先获取参数，不为4个则报错，最终将A和B存到数据库中 Invoke：设置了3个方法，（invoke，delete，query） invoke：接受3个参数，（谁给谁转账，赚多少） A给B转账。 持久化数据 接受1个值，从数据库中删除 查询操作，结果以json形式返回 main里只start或者进行一些验证，不写其他代码 srcipts中：初始化操作，A有100元，B有200元 查询A有多少钱，所以打印了100 A给B转账10元 fabric系统架构架构图 应用层 API：提供了GRPC，（谷歌）RPC框架 SDK：在API基础上封装的SDK，go，java，python，nodejs 事件：分布式系统中，达成共识需要一定的时间，fabric使用异步通信模式开发，触发回调函数执行。 身份：依托于底层的成员服务，是联盟链的认证功能，例如CA 账本：区块链的查询数据，是账本中查出来的，区块高度+交易ID，不重复 交易：对区块链数据进行修改，先提交交易到背书节点，签名认证之后再执行。 智能合约：做合约的安装，实例化和升级 区块链底层 成员服务：提供证书，用于加密和签名 共识服务：CAP（不能全满足，只能满足2个，一致性，可用性和分区容忍性），实际上区块链是弱化了可用性和分区容忍性，所以需要共识算法保证一致性。fabric的共识大概分为三个阶段： 首先客户端向背书节点发送一个背书提案，背书节点进行交易模拟，将背书节点和签名返回客户端。 然后将背书后的交易，交给排序节点进行排序。有排序节点生成区块，向全网广播。网络节点接受到广播后，先验证区块交易的正确性。 验证通过后，存入本地账本。 PS：排序节点与组织的锚节点使用的是GRPC通信，组织内使用的是gossip协议通信 链码服务：提供安全的，可隔离的交易环境。所以fabric使用docker，链码直接与docker通信。目前阶段对k8s支持的不好，会出问题。 安全及密码服务：fabric定义了一个BCCSP接口，定义签名，加密解密功能，是默认实现了一套国际通用的密码服务，如sha256等 网络拓扑图 概念： 客户端节点：应用程序和底层的交互媒介，与上层和peer和orderer连接发挥作用，连接peer做交易模拟 peer节点：包含了锚节点（主节点），在一个组织内可以有多个peer，一个组织中锚节点只有一个，锚节点的作用（与orderer进行通信），锚节点需要HA支持，若锚节点挂了，组织内会选举新的节点与orderer节点进行通信，背书节点（Endorse）理解为担保，与智能合约绑定的，每一个智能合约安装到区块链中，会有一个专属的背书策略，记账节点（committer）所有的peer节点都是记账节点。用于验证从orderer接受的区块，验证交易的有效性，验证通过后，同步到本地账本。 orderer节点：排序节点，接受全网客户端节点的交易信息，按照一定规则进行排序，将排序好的交易，按照固定的时间间隔打包成区块。与其他组织的主节点进行通信，排序可以用solo（整个网络中只有一个排序节点，使用于开发和测试）和kafka（生产环境下使用，分布式消息队列）模式 CA节点：可选的，作用：颁发证书，只用被CA认证的节点才能进行交易，fabric不存在51%攻击问题。 动作和行为： 注册登记：与客户端发起，向CA机构表明自己的身份，获取证书，上图中是第三方的CA，也可以使用官方提供的CA。 交易提案：向组织的背书节点提交请求，对应peer节点，组织可以理解为现实中的商业主体，组织是独立的，有两个个数据来源。 提交交易：客户端节点向排序节点发请求，orderer内部进行排序打包成区块，广播给其他组织的锚节点，上图是基于kafka实现的，每个组织会选择一个orderer节点进行通信。 交易流程 客户端提交交易，最终到记账节点同步数据。 智能合约按照要指定背书节点，正常情况下，背书节点返回相同的结果，但签名是不一样的。 背书是模拟的过程，不会持久化 1,2,3是交易模拟，4,5,6是交易排序，7,8,9是交易同步和记账。交易模拟对应智能合约，交易排序对应共识机制，同步和记账对应账本存储 fabric共识排序共识机制 达成公式需要3个阶段，交易背书，交易排序，交易验证。 交易背书：模拟的 交易排序：确定交易顺序，最终将排序好的交易打包区块分发。 交易验证：区块储存前要进行一下交易验证（不是所有的orderer的东西都能存进去） Orderer节点的作用 交易排序 目的：保证系统的最终一致性（有限状态机） solo：单节点排序 kafka：外置的分布式消息队列 区块分发： orderer中的区块并不是最终持久化的区块， 是一个中间状态的区块 包含了所有交易，不管是有有效还是无效，都会打包传给组织的锚节点。 多通道的数据隔离 客户端可以使用某个通道，发送交易 源码目录 从goland中阅读 源码目录 bccsp：与密码学相关的，加密，数字签名，证书，将密码学中的函数抽象成了接口，方便调用和扩展 bddtests：行为驱动开发，从需求直接到开发 common：公共库，错误处理，日志处理，账本存贮，相关工具 core：是fabric核心库，子目录是各个模块的目录 comm：网络通信相关 devenv：官方提供的开发环境，使用的是Vagrant docs：文档 events：事件监听机制 gossip：通信协议，组织内部的通信，区块同步 gotools：用于编译 images：docker镜像相关的 msp：成员服务管理，member serivce provider 读取证书做签名 orderer：排序节点 peer：peer节点 proposals：用于扩展，新功能的提案 protos：数据结构的定义 共识机制源码 如果使用goland查看源码时import全部标红的话，进入这个设置，将第一个Enable Go … 这个框勾掉即可。 orderer节点的源码 首先看orderer目录下的main.go main.go里有一个NewServer 从sever.go可以具体查看交易收集和广播区块 点击Manager，进入Manager.go查看源码（还在sever.go里） 点击chainsupport，查看（在manager.go中） 点receiver进去，看区块切割（在chainsupport.go中） 回顾共识机制源码 main.go是入口，orderer节点的初始化 manager.go是控制中枢，是对链的操作，拿到chainsupport对象 chainsupport.go链对象额代理，与链式对应的关系 Cut（）方法是区块切割 solo和kafka相关的设置 sever.go有两个Handle，是交易收集和区块扩散的方法 将共识简化为了排序，最终一致性 fabric账本存储账本存储概念 peer节点做账本存储 orderer是临时存储区块，peer节点时账本存储的持久化，会改变世界状态。 文件系统，区块是存储为文件 区块索引，用于查询区块，是用levelDB实现的 状态数据库，一般村存放区块链最新状态，数据不需要HA，可以从文件系统再次获取，couchDB支持模糊查询 交易读写集 回忆交易流程 交易模拟 在背书节点执行模拟时，最终返回交易读写集（RWset），告诉区块链在交易中读写了哪些数据 交易排序 交易验证，交易验证后，更新世界状态，更新的就是读写集中的写集 交易读写集的3个概念 读集：包含键的列表，键的提交版本，读取赌赢的值，返回的是已提交的状态的值（读已提交），不能读取交易过程中写入的数据。 写集：包含键的列表，写入的数据的值，如果多次写入，以最后一次为准。 版本号：用区块高度和交易编号组成的。 交易验证阶段是对读写集进行验证（验证读集） 验证读集的版本号是和否等于世界状态的版本号 账本存储相关概念 世界状态 交易执行后，所有键的最新值 历史数据索引（可选） 区块储存 按照文件去存 blockfile_xxxx 文件大小是64M，若修改，需要重新编译peer源码 账本最大容量64M* 区块读取 区块文件流 区块流 迭代器 区块索引 键：区块高度，区块哈希，交易哈希 值：区块文件编号，文件内的偏移量，区块数据的长度 区块提交 保存到文件 账本存储相关源码 从4方面看，读写集，状态数据， 历史数据，区块文件 可以先从core/ledger 下的 ledger_interface.go 中看大体结构 读写集，分为交易读写集的生成和交易读写集的验证两个部分去看。 交易读写集生成 fabric/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/lockbased_tx_simulator.go 交易读写集验证 fabric/core/ledger/kvledger/txmgmt/validator/statebasedval/state_based_validator.go 状态数据库：看levelDB的实现 fabric/core/ledger/kvledger/txmgmt/statedb/stateleveldb/stateleveldb.go 历史数据库：看levelDB的实现 fabric/core/ledger/kvledger/history/historydb/historyleveldb/historyleveldb.go 区块文件读取 fabric/common/ledger/blkstorage/fsblkstorage/fs_blockstore.go 区块流：fabric/common/ledger/blkstorage/fsblkstorage/block_stream.go 账本存储相关源码总结 首先看了账本根存储的根目录的接口，从宏观上把握 交易读写集的生成和验证 数据库增删改查 要有一个没有实现的方法，数据剪裁的接口，可能去解决数据无限增长的处理 fabric智能合约智能合约fabric_asset配置好的文件下载：点击下载fabric_asset.zip 执行环境：以太坊虚拟智能合约执行环境EVM，fabric执行环境是docker 链码 是应用层和区块链底层的中间点 每一个链码执行环境是一个独立的docker 使用GRPC协议与背书节点通讯，只有背书节点才能运行智能合约 链码的生命周期 打包，智能合约的编写和编译 安装，将打包好的文件，上传到背书节点 实例化，实际的安装了，执行Init方法，只执行一次，构造函数 升级，升级和修复链码 交互，自己定义的方法的调用 链码的交互流程 系统链码（了解） LSCC：管理链码的生命周期 CSCC：配置管理链码，管理链的配置 QSCC：查询账本存储，是一个区块索引的外部服务 ESCC：交易背书的链码，交易执行后的链码进行封装签名，给客户端返回背书交易结果。 VSCC：交易验证的链码 链码编程的接口 Init()：链码初始化，只执行一次 Invoke()：链码的业务逻辑的编写 上面2个方法参数一样，参数是SDK的接口 链码SDK的接口 写代码再看 一些注意点 分布式多机多节点执行，链码会执行很多次 不写随机函数，交易会无效，多次执行不一样 系统时间不写，多机时间不一定一样 网络搭建配置的实现 crypto-config.yaml：用于配置组织节点的个数，参考firstnetwork去编写 编写好后，传到linux对应目录 进入deploy目录，设置工作目录为当前目录 export FABRIC_CFG_PATH=$GOPATH/src/fabric_asset/deploy 指定按照yaml文件生成配置 cryptogen generate --config=./crypto-config.yaml configtx.yaml：用于区块联盟中的组织信息，配合名字和证书等的位置，参考firstnetwork去编写 编写好后，传到linux对应目录 创建用于存放配置的目录 生成系统链的创世区块 -profile 指定联盟配置，-outputBlock 指定存放的位置 configtxgen -profile OneOrgsOrdererGenesis -outputBlock ./config/genesis.block 生成通道的创世交易 profile 指定业务联盟，outputCreateChannelTx存放的路径，插件的名字叫做mychannel configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./config/mychannel.tx -channelID mychannel 注意：如果使用虚拟机为平台的话，会出现用ssh连接执行命令执行出错的情况发生，具体原因不详，但是在虚拟机上可以正常执行并生成成功。 生成两个组织锚节点的交易信息 configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./config/Org0MSPanchors.tx -channelID mychannel -asOrg Org0MSP configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./config/Org1MSPanchors.tx -channelID mychannel -asOrg Org1MSP 将docker-compose.yaml拖进deploy目录 启动网络 启动docker，后台运行 查看orderer节点的运行日志 与客户端交互操作 创建通道 -o 指定与哪个orderer节点进行通信，-c指定创建的通道名称，-f指定使用的文件 出现的错误一般情况下是docker-compose中书写有误，e.g.映射路径中etc目录写成了ect 加入通道 查看peer加入的通道列表： 指定主节点 基础网络完成了 安装链码 -n是安装的名字，-v是version，-l是使用的语言 克隆一个会话，交互执行peer0，查看安装的链码 链码实例化 链码交互执行 多次执行查询，得到的结果不同，因为invoke（）中使用了随机数，不要这么做。 fabric链码案例链码入门 编写hello.go，完成后，拖到linux对应目录 安装链码 -n是安装的名字，-v是version，-l是使用的语言 实例化链码 链码调用 账户相关链码 Init（）方法与例子程序类似 Invoke（）方法包含query，invoke，set，get， 编写完成后拖到linux对应目录 启动容器 交互执行 创建通道 加入通道 设置主节点 安装链码 实例化链码 查询user1的余额 user1给user2转200元 向user1存100元 向user1取200元 贷款还款相关链码 编写Trace下的代码，编写好后，拖到对应linux目录 保证网络基础OK的情况下，安装链码 实例化链码 运行测试 贷款500W 还款500 公民身份信息相关链码 编写citizens下的代码，编写好后，拖到对应linux目录 安装链码 链码实例化 身份查询 合约相关链码 编写contract下的代码，编写好后，拖到对应linux目录 安装链码 链码实例化 发布合约 响应合约 合约成交 合约关闭 查询合约的最新数据 查询合约所有数据 fabric链码案例流程整理 让什么数据上链 所有节点备份数据耗费空间，视频等不要上链 如何交互 -c “Args”:[方法名，参数] 编写合约 Init Invoke 拖到linux运行，基于配置好的网络去部署运行（安装和实例化） 合约交互 SDK调用（页面点击或输入信息） 需求分析 开发转让资产 功能 用户开户和销户 资产登记，资产上链，与具体的用户绑定 资产转让，资产的所有权变更 查询功能，用户查询，资产查询，资产变更的历史查询 业务实体 用户 名字 身份证（表示） 资产列表 资产 名字 标识 特殊属性列表（车：排量，品牌，座位） 资产的变更记录 资产标识 资产的原始拥有者 资产变更后的拥有者 交互方法 用户开户 参数：名字，标识 用户销户 标识 资产登记 名字，标识，特殊属性列表，拥有者 资产转让 拥有者，资产标识，受让者 用户查询 参数：标识，返回值：用户实体 资产查询 参数：标识，返回值：资产实体 资产的变更查询 参数：资产标识，返回值：资产的变更列表 合约编写 合约编写完成，传到linux对应目录 创建通道的创世交易（channel名字不能有大写） configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./config/assetschannel.tx -channelID assetschannel 如果出现这个提醒 很有可能是FABRIC_CFG_PATH环境变量没有配置成功，可以直接在deploy目录下设置export FABRIC_CFG_PATH=$PWD再次执行该命令即可 交互执行 创建通道 加入通道 查看通道 安装链码 链码实例化 注册 用户查询 资产登记 资产查询，查询用户资产绑定 注册了第二个用户 资产转让 查询用户二的用户状态 查询资产一的状态 查询所有资产的变更历史 注销用户2，下面的资产也会随之注销 链码开发者模式 将docker-compose关闭 修改docker-compose配置 运行docker 在另一个会话找到编写好的智能合约 运行链码 在另一个会话进入交互执行 链码安装，实例化，调用之后，修改链码 将第二个，链码运行的对话ctrl+C结束，重新运行链码执行命令 注意：链码开发用这个模式没问题，SDK调用时，可能会出现问题，开发完智能合约关掉开发者模式 外部服务分析 如何提供外部服务 企业内部各种数据接口，rpc，grpc 网站（web），手机（app），通过http 智能硬件，socket服务 SDK提供外部服务，SDK的语言选择 node.js（官方推荐，效率 9颗星） java（实际使用量最大的 9颗星） python（使用不太多 3颗星） golang（不稳定，常用方法也没有，1颗星） SDK的模块 区块链的管理：例如通道的创建和加入，链码的安装，实例化等 数据查询：区块和交易的查询 区块链交互（链码交互）：发起交易，invoke，query 事件监听：业务事件，系统事件 JavaSDK的使用maven为什么使用mavenmaven能解决哪些问题？ 引入jar包 解决jar包之间的依赖关系 自动获取第三方jar包 将项目拆分成多个功能模块 maven简介1.什么是构建？ 从开发到运行的一个过程 2.构建的环节 清理：删除以前的编译结果，为重新编译做准备 编译：将java编译成.class 测试：对项目中关键点进行自动测试 报告：日志打印 打包：将java项目打包成.jar文件，加你个JavaWeb的项目打成.war包 安装：将打包结果（jar包或war包），安装到maven仓库 部署：将打包结果部署到远程仓库，或者将war部署到服务器上运行。 3.自动化构建 maven进行自动化构建 maven安装1.安装 解压到一个目录 配置环境变量，并加入PATH 打开cmd验证安装 maven仓库默认目录为 修改仓库路径，将settings.xml放到.m2下 修改settings.xml，指定仓库位置 Eclipse里配置maven 如下 去掉勾选 使用自己解压的maven maven工程的创建创建java工程 创建项目 创建简单工程 填写坐标，选择打包方式 创建web工程 maven仓库1.仓库的分类 本地仓库 将maven所有jar存储到本地硬盘 远程仓库 中央仓库：为全世界所有maven工程提供服务的 中央仓库的镜像：亚洲镜像 私服：在公司内网自己人访问， 2.仓库中的文件 存储三类文件 maven的插件 自己开发的项目模块 第三方框架或工具jar包 maven详解1.maven报错 创建工程直接报错，插件下载不完整 2.约定的目录结构 src/main/java 主程序源码目录 src/main/resources 主程序配置文件目录 test是测试的 target编译结果的目录 3.POM文件 Project Object Model：项目对象模型 pom是maven的核心配置 maven父子工程创建父工程 创建子工程 maven聚合工程 SDK的下载和编译 下载并解压 编译前，需要有JDK，maven，编译好仓库位置。 进入解压目录，cmd中输入 mvn install -DskipTests，跳过测试并编译 有报错的，先将pl.搜出来，注释掉。 编译完成，最后将jar包部署到了仓库的如下位置。 搭建网络&amp;&amp;部署链码 将编写好的工程传到linux 给脚本执行权限 启动网络 进入容器 查看通道 安装链码 实例化链码 将a设置为123 取出a java外部服务调用 创建maven工程 工程根目录下创建一个cert目录，用于存放证书和私钥 将log4j.xml放到resources下 编写代码 首先定义一个实现了User接口的类","link":"/23955"}],"tags":[{"name":"赛后总结","slug":"赛后总结","link":"/tags/%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/"},{"name":"数论","slug":"数论","link":"/tags/%E6%95%B0%E8%AE%BA/"},{"name":"双端队列","slug":"双端队列","link":"/tags/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"组合数学","slug":"组合数学","link":"/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"乘法逆元","slug":"乘法逆元","link":"/tags/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/"},{"name":"思考题","slug":"思考题","link":"/tags/%E6%80%9D%E8%80%83%E9%A2%98/"},{"name":"最小生成树","slug":"最小生成树","link":"/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"Hyperledger","slug":"Hyperledger","link":"/tags/Hyperledger/"},{"name":"fabric","slug":"fabric","link":"/tags/fabric/"},{"name":"文档阅读","slug":"文档阅读","link":"/tags/%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB/"},{"name":"博弈论","slug":"博弈论","link":"/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"学习笔记","slug":"学习笔记","link":"/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"搜索","slug":"搜索","link":"/tags/%E6%90%9C%E7%B4%A2/"},{"name":"方法总结","slug":"方法总结","link":"/tags/%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"SpringMVC","slug":"SpringMVC","link":"/tags/SpringMVC/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"Mybatis","slug":"Mybatis","link":"/tags/Mybatis/"},{"name":"Tomcat","slug":"Tomcat","link":"/tags/Tomcat/"},{"name":"Axios","slug":"Axios","link":"/tags/Axios/"},{"name":"Hyperledger fabric","slug":"Hyperledger-fabric","link":"/tags/Hyperledger-fabric/"}],"categories":[{"name":"竞赛","slug":"竞赛","link":"/categories/%E7%AB%9E%E8%B5%9B/"},{"name":"技术","slug":"技术","link":"/categories/%E6%8A%80%E6%9C%AF/"},{"name":"文化课","slug":"文化课","link":"/categories/%E6%96%87%E5%8C%96%E8%AF%BE/"},{"name":"生活","slug":"生活","link":"/categories/%E7%94%9F%E6%B4%BB/"}]}